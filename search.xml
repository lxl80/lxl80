<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>二、Spring Cloud Consul 实战</title>
      <link href="/2020/111844419.html"/>
      <url>/2020/111844419.html</url>
      
        <content type="html"><![CDATA[<p>本文是 SpringCloud 实战教程第二篇， Spring Cloud 基于 <code>Hoxton.SR8</code> 版本，Spring Boot 基于<code>2.3.5.RELEASE</code>。使用Consul、OpenFeign组件。</p><h2 id="一、组件选型"><a href="#一、组件选型" class="headerlink" title="一、组件选型"></a>一、组件选型</h2><table><thead><tr><th>模块</th><th>组件</th><th>版本</th></tr></thead><tbody><tr><td>服务注册与发现</td><td>Spring Cloud Consul</td><td>1.8.5</td></tr><tr><td>声明式服务调用（含客户端负载均衡）</td><td>OpenFeign（Ribbon）</td><td></td></tr><tr><td>服务网关</td><td></td><td></td></tr><tr><td>负载均衡</td><td></td><td></td></tr><tr><td>熔断限流</td><td>Hystrix</td><td></td></tr><tr><td>配置中心</td><td>Spring Cloud Consul</td><td>1.8.5</td></tr></tbody></table><h2 id="二、服务注册和发现"><a href="#二、服务注册和发现" class="headerlink" title="二、服务注册和发现"></a>二、服务注册和发现</h2><h3 id="1、安装并运行-Consul"><a href="#1、安装并运行-Consul" class="headerlink" title="1、安装并运行 Consul"></a>1、安装并运行 Consul</h3><p>获取 Docker 镜像。当前最新版本1.8.5。</p><pre class="line-numbers language-bash"><code class="language-bash">$ docker pull consul:1.8.5<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>通过列出匹配的Docker镜像来检查映像是否已下载 <code>consul</code></p><pre class="line-numbers language-bash"><code class="language-bash">$ docker images -f <span class="token string">'reference=consul'</span>REPOSITORY          TAG                 IMAGE ID            CREATED             SIZEconsul              1.8.5               4f7b214361a7        3 weeks ago         122MB<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>配置并运行 Consul 服务器：</p><pre class="line-numbers language-bash"><code class="language-bash">docker run -d \  --name ConsulDiscovery \  -p 8500:8500 \  -p 8600:8600/udp \  consul:1.8.5 agent -server -ui -node<span class="token operator">=</span>server-1 -bootstrap-expect<span class="token operator">=</span>1 -client<span class="token operator">=</span>0.0.0.0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>由于以分离模式 <code>-d</code> 启动了容器，因此该进程将在后台运行。Consul Docker 镜像设置  <code>/consul/config</code> 为 Consul 的默认配置目录，代理将加载该目录中放置的所有配置文件。</p><p>在命令行查看版本号：</p><pre class="line-numbers language-bash"><code class="language-bash">$ docker <span class="token function">exec</span> ConsulDiscovery consul -vConsul v1.8.5Revision 1e03567d3Protocol 2 spoken by default, understands 2 to 3 <span class="token punctuation">(</span>agent will automatically use protocol <span class="token operator">></span>2 when speaking to compatible agents<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>服务已经启动，在浏览器中访问：<a href="http://localhost:8050" target="_blank" rel="noopener">http://localhost:8050</a>，显示的界面如下:</p><p><img src="../../../static/2020/image-20201118152231818.png" alt="Consul 服务首页"></p><h3 id="2、创建服务提供者注册到-Consul"><a href="#2、创建服务提供者注册到-Consul" class="headerlink" title="2、创建服务提供者注册到 Consul"></a>2、创建服务提供者注册到 Consul</h3><p>首先创建一个主 Maven 工程，在其 pom 文件引入依赖，Spring Boot版本为 <code>2.3.5.RELEASE</code>，Spring Cloud版本为 <code>Hoxton.SR8</code>。这个pom文件作为父pom文件，起到依赖版本控制的作用，其他 module 工程继承该pom。</p><pre class="line-numbers language-xml"><code class="language-xml"><span class="token prolog">&lt;?xml version="1.0" encoding="UTF-8"?></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>project</span> <span class="token attr-name">xmlns</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://maven.apache.org/POM/4.0.0<span class="token punctuation">"</span></span>         <span class="token attr-name"><span class="token namespace">xmlns:</span>xsi</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://www.w3.org/2001/XMLSchema-instance<span class="token punctuation">"</span></span>         <span class="token attr-name"><span class="token namespace">xsi:</span>schemaLocation</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>modelVersion</span><span class="token punctuation">></span></span>4.0.0<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>modelVersion</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>cn.lixl<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>SpringCloudDemo<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>0.0.1-SNAPSHOT<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>packaging</span><span class="token punctuation">></span></span>pom<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>packaging</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>name</span><span class="token punctuation">></span></span>SpringCloudDemo<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>name</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>description</span><span class="token punctuation">></span></span>Demo project for Spring Cloud<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>description</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>parent</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-starter-parent<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>2.3.5.RELEASE<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>relativePath</span><span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>parent</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>modules</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>module</span><span class="token punctuation">></span></span>eureka-server<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>module</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>module</span><span class="token punctuation">></span></span>eureka-client<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>module</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>module</span><span class="token punctuation">></span></span>consul-provider<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>module</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>modules</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>properties</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>project.build.sourceEncoding</span><span class="token punctuation">></span></span>UTF-8<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>project.build.sourceEncoding</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>project.reporting.outputEncoding</span><span class="token punctuation">></span></span>UTF-8<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>project.reporting.outputEncoding</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>java.version</span><span class="token punctuation">></span></span>1.8<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>java.version</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>spring-cloud.version</span><span class="token punctuation">></span></span>Hoxton.SR8<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>spring-cloud.version</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>properties</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependencyManagement</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependencies</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.cloud<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-cloud-dependencies<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>${spring-cloud.version}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>type</span><span class="token punctuation">></span></span>pom<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>type</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>scope</span><span class="token punctuation">></span></span>import<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>scope</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependencies</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependencyManagement</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>build</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>plugins</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>plugin</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-maven-plugin<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>plugin</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>plugins</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>build</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>project</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>创建 model 工程作为服务提供者，即： <code>consul-provider</code>。以 IDEA 工具为例：</p><p><img src="../../../static/2020/image-20201119105838400.png" alt="创建 consul-provider 模块"></p><p>编辑新创建工程的pom.xml文件，继承父pom文件，引入 <code>spring-cloud-starter-netflix-eureka-server</code> 的依赖：</p><pre class="line-numbers language-xml"><code class="language-xml">  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>parent</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>cn.lixl<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>SpringCloudDemo<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>0.0.1-SNAPSHOT<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>parent</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>consul-provider2<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>0.0.1-SNAPSHOT<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>name</span><span class="token punctuation">></span></span>consul-provider2<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>name</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>description</span><span class="token punctuation">></span></span>Demo project for Spring Cloud<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>description</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependencies</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.cloud<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-cloud-starter-consul-discovery<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-starter-web<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-starter-actuator<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependencies</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>通过在 application 启动类上加注解 <code>@EnableDiscoveryClient</code> 表明自己是一个 Discovery client：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@SpringBootApplication</span><span class="token annotation punctuation">@EnableDiscoveryClient</span><span class="token annotation punctuation">@RestController</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConsulProviderApplication</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Value</span><span class="token punctuation">(</span><span class="token string">"${server.port}"</span><span class="token punctuation">)</span>    String port<span class="token punctuation">;</span>    <span class="token annotation punctuation">@Value</span><span class="token punctuation">(</span><span class="token string">"${spring.application.name}"</span><span class="token punctuation">)</span>    String appName<span class="token punctuation">;</span>    <span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span><span class="token string">"/"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> String <span class="token function">home</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token string">"Consul service name: "</span> <span class="token operator">+</span> appName <span class="token operator">+</span><span class="token string">", port: "</span> <span class="token operator">+</span> port<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        SpringApplication<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span>ConsulProviderApplication<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在配置文件中注明服务注册中心地址，application.yml 配置文件如下：</p><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token key atrule">server</span><span class="token punctuation">:</span>  <span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token number">8763</span><span class="token key atrule">spring</span><span class="token punctuation">:</span>  <span class="token key atrule">application</span><span class="token punctuation">:</span>    <span class="token key atrule">name</span><span class="token punctuation">:</span> consul<span class="token punctuation">-</span>provider  <span class="token key atrule">cloud</span><span class="token punctuation">:</span>    <span class="token key atrule">consul</span><span class="token punctuation">:</span>      <span class="token key atrule">host</span><span class="token punctuation">:</span> localhost      <span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token number">8500</span>      <span class="token key atrule">discovery</span><span class="token punctuation">:</span>        <span class="token key atrule">service-name</span><span class="token punctuation">:</span> consul<span class="token punctuation">-</span>provider <span class="token comment" spellcheck="true">#注册到 Consul 的服务名称，客户端根据这个名称来进行服务调用。</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>为了模拟注册负载均衡，需要启动 2 个 <code>consul-producer</code> 模块。在 IDEA 工具中，复制 <code>consul-producer</code> 启动配置，覆盖运行端口为: <code>8764</code>。如图：</p><p><img src="../../../static/2020/image-20201121113901136.png" alt="复制启动配置并覆盖端口"></p><p>依次启动两个服务提供者项目，在浏览器上访问 <a href="http://localhost:8500" target="_blank" rel="noopener">http://localhost:8500</a>，可以看到 <code>consul-provider</code> 服务已经注册到 Consul 上了。</p><p><img src="../../../static/2020/image-20201119115132483.png" alt="Consul 服务首页"></p><p>点进去后可以看到有 2 个服务提供实例。这样服务提供者就准备好了。</p><p><img src="../../../static/2020/image-20201119202302348.png" alt="Consul 服务实例列表页"></p><h2 id="三、基于-OpenFeign-调用服务"><a href="#三、基于-OpenFeign-调用服务" class="headerlink" title="三、基于 OpenFeign 调用服务"></a>三、基于 OpenFeign 调用服务</h2><h3 id="1、OpenFeign-介绍"><a href="#1、OpenFeign-介绍" class="headerlink" title="1、OpenFeign 介绍"></a>1、OpenFeign 介绍</h3><p>Spring Cloud OpenFeign 是一种声明式、模板化的服务调用组件。简化了 RestTemplate 代码，实现了 Ribbon 负载均衡，使代码变得更加简洁。</p><p>OpenFeign 的使用主要分为以下几个步骤：</p><ul><li>服务消费者添加 Feign 依赖；</li><li>创建业务层接口，添加 <code>@FeignClient</code> 注解声明需要调用的服务；</li><li>业务层抽象方法使用 SpringMVC 注解配置服务地址及参数；</li><li>启动类添加 <code>@EnableFeignClients</code> 注解激活 Feign 组件。</li></ul><h3 id="2、声明式服务调用"><a href="#2、声明式服务调用" class="headerlink" title="2、声明式服务调用"></a>2、声明式服务调用</h3><p>与创建服务提供者方法一致，创建服务消费者 model 工程，即： <code>consul-consumer</code>。编辑pom.xml文件，引入 <code>spring-cloud-starter-openfeign</code> 依赖：</p><pre class="line-numbers language-xml"><code class="language-xml">    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependencies</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.cloud<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-cloud-starter-consul-discovery<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-starter-actuator<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.cloud<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-cloud-starter-openfeign<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-starter-web<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependencies</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>application.yml 配置文件如下：</p><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token key atrule">server</span><span class="token punctuation">:</span>  <span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token number">8765</span><span class="token key atrule">spring</span><span class="token punctuation">:</span>  <span class="token key atrule">application</span><span class="token punctuation">:</span>    <span class="token key atrule">name</span><span class="token punctuation">:</span> consul<span class="token punctuation">-</span>consumer  <span class="token key atrule">cloud</span><span class="token punctuation">:</span>    <span class="token key atrule">consul</span><span class="token punctuation">:</span>      <span class="token key atrule">host</span><span class="token punctuation">:</span> localhost      <span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token number">8500</span>      <span class="token key atrule">discovery</span><span class="token punctuation">:</span>        <span class="token key atrule">service-name</span><span class="token punctuation">:</span> consul<span class="token punctuation">-</span>consumer        <span class="token key atrule">register</span><span class="token punctuation">:</span> <span class="token boolean important">true       </span><span class="token comment" spellcheck="true"># 是否将自己注册到注册中心，默认为 true</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>定义业务层接口，并通过注解 <code>@FeignClient(value = &quot;服务名&quot;)</code> 绑定到服务提供方，在抽象方法上使用 SpringMVC 注解配置服务地址及参数：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@FeignClient</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">"consul-provider"</span><span class="token punctuation">)</span>  <span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">ConsumerService</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">"/"</span><span class="token punctuation">,</span>method <span class="token operator">=</span> RequestMethod<span class="token punctuation">.</span>GET<span class="token punctuation">)</span>    String <span class="token function">callConsulProvider</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在 application 启动类上加注解 <code>@EnableFeignClients</code> ，启用 Feign 进行远程调用：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@SpringBootApplication</span><span class="token annotation punctuation">@EnableDiscoveryClient</span><span class="token annotation punctuation">@RestController</span><span class="token annotation punctuation">@EnableFeignClients</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConsulConsumerApplication</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Autowired</span>    ConsumerService consumerService<span class="token punctuation">;</span>    <span class="token annotation punctuation">@Value</span><span class="token punctuation">(</span><span class="token string">"${server.port}"</span><span class="token punctuation">)</span>    String port<span class="token punctuation">;</span>    <span class="token annotation punctuation">@Value</span><span class="token punctuation">(</span><span class="token string">"${spring.application.name}"</span><span class="token punctuation">)</span>    String appName<span class="token punctuation">;</span>    <span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span><span class="token string">"/"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> String <span class="token function">home</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token string">"Consul service name: "</span> <span class="token operator">+</span> appName <span class="token operator">+</span><span class="token string">", port: "</span> <span class="token operator">+</span> port<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span><span class="token string">"/call"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> String <span class="token function">cllConsulProvider</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token string">"Call consul provider response: "</span><span class="token operator">+</span> consumerService<span class="token punctuation">.</span><span class="token function">cllConsulProvider</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        SpringApplication<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span>ConsulConsumerApplication<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>启动程序，然后多次访问： <a href="http://localhost:8765/call" target="_blank" rel="noopener">http://localhost:8765/call</a>，可以看到消费者在交替请求 2 个服务提供者：</p><pre class="line-numbers language-basic"><code class="language-basic"><span class="token keyword">Call</span> consul provider response<span class="token punctuation">:</span> Consul service <span class="token keyword">name</span><span class="token punctuation">:</span> consul<span class="token operator">-</span>provider<span class="token punctuation">,</span> port<span class="token punctuation">:</span> <span class="token number">8763</span><span class="token keyword">Call</span> consul provider response<span class="token punctuation">:</span> Consul service <span class="token keyword">name</span><span class="token punctuation">:</span> consul<span class="token operator">-</span>provider<span class="token punctuation">,</span> port<span class="token punctuation">:</span> <span class="token number">8764</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>到此，Feign 消费者验证成功。</p><h3 id="3、负载均衡配置"><a href="#3、负载均衡配置" class="headerlink" title="3、负载均衡配置"></a>3、负载均衡配置</h3><p>由于 Spring Cloud Feign 的客户端负载均衡是通过 Spring Cloud Ribbon 实现的，所以我们可以直接通过配置 Ribbon 客户端的方式来定义各个服务客户端调用的参数。</p><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token key atrule">ribbon</span><span class="token punctuation">:</span>  <span class="token key atrule">ConnectTimeout</span><span class="token punctuation">:</span> <span class="token number">600   </span><span class="token comment" spellcheck="true"># 连接超时时间</span>  <span class="token key atrule">ReadTimeout</span><span class="token punctuation">:</span> <span class="token number">5000     </span><span class="token comment" spellcheck="true"># 调用超时时间</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><blockquote><p>我们需要让 Hystrix 的超时时间大于 Ribbon 的超时时间，否则 Hystrix 命令超时后，该命令直接熔断，重试机制就没有任何意义了。</p></blockquote><h3 id="4、服务断路保护"><a href="#4、服务断路保护" class="headerlink" title="4、服务断路保护"></a>4、服务断路保护</h3><p>Feign 中的服务降级使用起来非常方便，只需要为 Feign 客户端定义的接口添加一个服务降级处理的实现类即可。下面我们为 ConsumerService 接口添加一个服务降级实现类，并对接口中的每个方法定义服务降级处理逻辑。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@Component</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConsumerServiceFallback</span> <span class="token keyword">implements</span> <span class="token class-name">ConsumerService</span><span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> String <span class="token function">callConsulProvider</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token string">"调用失败，服务被降级。"</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>修改 ConsumerService 接口，设置服务降级处理类为 <code>ConsumerServiceFallback.class</code>：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@FeignClient</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">"consul-provider"</span><span class="token punctuation">,</span> fallback <span class="token operator">=</span> ConsumerServiceFallback<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">// 声明需要调用的服务</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">ConsumerService</span> <span class="token punctuation">{</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>修改 application.yml，开启 Hystrix 功能 :</p><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token key atrule">feign</span><span class="token punctuation">:</span>  <span class="token key atrule">hystrix</span><span class="token punctuation">:</span>    <span class="token key atrule">enabled</span><span class="token punctuation">:</span> <span class="token boolean important">true  </span><span class="token comment" spellcheck="true"># 开启 Hystrix 服务降级功能</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>关闭 2 个 <code>consul-provider</code> 服务，重启 <code>consul-consumer</code> 服务，访问 <a href="http://localhost:8765/call" target="_blank" rel="noopener">http://localhost:8765/call</a>，可以看到页面显示服务降级信息。</p><p><img src="../../../static/2020/image-20201121191142237.png" alt="服务降级示例"></p><h3 id="5、调整日志级别"><a href="#5、调整日志级别" class="headerlink" title="5、调整日志级别"></a>5、调整日志级别</h3><p>Spring Cloud Feign 在构建被 @FeignClient 注解修饰的服务客户端时，会为每一个客户端都创建一个 Logger.Level 实例，我们可以利用该日志对象的 DEBUG 模式来帮助分析 Feign 的请求细节。日志级别：</p><ul><li>NONE：默认的，不显示任何日志；</li><li>BASIC：仅记录请求方法、URL、响应状态码及执行时间；</li><li>HEADERS：除了 BASIC 中定义的信息之外，还有请求和响应的头信息；</li><li>FULL：除了 HEADERS 中定义的信息之外，还有请求和响应的正文及元数据。</li></ul><p>通过 Java 配置类将 Feign 日志设定为 <code>FULL</code>：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@Configuration</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">FeignConfig</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Bean</span>    <span class="token keyword">public</span> Logger<span class="token punctuation">.</span>Level <span class="token function">feignLoggerLevel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> Logger<span class="token punctuation">.</span>Level<span class="token punctuation">.</span>FULL<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在 application.yml 中配置日志级别为：<code>debug</code> :</p><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token key atrule">logging</span><span class="token punctuation">:</span>  <span class="token key atrule">level</span><span class="token punctuation">:</span>    <span class="token key atrule">cn.lixl.consulconsumer</span><span class="token punctuation">:</span> debug<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>访问 <a href="http://localhost:8765/call" target="_blank" rel="noopener">http://localhost:8765/call</a> ，可以看到控制台显示出详细的日志：</p><pre class="line-numbers language-bash"><code class="language-bash">2020-11-21 16:36:10.240 DEBUG 52581 --- <span class="token punctuation">[</span>nio-8765-exec-2<span class="token punctuation">]</span> cn.lixl.consulconsumer.ConsumerService   <span class="token keyword">:</span> <span class="token punctuation">[</span>ConsumerService<span class="token comment" spellcheck="true">#callConsulProvider] ---> GET http://consul-provider/ HTTP/1.1</span>2020-11-21 16:36:10.240 DEBUG 52581 --- <span class="token punctuation">[</span>nio-8765-exec-2<span class="token punctuation">]</span> cn.lixl.consulconsumer.ConsumerService   <span class="token keyword">:</span> <span class="token punctuation">[</span>ConsumerService<span class="token comment" spellcheck="true">#callConsulProvider] ---> END HTTP (0-byte body)</span>2020-11-21 16:36:10.252 DEBUG 52581 --- <span class="token punctuation">[</span>nio-8765-exec-2<span class="token punctuation">]</span> cn.lixl.consulconsumer.ConsumerService   <span class="token keyword">:</span> <span class="token punctuation">[</span>ConsumerService<span class="token comment" spellcheck="true">#callConsulProvider] &lt;--- HTTP/1.1 200 (12ms)</span>2020-11-21 16:36:10.253 DEBUG 52581 --- <span class="token punctuation">[</span>nio-8765-exec-2<span class="token punctuation">]</span> cn.lixl.consulconsumer.ConsumerService   <span class="token keyword">:</span> <span class="token punctuation">[</span>ConsumerService<span class="token comment" spellcheck="true">#callConsulProvider] connection: keep-alive</span>2020-11-21 16:36:10.253 DEBUG 52581 --- <span class="token punctuation">[</span>nio-8765-exec-2<span class="token punctuation">]</span> cn.lixl.consulconsumer.ConsumerService   <span class="token keyword">:</span> <span class="token punctuation">[</span>ConsumerService<span class="token comment" spellcheck="true">#callConsulProvider] content-length: 48</span>2020-11-21 16:36:10.253 DEBUG 52581 --- <span class="token punctuation">[</span>nio-8765-exec-2<span class="token punctuation">]</span> cn.lixl.consulconsumer.ConsumerService   <span class="token keyword">:</span> <span class="token punctuation">[</span>ConsumerService<span class="token comment" spellcheck="true">#callConsulProvider] content-type: text/plain;charset=UTF-8</span>2020-11-21 16:36:10.253 DEBUG 52581 --- <span class="token punctuation">[</span>nio-8765-exec-2<span class="token punctuation">]</span> cn.lixl.consulconsumer.ConsumerService   <span class="token keyword">:</span> <span class="token punctuation">[</span>ConsumerService<span class="token comment" spellcheck="true">#callConsulProvider] date: Sat, 21 Nov 2020 08:36:10 GMT</span>2020-11-21 16:36:10.253 DEBUG 52581 --- <span class="token punctuation">[</span>nio-8765-exec-2<span class="token punctuation">]</span> cn.lixl.consulconsumer.ConsumerService   <span class="token keyword">:</span> <span class="token punctuation">[</span>ConsumerService<span class="token comment" spellcheck="true">#callConsulProvider] keep-alive: timeout=4</span>2020-11-21 16:36:10.253 DEBUG 52581 --- <span class="token punctuation">[</span>nio-8765-exec-2<span class="token punctuation">]</span> cn.lixl.consulconsumer.ConsumerService   <span class="token keyword">:</span> <span class="token punctuation">[</span>ConsumerService<span class="token comment" spellcheck="true">#callConsulProvider] proxy-connection: keep-alive</span>2020-11-21 16:36:10.253 DEBUG 52581 --- <span class="token punctuation">[</span>nio-8765-exec-2<span class="token punctuation">]</span> cn.lixl.consulconsumer.ConsumerService   <span class="token keyword">:</span> <span class="token punctuation">[</span>ConsumerService<span class="token comment" spellcheck="true">#callConsulProvider] </span>2020-11-21 16:36:10.255 DEBUG 52581 --- <span class="token punctuation">[</span>nio-8765-exec-2<span class="token punctuation">]</span> cn.lixl.consulconsumer.ConsumerService   <span class="token keyword">:</span> <span class="token punctuation">[</span>ConsumerService<span class="token comment" spellcheck="true">#callConsulProvider] Consul service name: consul-provider, port: 8764</span>2020-11-21 16:36:10.255 DEBUG 52581 --- <span class="token punctuation">[</span>nio-8765-exec-2<span class="token punctuation">]</span> cn.lixl.consulconsumer.ConsumerService   <span class="token keyword">:</span> <span class="token punctuation">[</span>ConsumerService<span class="token comment" spellcheck="true">#callConsulProvider] &lt;--- END HTTP (48-byte body)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="四、使用-Consul-作为配置中心"><a href="#四、使用-Consul-作为配置中心" class="headerlink" title="四、使用 Consul 作为配置中心"></a>四、使用 Consul 作为配置中心</h2><p>Consul 支持 Key/Value 键值对的存储，可以用来做配置中心。Spring Cloud 提供 Spring Cloud Consul Config 依赖和 Consul 集成。 </p><p>参照 consul-provider 创建配置中心模块：consul-config-client，在工程的 pom 文件中添加相关依赖：</p><pre class="line-numbers language-xml"><code class="language-xml">  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependencies</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.cloud<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-cloud-starter-consul-discovery<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.cloud<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-cloud-starter-consul-config<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-starter-actuator<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-starter-web<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependencies</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>新建配置文件 bootstrap.yml，对 Consul 进行配置：</p><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token key atrule">spring</span><span class="token punctuation">:</span>  <span class="token key atrule">cloud</span><span class="token punctuation">:</span>    <span class="token key atrule">consul</span><span class="token punctuation">:</span>      <span class="token key atrule">config</span><span class="token punctuation">:</span>        <span class="token key atrule">enabled</span><span class="token punctuation">:</span> <span class="token boolean important">true   </span><span class="token comment" spellcheck="true"># 是否启用配置中心功能</span>        <span class="token key atrule">format</span><span class="token punctuation">:</span> yaml <span class="token comment" spellcheck="true"># 配置值格式</span>        <span class="token key atrule">prefix</span><span class="token punctuation">:</span> SpringCloudDemo <span class="token comment" spellcheck="true"># 配置数据所在目录</span>        <span class="token key atrule">data-key</span><span class="token punctuation">:</span> consul<span class="token punctuation">-</span>config<span class="token punctuation">-</span>data  <span class="token comment" spellcheck="true"># 配置key的名字</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>application.yml 配置文件如下：</p><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token key atrule">server</span><span class="token punctuation">:</span>  <span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token number">8766</span><span class="token key atrule">spring</span><span class="token punctuation">:</span>  <span class="token key atrule">application</span><span class="token punctuation">:</span>    <span class="token key atrule">name</span><span class="token punctuation">:</span> consul<span class="token punctuation">-</span>config<span class="token punctuation">-</span>client  <span class="token key atrule">cloud</span><span class="token punctuation">:</span>    <span class="token key atrule">consul</span><span class="token punctuation">:</span>      <span class="token key atrule">host</span><span class="token punctuation">:</span> localhost      <span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token number">8500</span>      <span class="token key atrule">discovery</span><span class="token punctuation">:</span>        <span class="token key atrule">service-name</span><span class="token punctuation">:</span> consul<span class="token punctuation">-</span>config<span class="token punctuation">-</span>client        <span class="token key atrule">register</span><span class="token punctuation">:</span> <span class="token boolean important">false</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>创建 ConfigClientController，从 Consul 配置中心中获取配置信息：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@RestController</span><span class="token annotation punctuation">@RefreshScope</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConfigClientController</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Value</span><span class="token punctuation">(</span><span class="token string">"${config.project.name}"</span><span class="token punctuation">)</span>    <span class="token keyword">private</span> String projectName<span class="token punctuation">;</span>    <span class="token annotation punctuation">@GetMapping</span><span class="token punctuation">(</span><span class="token string">"/project-name"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> String <span class="token function">getProjectName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> projectName<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在 Consul 中添加如下配置：</p><p><img src="../../../static/2020/image-20201120160044138.png" alt="在 Consul 中添加配置"></p><p>启动 consul-config-client，调用接口 <a href="http://localhost:8766" target="_blank" rel="noopener">http://localhost:8766</a> 查看配置信息，页面会显示配置值：<code>SpringCloudDemo</code>。只要修改下 Consul 中的配置信息，再次调用此接口，就会发现配置已经刷新。</p><h2 id="五、服务网关-Spring-Cloud-GateWay"><a href="#五、服务网关-Spring-Cloud-GateWay" class="headerlink" title="五、服务网关 Spring Cloud GateWay"></a>五、服务网关 Spring Cloud GateWay</h2><h3 id="1、简介"><a href="#1、简介" class="headerlink" title="1、简介"></a>1、简介</h3><p>Spring Cloud Gateway 作为 Spring Cloud 生态系统中的网关，目标是替代 Netflix Zuul，其不仅提供统一的路由方式，并且基于 Filter 链的方式提供了网关基本的功能，例如：安全，监控/指标，和限流。</p><h4 id="Spring-Cloud-Gateway-具有如下特性："><a href="#Spring-Cloud-Gateway-具有如下特性：" class="headerlink" title="Spring Cloud Gateway 具有如下特性："></a>Spring Cloud Gateway 具有如下特性：</h4><ul><li>基于Spring Framework 5, Project Reactor 和 Spring Boot 2.0 进行构建；</li><li>动态路由：能够匹配任何请求属性；</li><li>可以对路由指定 Predicate（断言）和 Filter（过滤器）；</li><li>集成Hystrix的断路器功能；</li><li>集成 Spring Cloud 服务发现功能；</li><li>易于编写的 Predicate（断言）和 Filter（过滤器）；</li><li>请求限流功能；</li><li>支持路径重写。</li></ul><h4 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h4><ul><li>Route（路由）：路由是构建网关的基本模块，它由ID，目标URI，一系列的断言和过滤器组成，如果断言为 true 则匹配该路由；</li><li>Predicate（断言）：路由组成的一部分，主要负责路由的匹配，来决定此次请求是否匹配路由，我们可以使用它匹配来自 HTTP 请求的任何内容，比如路径、参数或者 header 信息等。</li><li>Filter（过滤器）：指的是 Spring 框架中 GatewayFilter 的实例，请求经过 Predicate 匹配路由之后执行 Filter，我们可以使用它修改请求和响应。</li></ul><p><img src="../../../static/2020/f80c1ca6d7635aa5f1318dcf528b894b.png" alt="Spring Cloud Gateway 运行架构"></p><p>客户端向 Spring Cloud Gateway 发出请求。如果 Gateway Handler Mapping 中找到与请求相匹配的路由，将其发送到 Gateway Web Handler。Handler 再通过指定的过滤器链来将请求发送到我们实际的服务执行业务逻辑，然后返回。前置过滤器在代理请求之前运行，后置过滤器收到代理响应后开始起作用。筛选器提供了在两者之间修改流程的机制。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://learn.hashicorp.com/tutorials/consul/docker-container-agents" target="_blank" rel="noopener">Consul with Containers</a></li><li><a href="http://www.ityouknow.com/springcloud/2018/07/20/spring-cloud-consul.html" target="_blank" rel="noopener">注册中心 Consul 使用详解</a></li><li><a href="https://cloud.tencent.com/developer/article/1526674" target="_blank" rel="noopener">Spring Cloud Consul：服务治理与配置中心</a></li><li><a href="https://github.com/forezp/SpringCloudLearning" target="_blank" rel="noopener">Spring Cloud Learning</a></li><li><a href="https://www.jianshu.com/p/562045489d9d" target="_blank" rel="noopener">服务消费（LoadBalancerClient、Ribbon、Feign）</a></li><li><a href="https://cloud.tencent.com/developer/article/1468371" target="_blank" rel="noopener">Spring Cloud 之 Feign</a></li><li><a href="https://juejin.cn/post/6844903959086235655#heading-9" target="_blank" rel="noopener">Spring Cloud OpenFeign：基于Ribbon和Hystrix的声明式服务调用</a></li><li><a href="https://mp.weixin.qq.com/s/uKteoRrFjUbbl08NG522YQ" target="_blank" rel="noopener">Spring Cloud Ribbon：负载均衡的服务调用</a></li><li><a href="https://mp.weixin.qq.com/s/lEjojtuH7XOM9emXkd0TkQ" target="_blank" rel="noopener">Spring Cloud Hystrix：服务容错保护</a></li><li><a href="https://cloud.tencent.com/developer/article/1528557" target="_blank" rel="noopener">Spring Cloud Gateway：新一代API网关服务</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 微服务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringCloud </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一、Spring Cloud 介绍及组件选择</title>
      <link href="/2020/11128669.html"/>
      <url>/2020/11128669.html</url>
      
        <content type="html"><![CDATA[<h2 id="系列文章介绍"><a href="#系列文章介绍" class="headerlink" title="系列文章介绍"></a>系列文章介绍</h2><p>本文是《Spring Cloud 实战教程》第一篇，原文发布于个人博客：<a href="https://www.lixl.cn/">悟尘记</a>。</p><p>此系列文章共包括如下章节：</p><ul><li>一、Spring Cloud 介绍及组件选择</li><li>二、Spring Cloud Consul 实战</li><li>三、Spring Cloud Alibaba 实战</li></ul><h2 id="一、初识-Spring-Cloud"><a href="#一、初识-Spring-Cloud" class="headerlink" title="一、初识 Spring Cloud"></a>一、初识 Spring Cloud</h2><h3 id="1、概览"><a href="#1、概览" class="headerlink" title="1、概览"></a>1、概览</h3><p>Spring Cloud 为微服务架构提供了标准化、全站式的技术方案。它利用Spring Boot的开发便利性巧妙地简化了分布式系统基础设施的开发，如服务发现注册、配置中心、消息总线、负载均衡、断路器、数据监控等，都可以用Spring Boot的开发风格做到一键启动和部署。</p><p><img src="../../../static/2020/w1280-20201115184216333.png" alt="Spring Cloud 架构图"></p><h3 id="2、特性"><a href="#2、特性" class="headerlink" title="2、特性"></a>2、特性</h3><p>Spring Cloud 专注于为典型的用例和可扩展性机制（包括其他用例）提供良好的开箱即用体验，主要致力于解决如下问题：</p><ul><li>分布式/版本化配置</li><li>服务注册和发现</li><li>服务路由</li><li>服务调用</li><li>负载均衡</li><li>断路器</li><li>全局锁</li><li>分布式消息传递</li></ul><h3 id="3、版本介绍"><a href="#3、版本介绍" class="headerlink" title="3、版本介绍"></a>3、版本介绍</h3><p>Spring Cloud 是一个由各个独立组件组成的综合项目，4年时间发布了 46 个版本，更新换代非常快。每个组件有着不同的发布节奏，需要选择匹配的组件版本确保兼容性：</p><table><thead><tr><th align="left">Spring Cloud Version</th><th align="left">Boot Version</th></tr></thead><tbody><tr><td align="left">2020.0.x aka Ilford</td><td align="left">2.4.x</td></tr><tr><td align="left">Hoxton</td><td align="left">2.2.x, 2.3.x (Starting with SR5)</td></tr><tr><td align="left">Greenwich</td><td align="left">2.1.x</td></tr><tr><td align="left">Finchley</td><td align="left">2.0.x</td></tr><tr><td align="left">Edgware</td><td align="left">1.5.x</td></tr><tr><td align="left">Dalston</td><td align="left">1.5.x</td></tr></tbody></table><p>最新版本请参考官网: <a href="https://spring.io/projects/spring-cloud#overview。" target="_blank" rel="noopener">https://spring.io/projects/spring-cloud#overview。</a></p><h2 id="二、Spring-Cloud-规范下的实现"><a href="#二、Spring-Cloud-规范下的实现" class="headerlink" title="二、Spring Cloud 规范下的实现"></a>二、Spring Cloud 规范下的实现</h2><p>Spring Cloud 不是 Spring 团队全新研发的框架，他把常见的微服务组件基于 Spring Cloud 规范进行了整合。其中 Spring Cloud Netflix、Spring Cloud Consul、Spring Cloud Alibaba 是这套规范下的知名实现。</p><h3 id="1、Spring-Cloud-Netflix"><a href="#1、Spring-Cloud-Netflix" class="headerlink" title="1、Spring Cloud Netflix"></a>1、Spring Cloud Netflix</h3><p>业界对 Spring Cloud 使用最广的就是 Spring Cloud Netflix 了，在 Spring Cloud 发展之初，Netflix 做了很大的贡献。包括以下组件：</p><ul><li>Eureka：服务注册与发现</li><li>Zuul：服务网关</li><li>Ribbon：负载均衡</li><li>Feign：远程服务的客户端代理</li><li>Hystrix：断路器，提供服务熔断和限流功能</li><li>Hystrix Dashboard：监控面板</li><li>Turbine：聚合各个服务实例上的监控信息</li></ul><p>随着 Netflix 宣布 Eureka 2.0 不再开发，Hystrix、Ribbon、Archaius 不再维护，Zuul 被 Spring Cloud Gateway 代替。Spring Cloud 也在 RoadMap 中宣布 Ilford 版本（<a href="https://github.com/spring-cloud/spring-cloud-release/wiki/Spring-Cloud-2020.0-Release-Notes" target="_blank" rel="noopener">发行说明</a>）发布的时候删除这些维护模块，所以不建议继续使用 Spring Cloud Netflix 这套实现。</p><h3 id="2、Spring-Cloud-Consul"><a href="#2、Spring-Cloud-Consul" class="headerlink" title="2、Spring Cloud Consul"></a>2、Spring Cloud Consul</h3><p>Consul 是 HashiCorp 公司推出的开源软件，基于 Go 语言开发，提供了服务注册与发现框架、分布一致性协议实现、健康检查、Key/Value存储、多数据中心方案，不再需要依赖其他工具（比如ZooKeeper等）。</p><p>Spring Cloud Consul 通过自动配置并绑定到 Spring Environment 和其他 Spring 编程模型习惯用法，为Spring Boot应用程序提供Consul集成。通过一些简单的注释，您可以快速启用和配置应用程序中的通用模式。</p><h4 id="主要特性："><a href="#主要特性：" class="headerlink" title="主要特性："></a>主要特性：</h4><ul><li>支持服务治理：Consul 作为注册中心时，微服务中的应用可以向 Consul 注册自己，并且可以从 Consul 获取其他应用信息；</li><li>支持客户端负责均衡：包括 Ribbon 和 Spring Cloud LoadBalancer；</li><li>支持 Zuul：当 Zuul 作为网关时，可以从 Consul 中注册和发现应用；</li><li>支持分布式配置管理：Consul 作为配置中心时，使用键值对来存储配置信息；</li><li>支持控制总线：可以在整个微服务系统中通过 Control Bus 分发事件消息。</li></ul><h3 id="3、Spring-Cloud-Alibaba"><a href="#3、Spring-Cloud-Alibaba" class="headerlink" title="3、Spring Cloud Alibaba"></a>3、Spring Cloud Alibaba</h3><p>Spring Cloud Alibaba 是由阿里巴巴团队主导，致力于提供微服务开发的一站式解决方案。此项目包含开发分布式应用微服务的必需组件，方便开发者通过 Spring Cloud 编程模型轻松使用这些组件来开发分布式应用服务。依托 Spring Cloud Alibaba，您只需要添加一些注解和少量配置，就可以将 Spring Cloud 应用接入阿里微服务解决方案，通过阿里中间件来迅速搭建分布式应用系统。</p><p>对于中国用户来说，Spring Cloud Alibaba 还有一个非常特殊的意义：它将曾经红极一时的 Dubbo，以及阿里巴巴的强力消息中间件 RocketMQ 融入 Spring Cloud 体系。</p><h4 id="主要功能："><a href="#主要功能：" class="headerlink" title="主要功能："></a>主要功能：</h4><ul><li><strong>服务限流降级</strong>：默认支持 WebServlet、WebFlux, OpenFeign、RestTemplate、Spring Cloud Gateway, Zuul, Dubbo 和 RocketMQ 限流降级功能的接入，可以在运行时通过控制台实时修改限流降级规则，还支持查看限流降级 Metrics 监控。</li><li><strong>服务注册与发现</strong>：适配 Spring Cloud 服务注册与发现标准，默认集成了 Ribbon 的支持。</li><li><strong>分布式配置管理</strong>：支持分布式系统中的外部化配置，配置更改时自动刷新。</li><li><strong>消息驱动能力</strong>：基于 Spring Cloud Stream 为微服务应用构建消息驱动能力。</li><li><strong>分布式事务</strong>：使用 @GlobalTransactional 注解， 高效并且对业务零侵入地解决分布式事务问题。。</li><li><strong>阿里云对象存储</strong>：阿里云提供的海量、安全、低成本、高可靠的云存储服务。支持在任何应用、任何时间、任何地点存储和访问任意类型的数据。</li><li><strong>分布式任务调度</strong>：提供秒级、精准、高可靠、高可用的定时（基于 Cron 表达式）任务调度服务。同时提供分布式的任务执行模型，如网格任务。网格任务支持海量子任务均匀分配到所有 Worker（schedulerx-client）上执行。</li><li><strong>阿里云短信服务</strong>：覆盖全球的短信服务，友好、高效、智能的互联化通讯能力，帮助企业迅速搭建客户触达通道。</li></ul><p>更多功能请参考 <a href="https://github.com/alibaba/spring-cloud-alibaba/blob/master/Roadmap-zh.md" target="_blank" rel="noopener">Roadmap</a>。</p><h2 id="三、常用组件介绍"><a href="#三、常用组件介绍" class="headerlink" title="三、常用组件介绍"></a>三、常用组件介绍</h2><h3 id="2、服务注册与发现"><a href="#2、服务注册与发现" class="headerlink" title="2、服务注册与发现"></a>2、服务注册与发现</h3><p>通过使用独立的组件进行服务的注册和查询，可以实现调用方和服务提供方的信息解耦。以下4种组件Spring Cloud都提供了集成方案：</p><ul><li><strong>Eureka</strong>: 使用人数最多也最成熟，Spring Cloud Netflix的默认实现，网上资料非常丰富；无需独立部署，可以嵌入到应用内（就是一个servlet程序）。但Eureka 1后续不会再有新版本更新了，2.0又不会开源，官方已经不建议使用。</li><li><strong>Consul</strong>：作为Eureka的官方候补，是Spring Cloud目前主要支持的实现，各方面功能都很全面。随着 Eureka 2.x 版本停止开发，Spring Cloud 官方建议用 Spring Cloud Consul 来替代。</li><li><strong>Nacos</strong>：阿里开源的产品，功能对标 Consul，CAP模型中不仅支持CP也支持AP，使用Dubbo时的首选注册中心。</li><li><strong>ZooKeeper</strong>：一个通用的分布式协调器，也可以作为注册中心使用，Spring Cloud提供了集成支持，如果项目本身也依赖于ZooKeeper，就无需再单独部署新的组件了；但zookeeper缺少一些对于注册中心来说比较重要的特性，比如健康检查和DNS服务集成等。</li></ul><p>下面是网上找的一个特性对比图：</p><p><img src="../../../static/2020/20201115195838.png" alt="服务注册与发现组件特性对比图"></p><h3 id="3、分布式配置管理"><a href="#3、分布式配置管理" class="headerlink" title="3、分布式配置管理"></a>3、分布式配置管理</h3><p>采用统一的配置中心的主要目的是为了简化运维和动态刷新配置。通过提供配置变更、配置推送、历史版本管理、灰度发布、配置变更审计等配置管理操作，配置中心帮助您集中管理所有生产环境中的配置，降低分布式系统中管理配置的成本，并降低因错误的配置变更带来可用性下降甚至发生故障的风险。Spring Cloud 集成的解决方案包括下面几种：</p><ul><li><strong>Nacos</strong>：2018年6月，阿里开源的配置中心。如果已经用Nacos作为注册中心，不想单独部署配置管理中心，nacos是最佳选择。</li><li><strong>Consul</strong>：直接利用Consul 的KV存储功能来存储配置项，如果采用Consul作为注册中心则不需要再引入额外的系统，可以在Consul的管理后台直接编辑配置信息。</li><li><strong>Spring Cloud Config</strong> : 以文件的方式加载远程配置，提供了定义良好的REST风格API用来访问配置文件，且可以自动转换配置文件的格式；但需要结合结合版本控制工具使用，如GIT，SVN等等；动态配置更新还需要配合Spring Cloud Bus和MQ组件使用；也没有提供维护配置的界面。</li><li><strong>Apollo</strong>： 携程开源的配置管理中心，具备规范的权限、流程治理等特性。能够集中化管理应用不同环境、不同集群的配置，配置修改后能够实时推送到应用端，并且具备规范的权限、流程治理等特性，适用于微服务配置管理场景。</li></ul><h3 id="4、服务网关"><a href="#4、服务网关" class="headerlink" title="4、服务网关"></a>4、服务网关</h3><p>服务网关是外部系统（前端，手机端等等）访问微服务的一个反向代理服务器。默认的实现是 zuul，但和 Eureka 的情况类似，Netflix 后续的2.0版本不断跳票，Spring忍无可忍最后自己搞了一个网关出来 <a href="https://spring.io/projects/spring-cloud-gateway" target="_blank" rel="noopener">Spring Cloud Gateway</a> 出来。后面zuul 2.0开源以后，Spring Cloud似乎也不打算再集成进来了。</p><ul><li><strong>Zuul</strong> : 和 Eureka 的情况类似，成熟，流行。缺点是基于Servlet 2.5构建，阻塞式的 API，性能不够好，不支持长连接。后面zuul 2.0开源以后，Spring Cloud似乎也不打算再集成了。</li><li><strong>Spring Cloud Gateway</strong> : 基于 Spring Boot 2.x 响应式的、非阻塞式的 API开发，性能更好，也支持长连接，后续的维护集成不用担心。</li><li><strong>Nginx</strong> : 性能是最好的，结合Consul Template也能够实现服务的动态负载均衡。但缺点是和Spring Cloud整合相对困难一些，缺少类似于过滤器，断路保护等特性的原生支持。</li></ul><h3 id="5、服务间调用和负载均衡"><a href="#5、服务间调用和负载均衡" class="headerlink" title="5、服务间调用和负载均衡"></a>5、服务间调用和负载均衡</h3><p>选择比较少，常用的是 Feign（声明式http客户端）+ Ribbon（客户端负载均衡），但 Spring Cloud Ribbon 项目目前已经处于维护模式，使用时会有警告；另一种选择是使用阿里的 Dubbo。Spring也开发了自己的负载均衡器 spring-cloud-loadbalancer，可以用来取代Ribbon的位置。</p><ul><li><strong>OpenFeign</strong> : 是 Spring Cloud 的一个子项目，为微服务架构下服务之间的调用提供解决方案。可以动态创建基于Spring MVC注解的接口实现服务调用，在 SpringCloud 2.0 中已经取代 Feign 成为了一等公民，并且集成了 Ribbon 来做负载均衡。</li><li><strong>Dubbo</strong> : 自带负载均衡策略；可以使用自有的二级制 RPC 协议，占用带宽更少，性能更好 ；如果要使用的话最好采用 Spring Cloud Alibaba 套件的整套解决方案；但 Dubbo 的服务调用方需要依赖于提供方的接口Jar包，解耦并不彻底；由于使用的是自定义协议，跨语言调用比较困难。</li></ul><h3 id="6、熔断限流"><a href="#6、熔断限流" class="headerlink" title="6、熔断限流"></a>6、熔断限流</h3><p>为了避免“雪崩”，需要引入熔断机制。利用断路器对某个服务的故障进行监控，一旦发现服务不可用，就立即对调用方返回错误响应（或者做一些应急处理，也就是服务降级），避免了调用方的长时间等待。目前Spring Cloud已经集成的断路器有：Hystrix，Sentinel，Resilience4j。</p><ul><li><strong>Hystrix</strong>：2018年12月，Spring官方宣布Netflix的相关项目进入维护模式（Maintenance Mode）。不再开发新的功能，但是Hystrix整体上还是比较稳定的，对于老用户不必更换，影响也不大。</li><li><strong>Resilience4j</strong>：Hystrix停更之后，Netflix官方推荐使用resilience4j，它是一个轻量、易用、可组装的高可用框架，支持熔断、高频控制、隔离、限流、限时、重试等多种高可用机制。</li><li><strong>Sentinel</strong>：阿里中间件团队开源的，面向分布式服务架构的轻量级高可用流量控制组件，主要以流量为切入点，从流量控制、熔断降级、系统负载保护等多个维度来帮助用户保护服务的稳定性。</li></ul><p>功能对比可参考：<a href="https://github.com/alibaba/Sentinel/wiki/Guideline:-%E4%BB%8E-Hystrix-%E8%BF%81%E7%A7%BB%E5%88%B0-Sentinel" target="_blank" rel="noopener">Guideline: 从 Hystrix 迁移到 Sentinel</a></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://spring.io/projects/spring-cloud#overview" target="_blank" rel="noopener">Spring Cloud 官方文档</a></li><li><a href="https://github.com/spring-cloud/spring-cloud-release/wiki/Spring-Cloud-2020.0-Release-Notes" target="_blank" rel="noopener">Spring Cloud 2020.0 Release Notes</a></li><li><a href="https://blog.csdn.net/csdnnews/article/details/105304531" target="_blank" rel="noopener">4 年 46 个版本，一文读懂 Spring Cloud 发展历史</a></li><li><a href="https://static.kancloud.cn/hanxt/springcloud/1599297" target="_blank" rel="noopener">Spring Cloud组件的选型</a></li><li><a href="https://github.com/alibaba/spring-cloud-alibaba/blob/master/README-zh.md" target="_blank" rel="noopener">Spring Cloud Alibaba</a></li><li><a href="https://spring-cloud-alibaba-group.github.io/github-pages/hoxton/zh-cn/index.html" target="_blank" rel="noopener">Spring Cloud Alibaba 参考文档</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 微服务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringCloud </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>北京市通州区与河北省三河、大厂、香河三县市协同发展规划（转载）</title>
      <link href="/2020/052048798.html"/>
      <url>/2020/052048798.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文转载自：<a href="https://www.ndrc.gov.cn/xxgk/zcfb/ghwb/202003/t20200317_1223417.html" target="_blank" rel="noopener">中华人民共和国国家发展和改革委员会官方网站</a>，发布时间：2020年03月17日。</p></blockquote><p>  京津冀协同发展是习近平总书记亲自谋划、亲自决策、亲自推动的重大国家战略。规划建设北京城市副中心是以习近平同志为核心的党中央作出的重大战略部署，是千年大计、国家大事。深入推进北京市通州区与河北省三河、大厂、香河三县市（以下简称“通州区与北三县”）协同发展对于推进北京非首都功能疏解、优化首都发展格局、建设以首都为核心的世界级城市群、保障北京城市副中心高质量发展具有重大而深远的意义。</p><p>  在党中央、国务院坚强领导下，按照京津冀协同发展领导小组（以下简称“领导小组”）统筹部署，领导小组办公室会同北京市、河北省，以习近平新时代中国特色社会主义思想为指导，全面贯彻党的十九大和十九届二中、三中、四中全会精神，依据《京津冀协同发展规划纲要》《北京城市总体规划（2016年—2035年）》，坚持高起点、高标准，落实世界眼光、国际标准、中国特色、高点定位的要求，按照“统一规划、统一政策、统一标准、统一管控”的原则，编制《北京市通州区与河北省三河、大厂、香河三县市协同发展规划》。</p><p>  本规划是指导通州区与北三县规划建设的基本依据。规划范围包括北京市通州区和河北省廊坊市所辖三河市、大厂回族自治县、香河县行政辖区范围，国土总面积2164平方公里。规划近期至2025年，远期至2035年。</p><h2 id="第一章-总体要求"><a href="#第一章-总体要求" class="headerlink" title="第一章 总体要求"></a>第一章 总体要求</h2><p>  深入贯彻落实习近平总书记关于京津冀协同发展和北京城市副中心规划建设的重要指示精神，紧紧抓住疏解北京非首都功能这个“牛鼻子”，坚持“一盘棋”谋划，打破“一亩三分地”思维定势，充分发挥城市副中心示范引领作用，辐射带动北三县协同发展，打造新时代推进高质量发展的典范。</p><h3 id="第一节-重大意义"><a href="#第一节-重大意义" class="headerlink" title="第一节 重大意义"></a><strong>第一节 重大意义</strong></h3><p>  通州区与北三县共处京冀交界地区，地缘相邻、人缘相亲、生态相融、文化相近，具有良好的协同发展基础。深入推进通州区与北三县协同发展，有利于疏解北京非首都功能，治理大城市病，优化首都发展格局，探索人口经济密集地区优化开发新模式；有利于推进北京城市副中心建设，拓展发展新空间，形成新的增长极；有利于落实 “统一规划、统一政策、统一标准、统一管控” 的要求，破解协同发展中的突出问题，探索京津冀协同发展的新机制；有利于解决城乡发展不平衡不充分的现实矛盾，满足人民群众对美好生活的向往，探索新型城镇化发展路径。</p><h3 id="第二节-发展现状"><a href="#第二节-发展现状" class="headerlink" title="第二节 发展现状"></a><strong>第二节 发展现状</strong></h3><p>  通州区与北三县位于北京市东部，是京津冀协同发展的重点地区，空间紧邻、联系紧密，协同发展需求迫切，但长期以来各自为政，跨界协同发展缺乏有效途径，发展中暴露出一些突出问题。<strong>空间布局缺乏协调，</strong>功能组织松散，职住不平衡问题突出，贴边连片发展问题严重。<strong>资源环境约束趋紧，</strong>大气环境质量超标严重，水资源瓶颈制约明显，地下水超采严重，主要河流水质仅为V类，森林覆盖率不足30%。<strong>跨界交通问题突出，</strong>交通拥堵严重，尤其是早晚高峰时段交通秩序混乱。<strong>产业发展结构失衡，</strong>传统产业多，新兴产业少，产业层次低，就业吸纳能力不强，过度依赖房地产开发。<strong>公共服务落差明显，</strong>两地在教育和医疗等公共服务领域的资源配置、服务水平、设施标准存在明显落差。</p><h3 id="第三节-指导思想"><a href="#第三节-指导思想" class="headerlink" title="第三节 指导思想"></a><strong>第三节 指导思想</strong></h3><p>  以习近平新时代中国特色社会主义思想为指导，全面贯彻党的十九大和十九届二中、三中、四中全会精神，坚持和加强党的全面领导，统筹推进“五位一体”总体布局，协调推进“四个全面”战略布局，坚持以人民为中心的发展思想，坚持稳中求进的工作总基调，坚持新发展理念，坚持以供给侧结构性改革为主线，坚持以改革开放为动力，推动高质量发展，紧紧抓住疏解北京非首都功能这个“牛鼻子”，落实“统一规划、统一政策、统一标准、统一管控”的要求，按照整体谋划、协同创新、减量提质、互利共赢的总体思路，坚持世界眼光、国际标准、中国特色、高点定位，坚持政府引导、市场运作，以先进的理念打造新时代高质量发展的典范。</p><h3 id="第四节-战略定位"><a href="#第四节-战略定位" class="headerlink" title="第四节 战略定位"></a><strong>第四节 战略定位</strong></h3><p>  贯彻落实党中央、国务院决策部署，立足服务京津冀协同发展大局，以北京城市副中心建设为统领，着力打造国际一流和谐宜居之都示范区、新型城镇化示范区、京津冀区域协同发展示范区。</p><p>  <strong>——国际一流和谐宜居之都示范区。</strong>坚持以人民为中心的发展思想，践行绿水青山就是金山银山的理念，对标国际一流城市的宜居建设标准，建设生态环境卓越、人与自然和谐、经济活跃繁荣、文化特色鲜明、社会安定和谐、人民生活幸福的美丽家园。</p><p>  <strong>——新型城镇化示范区。</strong>遵循超大城市地区的城镇化发展规律，妥善处理好城与乡的关系，建立健全城乡融合发展体制机制，着力推进户籍制度、社会保障制度、土地制度改革，创新政策体系，探索新型城镇化的发展模式，实现城乡规划、资源配置、设施建设、产业发展、公共服务、社会治理的一体化，让城乡居民共享发展成果。</p><p>  <strong>——京津冀区域协同发展示范区。</strong>充分发挥北京城市副中心的辐射带动作用，推进通州区与北三县高质量发展，实现功能分工协同、交通互联互通、生态共建共管、设施共建共享、安全联防联控，探索统一规划、统一政策、统一标准、统一管控的协同机制，成为京津冀交界地区协同发展的典范。</p><h3 id="第五节-发展目标"><a href="#第五节-发展目标" class="headerlink" title="第五节 发展目标"></a><strong>第五节 发展目标</strong></h3><p>  <strong>到2025年，</strong>协同发展机制建立并有效发挥作用，环境治理、基础设施、公共服务、工程技术等领域形成统一的标准体系。城乡空间和功能格局进一步优化，重点生态修复与建设工程基本完成，轨道交通建设取得突破性进展，非首都功能疏解和产业园区共建取得实质进展，公共服务落差逐步缩小。</p><p>  <strong>到2035年，</strong>协同发展的体制机制更加完善，高效一体的空间格局基本形成，生态环境质量根本改善，智能绿色的交通体系基本形成，创新引领的现代经济体系基本建立，基本公共服务基本实现均等化，绿色城市、森林城市、海绵城市、智慧城市基本建成。</p><h2 id="第二章-共同构筑协同发展的空间格局"><a href="#第二章-共同构筑协同发展的空间格局" class="headerlink" title="第二章 共同构筑协同发展的空间格局"></a><strong>第二章 共同构筑协同发展的空间格局</strong></h2><p>  坚持“一张蓝图干到底”，统筹生产、生活、生态三大空间，强化水资源刚性约束，实施留白增绿战略，构建新型城乡格局，融入区域开放大局，逐步形成蓝绿交织、清新明亮、水城共融、多组团集约紧凑发展的空间格局。</p><h3 id="第一节-优化国土空间格局"><a href="#第一节-优化国土空间格局" class="headerlink" title="第一节 优化国土空间格局"></a><strong>第一节 优化国土空间格局</strong></h3><p>  <strong>科学划定规划控制线。</strong>科学划定生态保护红线、永久基本农田、城镇开发边界三条控制线，加强各类规划空间控制线的衔接，逐步实现城镇开发边界和生态控制线“两线合一”。严守生态保护红线。严格落实永久基本农田保护要求，确保永久基本农田确定后总量不减少、用途不改变、质量有提高。严控城镇开发边界。</p><p>  <strong>高效利用城乡建设用地。</strong>按照减量提质发展思路，合理控制城乡建设用地总量和开发强度。推动建设用地减量提质，引导存量低效用地、集体产业用地减量，优先用于还绿以及补齐公共服务和基础设施欠账。</p><p>  <strong>实施留白增绿战略。</strong>充分考虑未来发展的可能性，划定战略留白地区。在城乡建设用地范围内预留弹性空间，制定严格的年度土地供应和开发计划，适度预留集中建设区存量用地。在规划城乡建设用地范围外，预留远景发展用地指标。积极开展“留白增绿”工作，优先将疏解腾退的存量空间资源用于城市绿地建设，增加绿地游憩空间。</p><h3 id="第二节-构建新型城乡格局"><a href="#第二节-构建新型城乡格局" class="headerlink" title="第二节 构建新型城乡格局"></a><strong>第二节 构建新型城乡格局</strong></h3><p>  <strong>打造生态化、组团式、紧凑型的空间格局。</strong>按照城绿交融、主次分明、组团布局、纵深发展的布局思路，构建<strong>“一中心、一绿洲、四组团、四片区、多廊道、多节点”</strong>的空间结构。</p><p>  <strong>一中心</strong> 即北京城市副中心，是区域发展的功能中枢，统领区域城镇空间布局与设施系统建设。<strong>一绿洲</strong> 即北运河—潮白河中部地区的大尺度生态绿洲，是区域生态体系建设的主体。<strong>四组团</strong> 即城市功能集中建设的重点区域。<strong>四片区 **即4个大型生态板块。</strong>多廊道** 即多条生态廊道。<strong>多节点</strong> 即多个特色小城镇（新市镇）和生态节点。</p><p>  <strong>创新城乡功能组织体系，构建“城市副中心—发展组团—特色小城镇（新市镇）—美丽乡村”</strong>四级联动城乡体系。<br>  ——高水平规划建设北京城市副中心。按照“一带、一轴、多组团”空间结构，优化城市功能布局。依托大运河构建城市水绿空间格局，形成一条蓝绿交织的生态文明带。依托北京市六环路建设功能融合的活力地区，形成一条清新明亮的创新发展轴。</p><p>  ——完善发展组团功能。建设定位明确、特色鲜明、职住平衡的发展组团。燕郊组团重点发展科技创新、商务服务、健康养老等功能，补齐公共服务短板，优化提升城市品质，与北京城市副中心形成更加紧密的功能协作关系。三河组团重点发展科技创新和商务服务功能。香河组团重点发展健康养老、智慧物流、科技创新等功能。亦庄新城（通州部分）组团重点发展科技创新功能和城市综合服务功能。</p><p>  ——培育若干特色小城镇。加强分区指导，按照产业集聚地区、生态优势地区、传统农业地区三个区域，制定差异化的发展策略，推进特色小城镇建设，实现差异化、特色化、绿色化发展。坚持分类推动，因地制宜，突出差异，形成各具特色的产业发展格局。</p><p>  ——推进美丽乡村建设。加快推进新型农村社区建设，优化村落格局。按照集聚提升类、特色保护类、城郊融合类、搬迁撤并类四种类型，引导村庄改造建设。推动城镇公共服务向农村延伸，提升基础设施配置标准。</p><h3 id="第三节-优化交界地区布局"><a href="#第三节-优化交界地区布局" class="headerlink" title="第三节 优化交界地区布局"></a><strong>第三节 优化交界地区布局</strong></h3><p>  <strong>划定生态绿带控制线。</strong>重塑空间发展秩序，共建环首都生态保护绿带。在交界地区划定生态绿带控制线。</p><p>  <strong>严格生态绿带控制线以内地区管控。</strong>加强生态建设与修复，原则上不再新增建设用地，严格拆除违法违规建筑，依法收回已批未建用地，逐步实施村庄拆迁和异地安置，按照规划要求优化调整已建在建项目。</p><p>  <strong>优化生态绿带控制线两侧用地布局。</strong>严控建设用地规模，结合轨道及骨干道路建设，逐步引导北三县地区按照轴向集聚、组团布局的方式向纵深紧凑发展。</p><h2 id="第三章-共同塑造魅力人文的城乡风貌特色"><a href="#第三章-共同塑造魅力人文的城乡风貌特色" class="headerlink" title="第三章 共同塑造魅力人文的城乡风貌特色"></a><strong>第三章 共同塑造魅力人文的城乡风貌特色</strong></h2><p>  坚持保护弘扬中华优秀传统文化、延续历史文脉，厚植京畿文化底蕴，创新文化内涵，强化城市设计，展示门户地区形象，形成“田园风光、国际风范、京华风韵、时代风尚”的总体风貌。</p><h3 id="第一节-共塑门户风貌特色"><a href="#第一节-共塑门户风貌特色" class="headerlink" title="第一节 共塑门户风貌特色"></a><strong>第一节 共塑门户风貌特色</strong></h3><p>  <strong>塑造“田园风光、国际风范、京华风韵、时代风尚”的总体风貌。</strong>凸显自然生态环境特色，强化城乡融合、城景交融，呈现田园风光。坚持“世界眼光、国际标准”的要求，体现文明包容的开放活力，彰显国际风范。强化东方营城理念与首都格局特色，突显运河文化和多元交融的京畿文化特色，展现京华风韵。弘扬中华优秀传统文化，传承中华文化基因，借鉴其他文化特色，塑造古今交融的时代风尚。</p><p>  <strong>突出“蓝绿交织、城景交融、文化传承、舒缓宜人”的形态特色。</strong>蓝绿交织重点突出以潮白河、北运河、鲍丘河、泃河等多条生态景观河流廊道和多层次、多季相、多色彩的大尺度森林生态环境相交织的环境特色。城景交融重点突出各级城镇组团与自然生态环境形成有机融合的布局特色。文化传承重点突出历史文化底蕴，塑造具有人文感的城市公共空间场所特色。舒缓宜人重点突出人性化的建筑与城市空间尺度特色。</p><p>  <strong>彰显具有现代气息和东方神韵的建筑风貌特色。</strong>传承中华建筑文化基因，汲取国际先进设计理念，以创造历史、追求艺术的工匠精神，塑造天人合一、古今交融、形神兼备、简约包容、端正大气的建筑风貌。</p><h3 id="第二节-加强城市设计管控"><a href="#第二节-加强城市设计管控" class="headerlink" title="第二节 加强城市设计管控"></a><strong>第二节 加强城市设计管控</strong></h3><p>  <strong>建立舒缓有序的城市高度秩序。</strong>结合北京城市副中心的高度控制要求，严格控制在城市中心区、铁路公路干线和主要街道、滨水地区及城市边界地带建设高层住宅。严格管控文物保护单位建设控制地带、传统风貌协调区的建筑高度。</p><p>  <strong>塑造和而不同的分区风貌特色。</strong>划分都市时代、特色城镇、乡村景观、生态景观等4类风貌区，实施分类管控。都市时代风貌区主要彰显古今融合、以中为主的现代特色，展现开放、活力的城市气息，形成功能齐全的现代都市。特色城镇风貌区重点结合不同职能特色，展现小城镇活力与休闲魅力，形成尺度宜人的特色城镇。乡村景观风貌区结合美丽乡村建设，塑造总体协调、富有诗意、适宜栖居的田园生活意象。生态景观风貌区以生态环境建设为主，重点关注大尺度自然景观的连续性、完整性，彰显水清河畅、绿意盎然的自然风光。建立和谐雅致的城市色彩体系。</p><p>  <strong>塑造富有韵律的城市天际线。</strong>重点塑造北运河北京城市副中心段的天际线，打造错落有致、局部簇群式的天际线。严格管控燕郊潮白河沿岸、大厂祁各庄镇潮白河沿岸、香河城区北运河和潮白河沿岸的滨水天际线及三河山前地区的天际线，除已建成区外，滨水、临山和历史地段周边宜采用退台式高度控制，不再新增贴边贴线建设的高层建筑，合理控制建筑面宽及连续等高建筑数量，并留出通河、观山等景观视廊和生态走廊。控制引导北三县城市中心区、大型开敞空间周边及重要景观廊道两侧天际线，营造疏密有序的城市空间。加强城市第五立面管控，统筹考虑城市肌理、建筑高度和建筑轮廓，塑造错落有致的城市第五立面。</p><h2 id="第四章-共同打造自然优美的生态环境"><a href="#第四章-共同打造自然优美的生态环境" class="headerlink" title="第四章 共同打造自然优美的生态环境"></a><strong>第四章 共同打造自然优美的生态环境</strong></h2><p>  践行绿水青山就是金山银山的理念，统筹山水林田草系统治理，共建北运河潮白河生态绿洲，加快生态环境保护、修复与建设，全面提升综合环境质量，构筑首都东部生态安全格局，满足城乡居民对高质量生态环境的需要。</p><h3 id="第一节-共筑生态安全格局"><a href="#第一节-共筑生态安全格局" class="headerlink" title="第一节 共筑生态安全格局"></a><strong>第一节 共筑生态安全格局</strong></h3><p>  <strong>构建蓝绿交织的生态安全格局。</strong>按照以洲为心、以廊为脉、以园为景的总体思路，塑造“一洲两楔多廊多点”的生态结构。“一洲”即在潮白河和北运河两河之间规划的大尺度生态绿洲，建设多个森林公园、湿地公园。“两楔”即北京城市总体规划确定的两条楔形绿地。“多廊”即潮白河、北运河、鲍丘河、泃河等主要水系廊道和交通生态廊道，强化区域生态廊道的连贯性和完整性。“多点”即若干重要的森林公园、湿地公园和大型生态公园。</p><p>  <strong>强化生态分级管控。</strong>强化生态空间保护，严格控制蓝绿空间比例，结合生态本底特征及生态功能分布，划定两级生态管控分区。一级生态管控区以生态保护红线为基础，进一步涵盖区域河道水系及两侧控制绿色空间、重要山体、饮用水水源一级保护区、地震断裂带控制区、主要交通干道两侧控制绿色空间、重要区域性生态绿地等，一级生态管控区突出生态保护功能，不符合生态功能和环境保护要求的村庄、产业用地逐步退出。二级生态管控区以构建地区重要生态空间为重点，主要包括基本农田和一级生态管控区以外的郊野公园、森林公园、湿地公园、饮用水水源二级保护区、现有生态林地等，并含有部分村庄、零星国有建设用地、区域设施及战略留白等建设用地。二级生态管控区突出生态休闲功能，以引导减量和扩大生态空间为主，通过平原造林、农业结构调整、腾退用地复垦还绿、生态绿洲和郊野公园建设等，逐步完善区域生态安全格局，在达到规模和质量要求，完成评估后，可动态增补到一级生态管控分区。</p><h3 id="第二节-共建绿色游憩体系"><a href="#第二节-共建绿色游憩体系" class="headerlink" title="第二节 共建绿色游憩体系"></a><strong>第二节 共建绿色游憩体系</strong></h3><p>  <strong>共建北运河—潮白河大尺度生态绿洲。</strong>依托北运河—潮白河两河良好的生态资源，以提高生物多样性为目标，以生态修复和生态示范为重点，在两河中部地区划定生态绿洲。生态绿洲地区一切建设及经营活动最大限度地服从于保护两河生态资源的原始性、自然性、完整性、丰富性及特异性要求，构建由森林公园、郊野公园、湿地、水系构成的结构合理、生物多样性丰富的复合生态系统，大力推进森林生态、生态农业和生态廊道建设，推动既有村镇生态化改造，适度配套基础设施和公共服务设施，严格控制开发强度。</p><p>  <strong>建设区域绿道系统。</strong>结合生态廊道的保护、修复与建设，重点推进北运河、潮白河、长安街东延长线、鲍丘河、南部等5条区域绿道建设。逐步完善区域绿道、城市绿道、社区绿道三级网络，安排适宜慢行要求的各类设施，满足人们交通出行、休闲散步、跑步健身、商业休闲活动等公共活动需求。</p><h3 id="第三节-推进生态修复建设"><a href="#第三节-推进生态修复建设" class="headerlink" title="第三节 推进生态修复建设"></a><strong>第三节 推进生态修复建设</strong></h3><p>  <strong>加强水生态系统修复与建设。</strong>坚持“以水为脉、净水于野、利水循环”的原则，开展水生态系统修复与建设。实施重要水系生态廊道保护与修复工程，逐步修复滨水生态系统。开展生态型河岸建设，保留河道天然的形态及断面，控制截弯取直，采取透水性好、有利于水体交换、适宜动植物生长的生态护岸形式，改造原有硬化河岸，恢复岸线和水体自然净化功能，强化水体的污染治理效果，维持河道基本生态需水。加强河道生态养护管理工作，健全工程后期管理体系，完善考核机制，明确责任主体，定期开展运行维护和景观升级工程。</p><p>  <strong>建设森林生态系统。</strong>以森林公园和郊野公园建设为抓手，推进生态绿洲地区和生态廊道的森林生态系统建设，开展大规模植树造林。积极推动大型森林公园、郊野公园、集中连片林地和城市绿道网络建设，形成大尺度绿色生态空间和城镇之间绿色隔离带。加快平原林地建设，加强平原生态涵养区水田路林综合治理，推进退化林带修复。实施森林质量精准提升工程，按照生态功能优先、适地适树、同时兼顾景观效果的原则，建设树种配置合理、结构稳定、功能完善的森林生态系统。</p><p>  <strong>提高农田的生态功能。</strong>加强农田保护，引导农业向观光型农业发展，充分发挥农田充当绿化隔离带的作用，重点提升农田的生态功能，加强农业灌溉水网的连通性，培育湿地环境。依托平原区造林工程，适度将部分非基本农田的耕地转换成林业用地，同时针对低质低效林进行抚育和养护，提高其生态功能。</p><h3 id="第四节-推动环境综合治理"><a href="#第四节-推动环境综合治理" class="headerlink" title="第四节 推动环境综合治理"></a><strong>第四节 推动环境综合治理</strong></h3><p>  <strong>推进区域大气环境治理。</strong>按照“以点带面、区域协同、量化管理、严格标准”的原则，对各类大气污染源采取严格控制措施，改善大气环境质量。优化能源结构，降低煤炭消费比重，提高天然气、电力等能源消费比重，推广新能源和可再生能源开发利用。淘汰落后产能，推进重点行业环保技术改造升级，强化对重点污染源的治理。合理控制机动车保有量，严格执行机动车尾气排放标准，实施重型柴油车排放实时在线监控，淘汰改造高排放老旧车辆。</p><p>  <strong>加强流域水环境治理。</strong>按照“系统治理、城乡统筹、水陆兼顾”的原则，实施分流域、分阶段治理，逐步构建流域系统化污染控制体系，消除区域黑臭水体，实现重要河湖水系长治久清。结合海绵城市建设，采用低影响开发措施，控制初期雨水径流污染，控制养殖规模，建立农田休耕提质机制，实施测土配方、减少化肥农药施用量，加大畜禽养殖业、农业种植面源污染治理。加大沿河截污力度，强化沿河岸溢流控制，同步完善污水收集管网，建设污水处理设施，提高污水收集处理率，彻底消除入河点源污染。实施河道内源治理，清理沿河垃圾和水面漂浮物，对黑臭水体进行清淤疏浚，快速降低河道内源污染负荷。通过设置泵站、合理连通水系等方式实现水体流动，恢复河网间自然连通，形成活水循环。按河网水系分单元统筹配置以再生水为主的河湖环境用水，增加水体流动性和环境容量。对于无法全面截污的重度黑臭水体采用旁路治理措施，实现水体净化。鼓励引入社会力量，采用市场化、公司化运作方式参与流域水环境的综合治理及生态修复。</p><p>  <strong>统筹推进土壤污染治理。</strong>按照“预防为主、保护优先、风险管控、重点监测”的原则，实施分类别、分用途、分阶段治理，逐步建立区域土壤污染防控体系。实施用地分类管理，建立土壤环境基础数据库，掌握重点行业企业用地中的污染地块分布及其环境风险情况。严格管控重度污染耕地，科学评估确定土地用途。严格控制污染地块再开发利用，保障建设用地土壤环境安全。建成土壤环境质量监测网络，实现土壤环境质量监测点位所有县（市、区）全覆盖。</p><p>  <strong>完善区域垃圾处理体系。</strong>按照“减量化、无害化、资源化”的原则，加强生活垃圾收运处理和危险废弃物管控，完善区域垃圾处理体系，促进垃圾回收利用。按照“村收集、镇转运、县（市、区）处理”的原则，完善生活垃圾收运及处理处置体系，提高废弃物回收效率和水平。加强医疗废物、工业废物及社会源危险废物的收集、处置和利用，提高危险废物管控能力。</p><h2 id="第五章-共同建设高效一体的综合交通网络"><a href="#第五章-共同建设高效一体的综合交通网络" class="headerlink" title="第五章 共同建设高效一体的综合交通网络"></a><strong>第五章 共同建设高效一体的综合交通网络</strong></h2><p>  按照网络化布局、智能化管理、一体化服务的要求，率先破解交通瓶颈，深入推进“轨道上的京津冀”建设，构建一体化的道路系统，实施公交优先发展战略，创新交通建设运营管理机制，打造安全、高效、便捷、绿色、智能的综合交通体系。</p><h3 id="第一节-率先破解交通瓶颈"><a href="#第一节-率先破解交通瓶颈" class="headerlink" title="第一节 率先破解交通瓶颈"></a><strong>第一节 率先破解交通瓶颈</strong></h3><p>  完善与北京中心城区的高快速路系统。加快三河市、大厂回族自治县、香河县骨干道路对接，统筹实施跨河桥梁建设。完善北京城市副中心南部与大厂、香河的骨架性通道网络，提升相关道路标准。构建快速公交通道。完善北三县与北京中心城区的快速公交网络，提升跨界公交运行效率。</p><h3 id="第二节-推进轨道上的京津冀建设"><a href="#第二节-推进轨道上的京津冀建设" class="headerlink" title="第二节 推进轨道上的京津冀建设"></a><strong>第二节 推进轨道上的京津冀建设</strong></h3><p>  <strong>推进城际铁路建设。</strong>以北京城市副中心为中心，构筑通达京津冀各中心城市、枢纽机场的城际铁路网络。构建以北京城市副中心站为主，亦庄站、燕郊站、三河站、香河站为补充的客运枢纽体系，实现对外交通与城市交通的顺畅衔接。</p><p>  <strong>完善多层次的城市轨道网络。</strong>形成区域轨道快线（含市郊铁路）、轨道普线、局域线等多层次的轨道交通网络。区域轨道快线服务北三县与北京城市副中心、北京中心城区的中长距离轨道联系。在北三县各发展组团研究现代有轨电车等形式的局域轨道线布局，与区域轨道快线、轨道普线相衔接。结合轨道交通建设，在北三县地区设置轨道交通车辆基地。</p><p>  <strong>推动轨道枢纽与功能区的耦合布局。</strong>建立轨道与土地利用协调发展机制，加强轨道站点与周边用地一体化规划及场站用地综合利用。完善北京城市副中心行政办公区、运河商务区等主体功能区的轨道网络支撑，推动北三县城市功能和空间沿轨道廊道向纵深发展。推进城际铁路枢纽及区域轨道快线主要站点综合开发利用。</p><h3 id="第三节-完善一体化道路系统"><a href="#第三节-完善一体化道路系统" class="headerlink" title="第三节 完善一体化道路系统"></a><strong>第三节 完善一体化道路系统</strong></h3><p>  <strong>完善区域高快速路系统。</strong>构建区域高速疏解通道，将东六环路国家高速公路功能外移至首都地区环线高速公路，近期利用密涿高速作为区域过境通道，远期新建密涿—京沪高速公路联络线，构建外围疏解通道。研究通过经济杠杆调节、行政管理及货运铁路建设、运输结构优化等途径共同疏导区域过境交通。</p><p>  <strong>完善城乡一体化道路网络。</strong>形成由高速公路、快速路、区域性主干路（主要公路）、主干路（主要公路）、次干路（次要公路）、支路等组成的功能完备、衔接便捷的城乡一体化道路体系。合理增设高速公路出入口，加强区域性主干路与高速公路系统的衔接。</p><p>  <strong>构建“窄马路、密路网”城市道路格局。</strong>推进开放式街区建设，完善北京城市副中心、发展组团、特色小城镇内部道路系统，提高路网密度。开展人性化、精细化的道路空间和交通设计，塑造安全有序、绿色健康、活力开放、生态美观的街道空间。</p><h3 id="第四节-加强交通运营管理"><a href="#第四节-加强交通运营管理" class="headerlink" title="第四节 加强交通运营管理"></a><strong>第四节 加强交通运营管理</strong></h3><p>  创新交通建设与运营投融资模式。突破行政区划限制，构建多元化的交通投融资平台。探索建立促进社会资本参与交通基础设施建设与运营的合作机制，通过投资主体一体化带动区域交通一体化。完善对轨道交通建设地上、地下空间实施土地综合开发的政策措施，加快跨界轨道交通建设。完善停车收费价格政策，大力推动停车产业化发展。研究建立特许经营制度，放宽社会资本进入交通运输市场条件。</p><p>  <strong>实施绿色导向的交通需求和停车管理。</strong>制定分区差别化的交通需求管理政策，分区完善拥车、用车管理策略，引导小汽车合理使用。控制路内停车位的供给，加大对违法停车的处罚力度，建设有序停车环境。建立停车资源信息管理系统，推进停车设施社会共享。</p><p>  <strong>协同推进交通运营管理。</strong>统筹推进交通信息化、标准化建设，完善区域一体化的交通建设、运营、管理政策。创新跨区域交通建设组织模式，建立城际轨道、公交运营补贴分担等运营机制，推动北京市与北三县公交“一卡通”互联互通。率先推进汽车电子标识试点工作，采取智能化手段提高车辆进京的便利性。建立交通执法区域联动机制，实现区域交通统一执法。</p><h2 id="第六章-共同培育创新引领的现代化经济体系"><a href="#第六章-共同培育创新引领的现代化经济体系" class="headerlink" title="第六章 共同培育创新引领的现代化经济体系"></a><strong>第六章 共同培育创新引领的现代化经济体系</strong></h2><p>  以构建高质量的现代化经济体系为目标，推进产业协同分工与联动发展，面向北京城市副中心发展需求，积极承接北京非首都功能疏解，探索产业协同发展的新模式和新机制。</p><h3 id="第一节-推进产业协同分工"><a href="#第一节-推进产业协同分工" class="headerlink" title="第一节 推进产业协同分工"></a><strong>第一节 推进产业协同分工</strong></h3><p>  <strong>聚焦战略性新兴产业。</strong>顺应产业发展的趋势，遵循产业链、价值链、创新链的分工发展规律，重点培育新一代信息技术、高端装备制造、节能环保三大战略性新兴产业，加快构建创新引领的现代产业体系，促进产业转型升级。</p><p>  <strong>培育新型服务经济。</strong>以非首都功能疏解为契机，顺应新经济的发展趋势，积极培育区域服务功能，完善对城市副中心发展的支撑保障功能。重点发展总部经济、数字经济、创意经济、休闲经济等新型服务经济。</p><p>  <strong>推动传统产业转型升级。</strong>加快传统产业技改升级、兼并重组，引导食品加工、家具制造、建材、商贸物流等传统优势行业企业与京津科研院所、高校和大型企业开展合作，提高产业竞争力。大力发展现代化农业，推动农业产业化、智能化、服务化，提高农业附加值。</p><p>  <strong>推进产业协同分工。</strong>充分发挥北京市产业辐射带动作用，积极推动北京“摆不下、离不开、走不远”产业向通州区与北三县疏解转移，明确通州区与北三县产业发展重点及产业链条上的协同分工，形成分工明确、层次清晰、协同高效、创新驱动的现代产业体系。通州区重点围绕前沿技术研发环节、科技创新与服务的高端环节进行布局，北三县地区重点在中试孵化环节、制造环节和配套服务环节实现与通州区的产业协同。加快推进服务首都的区域性物流产业基地建设。</p><h3 id="第二节-建立产业协同机制"><a href="#第二节-建立产业协同机制" class="headerlink" title="第二节 建立产业协同机制"></a><strong>第二节 建立产业协同机制</strong></h3><p>  <strong>强化产业协同政策机制。</strong>统筹研究制定通州区与北三县产业创新协作专项政策，推动中关村国家自主创新示范区相关政策向北三县延伸，引导产业和创新资源向北三县疏解和集聚。综合考虑价值链、经济效益、社会效应、空间资源、消费需求等因素，制定通州区与北三县差异化禁限目录，引导产业按照不同细分领域、产业链条在通州区以及北三县合理布局，禁止布局高耗水、高耗能及环境污染高风险项目。建立产业协同发展的风险防控机制，推进产业联盟建设，加强对信用风险和竞争风险防控，完善奖惩机制和退出机制。</p><p>  <strong>建立重大项目统筹机制。</strong>积极开展产业对接，通州区重点组织前沿科技、硬科技项目对接，北三县重点组织中试孵化、制造及配套服务项目对接。建立通州区与北三县常态化项目会商机制、重大项目评价和统筹落地联合审议机制，制定重大项目统筹管理办法，保障重大项目实施推进。</p><p>  <strong>创新产业协同利益机制。</strong>统筹研究制定通州区与北三县协同发展税收优惠与分享政策，加快引导企业和人才集聚。建立财政投入增长长效机制，通过创新公共财政支出方式，对产业价值链相关领域和项目进行贷款贴息、风险投保补贴等方式的利益补偿，加大对龙头企业、新型创新机构、重点园区平台的扶持力度，促进产业价值链的发展，加快形成集群效应和链式效应。</p><h3 id="第三节-优化产业空间布局"><a href="#第三节-优化产业空间布局" class="headerlink" title="第三节 优化产业空间布局"></a><strong>第三节 优化产业空间布局</strong></h3><p>  打造两条特色产业带。依托京哈、京沈两条区域交通廊道，有序引导产业集聚发展，形成两条特色产业带。京哈特色产业带形成以新一代信息技术、节能环保为主导的产业带。京沈特色产业带形成以新一代信息技术、高端装备产业为主导的产业带。</p><p>  <strong>重点建设五大产业功能区。</strong>立足主导产业方向和现实产业基础，有序引导产业向国家级和省级产业平台集聚，逐步推动产业功能区向高端化、集约化升级。加强产业功能区整合提升的分类指导，完善产业准入与退出机制，加强运营模式创新。</p><p>  <strong>建设若干特色产业小城镇。</strong>加强城乡功能互动和特色产业培育，激活乡镇发展动力，形成各具特色的产业发展格局。特色产业带沿线地区重点布局以人工智能、高端装备、节能环保、智慧物流、印刷媒体为主的产业型特色小城镇。潮白河和北运河沿线、中部生态绿洲及生态廊道周边地区重点培育以文化旅游、文化创意、休闲农业、健康养老等为主的休闲型特色小城镇。</p><h2 id="第七章-共同分享优质便利的城乡公共服务"><a href="#第七章-共同分享优质便利的城乡公共服务" class="headerlink" title="第七章 共同分享优质便利的城乡公共服务"></a><strong>第七章 共同分享优质便利的城乡公共服务</strong></h2><p>  坚持以人民为中心的发展思想，保障和改善民生，推动北京优质公共服务资源向北三县延伸，统筹区域公共服务设施布局，建立公共服务协同配套推进机制，逐步缩小两地公共服务落差，共同塑造高品质的生活空间，切实提高人民的获得感、幸福感、安全感。</p><h3 id="第一节-跨界统筹公共服务资源"><a href="#第一节-跨界统筹公共服务资源" class="headerlink" title="第一节 跨界统筹公共服务资源"></a><strong>第一节 跨界统筹公共服务资源</strong></h3><p>  <strong>推动北京优质教育资源向通州区与北三县布局。</strong>鼓励以合作办学、建立分校区等方式，促进北京优质教育资源向通州区与北三县转移。推动师资共享，大力促进师资在北三县地区流动。强化市场化运营机制建设，鼓励通过成立运营集团等方式，加速实现教育资源的整合与共享。</p><p>  <strong>培育北三县区域性医疗养老服务功能。</strong>鼓励北三县建设医疗卫生与养老相结合的服务设施，全面提升在健康养老领域服务北京市及京津冀地区的能力。研究制订鼓励政策，引导北京优质健康养老资源向北三县延伸。通过机构合作、设置分院等方式，推动在京服务全国和区域的优质医疗资源向北三县纵深布局。完善区域资源共享、双向医疗转诊、异地结算、多点执业等机制，积极促进分级诊疗制度在区域内的实施，为医疗卫生与养老服务事业融合发展创造便利条件。</p><p>  <strong>推进大型文体设施共建共享。</strong>提高设施利用效率，避免重复建设，共同推动文体事业的高质量发展。积极推动通州区与北三县大型文化设施、体育设施共建共享，共同促进地区间的文化活动交流，共同承办和推进重大体育赛事活动。</p><h3 id="第二节-均衡配置基本公共服务"><a href="#第二节-均衡配置基本公共服务" class="headerlink" title="第二节 均衡配置基本公共服务"></a><strong>第二节 均衡配置基本公共服务</strong></h3><p>  <strong>重点补齐基础教育设施短板。</strong>坚持幼有所育、学有所教，完善义务教育和高中阶段教育体系，全面实施素质教育。逐步统一通州区与北三县地区基础教育设施配套标准，促进城乡基础教育设施均衡布局，优先利用棚户区改造和单位腾退用地补齐欠缺的基础教育设施。特色小城镇中心设置初中、小学和幼儿园，较大的村设置完全小学，鼓励有条件的村集体和教育部门合作设置村办幼儿园，鼓励国际教育集团办学，保障服务覆盖和适宜的办学规模，提供均衡、优质的教育服务。</p><p>  <strong>构建公共文化服务体系。</strong>加大公共文化资源整合力度，全面提升公共文化设施配套水平，统筹各类公共文化设施资源，形成覆盖全面、布局合理、特色鲜明的现代公共文化服务体系。鼓励社会力量和资本参与公共文化事业发展。在严格保护历史文化资源前提下，鼓励合理利用文保单位和历史文化载体环境提供公共文化服务。</p><p>  <strong>高标准配置卫生健康资源。</strong>坚持病有所医，建立覆盖城乡、服务均等的卫生健康服务体系，逐步完善医院、公共卫生和基层卫生等基础设施，优化服务机构布局，提高基本医疗设施建设水平，大幅提升卫生健康服务能力。</p><p>  <strong>完善全民健身体系。</strong>加快推进体育事业发展，精准对接百姓健身需求，补齐体育设施短板，积极推进15分钟社区运动休闲圈建设，形成高品质的全民健身设施网络。鼓励学校、科研院所内部体育场馆开放共享，鼓励结合大型城市公园、郊野公园布局体育设施，鼓励社会力量和资本参与体育设施建设和运营，满足日益增长的群众体育健身需求。规划在北三县地区预留区域性重大赛事设施用地。</p><p>  <strong>提升社会保障基本服务水平。</strong>坚持老有所养、弱有所扶，以普惠性、保基本、均等化、可持续为目标，创新社会保障服务体系，完善社会保障政策。切实保障残障人员、老人、儿童的教育、文化、医疗等基本服务，统筹考虑养老服务设施配置，建立健全未成年人关爱保护体系，完善殡葬公共服务体系。完善劳动就业服务政策，提供多层次公共就业服务。构建以居家为基础、社区为依托、机构为补充、医养结合的养老服务体系。</p><h3 id="第三节-建立多元住房供应体系"><a href="#第三节-建立多元住房供应体系" class="headerlink" title="第三节 建立多元住房供应体系"></a><strong>第三节 建立多元住房供应体系</strong></h3><p>  <strong>优化居住空间布局。</strong>促进职住均衡发展，推进就业与居住空间的匹配与融合。严禁在交界地区大规模开发房地产，科学引导居住空间布局。合理控制特色小城镇的居住空间规模，强化特色产业功能，避免房地产化。加强保障性住房、公共交通、公共服务与市政基础设施的整合式开发，适度在轨道车站、大容量公共交通廊道周边布局混合性居住空间。</p><p>  <strong>完善住房保障制度。</strong>建立多主体供给、多渠道保障、租购并举的住房制度。根据产业布局、人口流动情况，因地制宜发展共有产权住房和公租房，形成供需匹配、结构合理、流转有序、支出与收入相适应的住房保障体系，完善住房保障监督管理机制，努力满足实有就业人口住房保障需求。</p><p>  <strong>严控房地产无序开发。</strong>坚决摒弃以房地产开发为主的发展方式，制定更加严格的房地产项目准入条件和年度开发总量约束机制。根据就业增长、配套设施情况，合理确定住房供地数量、布局和时序，严控房地产开发总量，引导房地产理性发展。加强交界地区房地产开发全过程联动监管，严厉打击房地产企业囤地炒地。</p><h2 id="第八章-共同建设绿色智慧的市政基础设施"><a href="#第八章-共同建设绿色智慧的市政基础设施" class="headerlink" title="第八章 共同建设绿色智慧的市政基础设施"></a><strong>第八章 共同建设绿色智慧的市政基础设施</strong></h2><p>  遵循城乡一体、绿色生态、智能高效、适度超前的理念，推进区域基础设施共建共享，统筹区域水资源利用与能源保障体系建设，建设海绵城市和智慧城市，构建绿色智慧的市政设施网络。</p><h3 id="第一节-统筹区域水资源利用"><a href="#第一节-统筹区域水资源利用" class="headerlink" title="第一节 统筹区域水资源利用"></a><strong>第一节 统筹区域水资源利用</strong></h3><p>  <strong>综合配置多种水资源。</strong>统筹考虑通州区与北三县水资源保障，加强水资源质量管理和水资源开发利用，优化区域水资源配置，构建多水源供水的水源供给保障格局。增加外调水量，提升水资源安全保障度。严禁超采并逐步减少地下水开采量，严格控制开采深层地下水，生活、工业用水优先使用外调水，农业以浅层地下水为主，适度提高本地地表水和外调水资源比例，降低供水水源中地下水资源比例，保障生态用水需求，促进水资源供需平衡。</p><p>  <strong>开展节水型社会建设。</strong>北京城市副中心建成全国节水示范区，其余地区达到节水型社会建设先进水平。优化用水结构，实现生活用水控制增长、工业用新水零增长、农业用新水负增长、生态环境用水稳定增长。提高用水效率，发展生态节水农业，加强农业节水灌溉设施建设，减少农业用水，引入国际先进行业清洁高效生产技术，提高节水型器具普及率。加强公众节水宣传教育。</p><h3 id="第二节-建设区域水循环系统"><a href="#第二节-建设区域水循环系统" class="headerlink" title="第二节 建设区域水循环系统"></a><strong>第二节 建设区域水循环系统</strong></h3><p>  <strong>确保城乡供水安全。</strong>建立城乡统筹的集中供水系统，统一供水水质标准，形成集成、互联、安全的供水格局。在统筹考虑通州区与北三县水资源配置的基础上，加大区域供水工程连通性，各分区间设施集成共享、互为备用，提高供水效率，增强区域供水安全保障能力。整合现有水厂，设施适度集中。实现用水分类分质供应，采用管网分区计量管理，提高管网精细化、信息化管理水平，有效节约水资源。提高农村集中式供水比例。鼓励镇级水厂服务周边村庄的“镇带村”供水模式，提高农村地区供水保障率。</p><p>  <strong>推进污水全收集全处理。</strong>提高城镇污水收集处理能力和回用水平，适度分散、相对集中布局污水处理厂，构建多目标、可持续、完整的污水处理及再生利用系统。利用一体化设施及湿地系统，分散处理小城镇、村庄的生活污水，回用于生态与农业。引导污泥减量化、稳定化、无害化、资源化处理处置。</p><h3 id="第三节-保障区域能源安全"><a href="#第三节-保障区域能源安全" class="headerlink" title="第三节 保障区域能源安全"></a><strong>第三节 保障区域能源安全</strong></h3><p>  <strong>优化区域能源结构。</strong>以绿色低碳、节能高效、智能先进为原则，优化能源消费结构。大幅提高清洁能源比重，构建以电力、天然气为主，太阳能、地热能及生物质能等为辅的绿色低碳能源供应体系，建设多个分布式能源耦合系统互供体系，全面推广太阳能、分布式光伏、冷热电三联供等分布式能源与常规能源系统的智能耦合发展，提升绿色能源智能利用水平。</p><p>  <strong>加强电网安全保障。</strong>加快电网通达建设和互通互联，提高通州区及北三县能源系统保障水平。优化主干电网结构，加密变电站布点，保障供电可靠性。</p><p>  <strong>完善天然气高压管网。</strong>远近结合，通过多方向气源、多层次储备体系、互联互通的各级管网，切实有效保障通州区及北三县的燃气安全稳定供应，构建多气源、多层级、广覆盖的城乡燃气供应体系，实现通州区与北三县气源共建共享。</p><h3 id="第四节-统筹地下空间利用"><a href="#第四节-统筹地下空间利用" class="headerlink" title="第四节 统筹地下空间利用"></a><strong>第四节 统筹地下空间利用</strong></h3><p>  <strong>有序利用地下空间。</strong>贯彻统一规划、综合开发、合理利用、依法管理的原则，更好发挥地下资源潜力，形成相互连接、四通八达的城市地下空间。以地质评估为基础，确定合理的地下空间发展规模。统筹地上地下功能，推进地下空间功能复合利用，合理安排公共活动、防灾安全、市政交通、资源能源利用、物流配送等功能。统筹浅层、次浅层、次深层、深层四个深度，形成立体分层的地下空间系统。按照重点利用、鼓励利用、一般利用和限制利用四个等级，对地下空间开发利用实施统筹管理。提升地下空间利用强度，综合考虑商业、交通枢纽等人流密集地区地下空间使用，划定轨道周边地下空间一体化控制线，完善地下步行系统，加强整体性、连通性，提高轨道站点使用效率及空间品质。</p><p>  <strong>加强综合管廊建设。</strong>统筹各类市政管线规划、建设和管理，保障城市安全、完善城市功能、美化城市景观、促进城市集约高效和转型发展，提高城市综合承载能力和城镇化发展质量。加大北京城市副中心和重要发展组团综合管廊建设力度，逐步形成连片示范、覆盖成网的管廊体系。建设综合管廊监控管理平台，提高管线运行安全性和抵御灾害能力，方便运营维护与更新，提升市政基础设施管理水平。</p><p>  <strong>建立统筹协调机制。</strong>统筹协调地下空间管理涉及的自然资源、规划建设、交通、电信、供电、消防、抗震、防洪、环保和文物保护等部门，建立城市地下空间开发利用相关部门之间的协同管理机制，建立专门的运维机构和联席会议制度，维护城市地下空间的整体性、系统性，避免条块分割、多头管理。</p><h2 id="第九章-共同建立韧性安全的防灾减灾体系"><a href="#第九章-共同建立韧性安全的防灾减灾体系" class="headerlink" title="第九章 共同建立韧性安全的防灾减灾体系"></a><strong>第九章 共同建立韧性安全的防灾减灾体系</strong></h2><p>  牢固树立和贯彻落实总体国家安全观，坚持预防为主、平灾结合的原则，高标准规划建设防灾减灾基础设施，推进区域联防联控，全面提升综合防灾减灾救灾能力，形成全天候、系统性、现代化的安全保障体系。</p><h3 id="第一节-共筑首都安全防控体系"><a href="#第一节-共筑首都安全防控体系" class="headerlink" title="第一节 共筑首都安全防控体系"></a><strong>第一节 共筑首都安全防控体系</strong></h3><p>  <strong>提升安防保障能力。</strong>高标准推进安防设施建设，加强安防警务力量，有效提升首都安全保障水平。建立相邻网格支援、警种联勤联动、常态机动处突机制，不断提升人民群众安全感。</p><p>  <strong>建立安防联动机制。</strong>按照常态、联动、共建原则，构建立体化安防体系，健全区域治安防控联动机制，有效应对影响首都社会安全稳定突出问题。优化区域及多部门协作机制，共保首都安全。</p><p>  <strong>加强网络安全保障。</strong>按照突出重点、分步实施的原则，强化区域信息安全保障设施建设，提升信息安全保障水平。提升突发公共事件的应急保障能力。加强基础网络的安全监管与保障，建立区域智能信息容灾共享备份系统。严格按照网络安全等级保护制度要求，严格履行网络安全保护义务，完善区域信息安全等级保护工作机制。</p><h3 id="第二节-加强区域防灾救灾联动"><a href="#第二节-加强区域防灾救灾联动" class="headerlink" title="第二节 加强区域防灾救灾联动"></a><strong>第二节 加强区域防灾救灾联动</strong></h3><p>  <strong>统一区域灾害评估体系。</strong>按照统一标准，科学评估区域灾害风险，严守防灾安全底线，识别灾害种类，共画一张灾害风险评估图。统筹灾害造成损失、灾害发生频率、承载体防御能力等多方面因素，对潜在灾害要素进行深入分析和评估，为区域空间布局提供基础。全面落实区域灾害评估体系和预警体系建设，强化区域灾害防控能力。按照区域灾害风险识别，及时联动处理高风险灾害要素。</p><p>  <strong>共建灾害预警监测体系。</strong>建立统一指挥、统一管理的区域灾害预警监测机制，建设多灾种、多部门联合预警监测网络体系，联合共建区域灾害预警监测网络中心，将抗震、防洪防涝、消防、人防、安全生产等预警监测统一纳入，实现灾害预警监测统一管理，灾害信息全方位共享。</p><p>  <strong>构建联合应急救援体系。</strong>按照区域灾害统一管理原则，合作构筑区域性联合应急救援体系，共建区域应急救援中心，结合预警监测网络中心信息共享机制，统一发布灾情，统一指挥应急救援。在灾害救助体系建设、应急力量统筹、抢险救灾储备资源统一调度、灾害应急演练、防灾减灾示范社区建设、队伍建设等方面建立常态化统一行动格局，提高灾害联防联控和应急响应能力。充分发挥市场主体作用，引导和助推区域间防灾减灾救灾领域的产业合作。</p><h3 id="第三节-完善综合防灾减灾体系"><a href="#第三节-完善综合防灾减灾体系" class="headerlink" title="第三节 完善综合防灾减灾体系"></a><strong>第三节 完善综合防灾减灾体系</strong></h3><p>  <strong>提高城乡综合防灾能力。</strong>深化城乡防洪排涝、地震、气象、地质等领域的灾害风险评估，结合风险评估结果优化城市综合防灾减灾布局，合理确定防灾减灾分区，形成“空间布局合理、设施强力支撑、风险有效管控、应急响应充分”的现代化、全过程、高效率防灾减灾体系。严格执行城乡综合防灾和设施安全标准，高标准建设城乡防灾减灾设施系统，提高城乡适应环境变化的自我调整与恢复的能力，推动全社会防灾减灾意识和能力的提升。</p><p>  <strong>完善防洪安全体系。</strong>按照上蓄、中疏、下排、适滞的原则，以流域为单元，完善整体防洪安全格局。提高潮白河、北运河、泃河等区域河道的防洪能力。结合北京城市副中心外围分洪方案研究与温潮减河工程实施，专项研究区域防洪与分洪方案。结合区域大型湿地与森林公园建设，合理设置洪水调蓄区。</p><p>  <strong>严格城乡抗震设防标准。</strong>严格遵守各级城镇、各类地区抗震基本设防烈度要求。学校、医院、生命线系统等重点设防类设施按高于本地区抗震设防烈度的要求加强其抗震措施，其他重大工程依据地震安全性评价结果进行抗震设防。</p><p>  <strong>实现城乡消防布局全覆盖。</strong>构建城乡覆盖、陆水空立体布局的消防安全系统，均衡布局消防设施，基本实现城乡消防服务全覆盖。完善消防指挥体系，夯实基层消防设施网络，补齐历史欠账，改善设施条件，加强要害地区防护。推进“智慧消防”建设，坚持高标准建设，形成充分保障、统筹协调、系统高效的消防设施体系。</p><p>  <strong>加强应急避难场所建设。</strong>加强城乡应急避难场所建设，增强抵御自然灾害、处置突发事件和危机管理能力。以居住地为主就近疏散为原则，结合公园绿地、广场、体育场馆、各类学校等开敞空间以及地下空间等科学布局应急避难场所，形成就地避难、就近避难、步行避难的分级分类疏散系统。强化公共建筑物和设施的应急避险功能建设。</p><p>  <strong>完善应急救灾保障系统。</strong>以区域干线公路网、城市干道网为主通道，完善城市生命通道系统。应急救灾主通道两侧的建筑应能保障通道的安全通畅。按照区域联动共享的原则，规划构建三级区域应急救灾通道体系，一级生命通道为区域高速、快速路系统，二级生命通道为城区主要主干路系统，三级生命通道为地区支线公路，形成安全、可靠、高效的紧急救援通道体系。</p><h2 id="第十章-建立共同治理的政策保障机制"><a href="#第十章-建立共同治理的政策保障机制" class="headerlink" title="第十章 建立共同治理的政策保障机制"></a><strong>第十章 建立共同治理的政策保障机制</strong></h2><p>  坚持把改革创新作为协同发展的根本动力，按照统一规划、统一政策、统一标准、统一管控的要求，建立新时代高质量的城市规划建设管理体系，推动政策机制创新，推进治理体系和治理能力现代化，打造京津冀区域协同发展示范区。</p><h3 id="第一节-建立规划实施机制"><a href="#第一节-建立规划实施机制" class="headerlink" title="第一节 建立规划实施机制"></a><strong>第一节 建立规划实施机制</strong></h3><p>  <strong>建立统一规划管理机制。</strong>建立保障高质量发展的规划编制技术体系，依法依规编制相关规划，实现“多规合一”。编制国土空间规划，同步搭建“多规合一”空间基础信息平台，健全城市数据资源管理体系，逐步实现各类规划在规划体系、空间布局、技术标准、信息平台和管理机制等方面的统一。建立动态监控与展示平台，组织开展全领域运行动态监测，加强公众参与的广度与深度，运用平台展现公众诉求与意见。建立联合督查制度，统一对自然资源、环保、水利等领域实施监督，严肃查处各类违法违规建设行为，确保一张蓝图干到底。</p><p>  <strong>建立统一运维机制。</strong>坚持政府引导、市场运作、合作共建，鼓励引入社会资本开展特许经营，提供运营服务，重点推进产业园区、公共服务、基础设施和生态建设等领域有一定收益的项目先行先试，探索建立统一的投资建设运维机制。</p><h3 id="第二节-建立统一标准体系"><a href="#第二节-建立统一标准体系" class="headerlink" title="第二节 建立统一标准体系"></a><strong>第二节 建立统一标准体系</strong></h3><p>  <strong>严格执行统一环保标准。</strong>按照从严执行的原则，通州区与北三县统一执行大气、水体、土壤等环保领域的标准。以PM2.5为重点开展大气治理，北三县全域按照北京市治超治限、燃煤和扬尘污染源防控以及“散乱污”企业治理标准开展执法工作。以整治污水排放为重点开展水体治理，按照北京地方排污标准执法管理。加强垃圾分类和无害化处理，统一高标准建设垃圾处理设施。</p><p>  <strong>高起点制定统一城市建设标准。</strong>按照打造时代精品、城市典范的共同要求，高起点制定实施城市建设标准。以创建全国森林城市（县）的标准开展园林绿化建设，统一执行北京市的绿地养护标准。以打造绿色城市为目标，大幅提高绿色节能三星以上建筑物比例。北三县参照城市副中心海绵城市试点在主要城区建设海绵城市。</p><p>  <strong>高起点制定统一基本公共服务标准。</strong>合理制定辖区内基本公共服务标准，逐步推进实施。按照北京市示范校标准建设若干所中小学、增加学位供给。合理布局医疗机构，提高乡镇卫生院床位数和全科医生人数，提升本地就医率。</p><p>  <strong>统一社会保障标准。</strong>按照权利与义务相对应的原则，逐步提高北三县医保、养老、工资、城乡低保等社会保障标准。逐步统一缴费标准、保障范围、医保目录、公共卫生待遇、准入条件等。北三县探索建立城乡居民养老保险待遇确定和基础养老正常调整机制，逐步提高保障水平。</p><h3 id="第三节-推进协同政策创新"><a href="#第三节-推进协同政策创新" class="headerlink" title="第三节 推进协同政策创新"></a><strong>第三节 推进协同政策创新</strong></h3><p>  <strong>完善生态环保支持政策。</strong>支持潮白河、北运河综合治理工程。将植树造林绿化工程纳入国家重点生态工程建设规划，加大对环首都森林湿地公园建设的支持力度。</p><p>  <strong>创新人口人才管理政策。</strong>通州区严格执行北京市人口积分落户制度。河北省实施北三县户籍制度单列管理。推进实施“人才资源共享工程”。</p><p>  <strong>建立统一互认的人才评价和行业管理政策。</strong>通州区严格执行北京市各行业管理要求和人才评价规定，河北省、廊坊市参照北京市相关规定，全面调整北三县各行业管理规范，实现在高新技术产业认定、人才评价等方面与北京市保持程序一致、结果互认。</p><p>  <strong>创新金融财税政策。</strong>支持通州区与北三县开展投融资改革试点。鼓励开发性和政策性金融机构依法合规创新业务模式，有效利用各类资金。</p><p>  <strong>共享改革试点政策。</strong>推进改革试点政策区域共享，推动北京城市副中心建设项目审批改革试点、海绵城市试点、政府与社会资本合作试点、国家知识产权城区试点等政策向北三县延伸。</p><h3 id="第四节-完善工作推进机制"><a href="#第四节-完善工作推进机制" class="headerlink" title="第四节 完善工作推进机制"></a><strong>第四节 完善工作推进机制</strong></h3><p>  <strong>加强组织领导。</strong>在党中央、国务院领导下，按照京津冀协同发展领导小组部署要求，领导小组办公室加强统筹协调，北京市、河北省人民政府组织实施，重要事项及时按程序报告。各有关部门要按照职能分工，加强对规划实施的指导，在相关规划编制、政策制定、项目建设、体制机制创新方面予以积极支持。</p><p>  <strong>抓好督促落实。</strong>严格执行协同发展规划，切实维护规划的严肃性、不得擅自调整变更规划内容。对于规划执行中的困难和问题，按程序报北京市、河北省和领导小组办公室以及相关部门协调解决，不得变相执行。对于督查和调研工作中发现的久督不办、敷衍塞责、推诿扯皮、瞒报谎报事项，及时对相关单位和责任人问责。完善规划实施的公众参与机制，广泛听取社会各界的意见和建议。</p>]]></content>
      
      
      <categories>
          
          <category> 政府规划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 政府规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>河北雄安新区规划纲要（转载）</title>
      <link href="/2020/0518535.html"/>
      <url>/2020/0518535.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文转载自：<a href="http://www.xiongan.gov.cn/2018-04/21/c_129855813.htm" target="_blank" rel="noopener">中国雄安官方网站</a>，新华社北京4月21日电。</p></blockquote><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>　　设立河北雄安新区，是以习近平同志为核心的党中央作出的一项重大历史性战略选择，是千年大计、国家大事。习近平总书记亲自谋划、亲自决策、亲自推动，倾注了大量心血，2017年2月23日亲临实地考察并发表重要讲话，多次主持召开会议研究部署并作出重要指示，为雄安新区规划建设指明了方向。</p><p>　　在党中央坚强领导下，河北省、京津冀协同发展领导小组办公室会同中央和国家机关有关部委、专家咨询委员会等方面，深入学习贯彻习近平新时代中国特色社会主义思想和党的十九大精神，坚持世界眼光、国际标准、中国特色、高点定位，紧紧围绕打造北京非首都功能疏解集中承载地，创造“雄安质量”、成为新时代推动高质量发展的全国样板，培育现代化经济体系新引擎，建设高水平社会主义现代化城市，借鉴国际成功经验，汇聚全球顶尖人才，集思广益、深入论证，编制雄安新区规划。</p><p>　　2018年2月22日，习近平总书记主持召开中央政治局常委会会议，听取雄安新区规划编制情况的汇报并发表重要讲话。李克强总理主持召开国务院常务会议，审议雄安新区规划并提出明确要求。京津冀协同发展领导小组直接领导推动新区规划编制工作。按照党中央要求，进一步修改完善形成了《河北雄安新区规划纲要》。</p><p>　　本纲要是指导雄安新区规划建设的基本依据。规划期限至2035年，并展望本世纪中叶发展远景。</p><h2 id="第一章-总体要求"><a href="#第一章-总体要求" class="headerlink" title="第一章　总体要求"></a>第一章　总体要求</h2><p>　　中国特色社会主义进入新时代，以习近平同志为核心的党中央高瞻远瞩、深谋远虑，科学作出了设立雄安新区的重大决策部署，明确了雄安新区规划建设的指导思想、功能定位、建设目标、重点任务和组织保障，为高起点规划、高标准建设雄安新区提供了根本遵循、指明了工作方向。</p><h3 id="第一节-设立背景"><a href="#第一节-设立背景" class="headerlink" title="第一节　设立背景"></a>第一节　设立背景</h3><p>　　设立河北雄安新区，是以习近平同志为核心的党中央深入推进京津冀协同发展作出的一项重大决策部署，是继深圳经济特区和上海浦东新区之后又一具有全国意义的新区，是重大的历史性战略选择，是千年大计、国家大事。</p><p>　　党的十八大以来，以习近平同志为核心的党中央着眼党和国家发展全局，运用大历史观，以高超的政治智慧、宏阔的战略格局、强烈的使命担当，提出以疏解北京非首都功能为“牛鼻子”推动京津冀协同发展这一重大国家战略。习近平总书记指出，考虑在河北比较适合的地方规划建设一个适当规模的新城，集中承接北京非首都功能，采用现代信息、环保技术，建成绿色低碳、智能高效、环保宜居且具备优质公共服务的新型城市。在京津冀协同发展领导小组的直接领导下，经过反复论证、多方比选，党中央、国务院决定设立河北雄安新区。</p><p>　　规划建设雄安新区意义重大、影响深远。中国特色社会主义进入新时代，我国经济由高速增长阶段转向高质量发展阶段，一个阶段要有一个阶段的标志，雄安新区要在推动高质量发展方面成为全国的一个样板。雄安新区作为北京非首都功能疏解集中承载地，与北京城市副中心形成北京发展新的两翼，共同承担起解决北京“大城市病”的历史重任，有利于探索人口经济密集地区优化开发新模式；培育建设现代化经济体系的新引擎，与以2022年北京冬奥会和冬残奥会为契机推进张北地区建设形成河北两翼，补齐区域发展短板，提升区域经济社会发展质量和水平，有利于形成新的区域增长极；建设高水平社会主义现代化城市，有利于调整优化京津冀城市布局和空间结构，加快构建京津冀世界级城市群；创造“雄安质量”，有利于推动雄安新区实现更高水平、更有效率、更加公平、更可持续发展，打造贯彻落实新发展理念的创新发展示范区，成为新时代高质量发展的全国样板。</p><h3 id="第二节-新区概况"><a href="#第二节-新区概况" class="headerlink" title="第二节　新区概况"></a>第二节　新区概况</h3><p>　　雄安新区地处北京、天津、保定腹地，距北京、天津均为105公里，距石家庄155公里，距保定30公里，距北京新机场55公里，区位优势明显，交通便捷通畅，地质条件稳定，生态环境优良，资源环境承载能力较强，现有开发程度较低，发展空间充裕，具备高起点高标准开发建设的基本条件。</p><p>　　本次新区规划范围包括雄县、容城、安新三县行政辖区（含白洋淀水域），任丘市鄚州镇、苟各庄镇、七间房乡和高阳县龙化乡，规划面积1770平方公里。选择特定区域作为起步区先行开发，在起步区划出一定范围规划建设启动区，条件成熟后再有序稳步推进中期发展区建设，并划定远期控制区为未来发展预留空间。</p><h3 id="第三节-指导思想"><a href="#第三节-指导思想" class="headerlink" title="第三节　指导思想"></a>第三节　指导思想</h3><p>　　高举中国特色社会主义伟大旗帜，深入学习贯彻习近平新时代中国特色社会主义思想和党的十九大精神，坚决落实党中央、国务院决策部署，坚持稳中求进工作总基调，牢固树立和贯彻落实新发展理念，紧扣我国社会主要矛盾变化，按照高质量发展的要求，紧紧围绕统筹推进“五位一体”总体布局和协调推进“四个全面”战略布局，着眼建设北京非首都功能疏解集中承载地，创造“雄安质量”，打造推动高质量发展的全国样板，建设现代化经济体系的新引擎，坚持世界眼光、国际标准、中国特色、高点定位，坚持生态优先、绿色发展，坚持以人民为中心、注重保障和改善民生，坚持保护弘扬中华优秀传统文化、延续历史文脉，着力建设绿色智慧新城、打造优美生态环境、发展高端高新产业、提供优质公共服务、构建快捷高效交通网、推进体制机制改革、扩大全方位对外开放，建设绿色生态宜居新城区、创新驱动发展引领区、协调发展示范区、开放发展先行区，努力打造贯彻落实新发展理念的创新发展示范区，建设高水平社会主义现代化城市。</p><h3 id="第四节-发展定位"><a href="#第四节-发展定位" class="headerlink" title="第四节　发展定位"></a>第四节　发展定位</h3><p>　　雄安新区作为北京非首都功能疏解集中承载地，要建设成为高水平社会主义现代化城市、京津冀世界级城市群的重要一极、现代化经济体系的新引擎、推动高质量发展的全国样板。</p><p>　　绿色生态宜居新城区。坚持把绿色作为高质量发展的普遍形态，充分体现生态文明建设要求，坚持生态优先、绿色发展，贯彻绿水青山就是金山银山的理念，划定生态保护红线、永久基本农田和城镇开发边界，合理确定新区建设规模，完善生态功能，统筹绿色廊道和景观建设，构建蓝绿交织、清新明亮、水城共融、多组团集约紧凑发展的生态城市布局，创造优良人居环境，实现人与自然和谐共生，建设天蓝、地绿、水秀美丽家园。</p><p>　　创新驱动发展引领区。坚持把创新作为高质量发展的第一动力，实施创新驱动发展战略，推进以科技创新为核心的全面创新，积极吸纳和集聚京津及国内外创新要素资源，发展高端高新产业，推动产学研深度融合，建设创新发展引领区和综合改革试验区，布局一批国家级创新平台，打造体制机制新高地和京津冀协同创新重要平台，建设现代化经济体系。</p><p>　　协调发展示范区。坚持把协调作为高质量发展的内生特点，通过集中承接北京非首都功能疏解，有效缓解北京“大城市病”，发挥对河北省乃至京津冀地区的辐射带动作用，推动城乡、区域、经济社会和资源环境协调发展，提升区域公共服务整体水平，打造要素有序自由流动、主体功能约束有效、基本公共服务均等、资源环境可承载的区域协调发展示范区，为建设京津冀世界级城市群提供支撑。</p><p>　　开放发展先行区。坚持把开放作为高质量发展的必由之路，顺应经济全球化潮流，积极融入“一带一路”建设，加快政府职能转变，促进投资贸易便利化，形成与国际投资贸易通行规则相衔接的制度创新体系；主动服务北京国际交往中心功能，培育区域开放合作竞争新优势，加强与京津、境内其他区域及港澳台地区的合作交流，打造扩大开放新高地和对外合作新平台，为提升京津冀开放型经济水平作出重要贡献。</p><h3 id="第五节-建设目标"><a href="#第五节-建设目标" class="headerlink" title="第五节　建设目标"></a>第五节　建设目标</h3><p>　　到2035年，基本建成绿色低碳、信息智能、宜居宜业、具有较强竞争力和影响力、人与自然和谐共生的高水平社会主义现代化城市。城市功能趋于完善，新区交通网络便捷高效，现代化基础设施系统完备，高端高新产业引领发展，优质公共服务体系基本形成，白洋淀生态环境根本改善。有效承接北京非首都功能，对外开放水平和国际影响力不断提高，实现城市治理能力和社会管理现代化，“雄安质量”引领全国高质量发展作用明显，成为现代化经济体系的新引擎。</p><p>　　到本世纪中叶，全面建成高质量高水平的社会主义现代化城市，成为京津冀世界级城市群的重要一极。集中承接北京非首都功能成效显著，为解决“大城市病”问题提供中国方案。新区各项经济社会发展指标达到国际领先水平，治理体系和治理能力实现现代化，成为新时代高质量发展的全国样板。彰显中国特色社会主义制度优越性，努力建设人类发展史上的典范城市，为实现中华民族伟大复兴贡献力量。</p><h2 id="第二章-构建科学合理空间布局"><a href="#第二章-构建科学合理空间布局" class="headerlink" title="第二章　构建科学合理空间布局"></a>第二章　构建科学合理空间布局</h2><p>　　坚持生态优先、绿色发展，统筹生产、生活、生态三大空间，构建蓝绿交织、和谐自然的国土空间格局，逐步形成城乡统筹、功能完善的组团式城乡空间结构，布局疏密有度、水城共融的城市空间。</p><h3 id="第一节-国土空间格局"><a href="#第一节-国土空间格局" class="headerlink" title="第一节　国土空间格局"></a>第一节　国土空间格局</h3><p>　　坚持以资源环境承载能力为刚性约束条件，以承接北京非首都功能疏解为重点，科学确定新区开发边界、人口规模、用地规模和开发强度，形成规模适度、空间有序、用地节约集约的城乡发展新格局。</p><p>　　坚持生态优先。将淀水林田草作为一个生命共同体进行统一保护、统一修复。通过植树造林、退耕还淀、水系疏浚等生态修复治理，强化对白洋淀湖泊湿地、林地以及其他生态空间的保护，确保新区生态系统完整，蓝绿空间占比稳定在70%。</p><p>　　严格控制建设用地规模。推进城乡一体规划建设，不断优化城乡用地结构，严格控制开发强度，新区远景开发强度控制在30%，建设用地总规模约530平方公里。</p><p>　　划定规划控制线。科学划定生态保护红线、永久基本农田、城镇开发边界三条控制线，加强各类规划空间控制线的充分衔接，统筹土地利用、环境保护、文物保护、防洪抗震等专项规划，实现多规合一。</p><p>　　严守生态保护红线。先期划定以白洋淀核心区为主的生态保护红线，远期结合森林斑块和生态廊道建设逐步扩大。</p><p>　　严格保护永久基本农田。耕地占新区总面积18%左右，其中永久基本农田占10%。落实永久基本农田保护目标任务，加快数据库建设和信息化管理，实行全面监测。结合土地整治措施，加大高标准农田建设力度，确保永久基本农田确定后总量不减少、用途不改变、质量有提高。</p><p>　　严控城镇开发边界和人口规模。划定起步区、外围组团、特色小城镇开发边界，实行战略留白，为国家重大发展战略和城市可持续发展预留空间。合理控制人口密度，新区规划建设区按1万人/平方公里控制。</p><h3 id="第二节-城乡空间布局"><a href="#第二节-城乡空间布局" class="headerlink" title="第二节　城乡空间布局"></a>第二节　城乡空间布局</h3><p>　　综合考虑新区定位、发展目标和现状条件，坚持城乡统筹、均衡发展、宜居宜业，规划形成“一主、五辅、多节点”的新区城乡空间布局。</p><p>　　“一主”即起步区，选择容城、安新两县交界区域作为起步区，是新区的主城区，按组团式布局，先行启动建设。“五辅”即雄县、容城、安新县城及寨里、昝岗五个外围组团，全面提质扩容雄县、容城两个县城，优化调整安新县城，建设寨里、昝岗两个组团，与起步区之间建设生态隔离带。“多节点”即若干特色小城镇和美丽乡村，实行分类特色发展，划定特色小城镇开发边界，严禁大规模开发房地产。</p><p>　　美丽乡村为新区城乡体系的重要组成部分，实施乡村振兴战略，以产业兴旺、生态宜居、乡风文明、治理有效、生活富裕为目标，构建一体化、网络化的城乡体系。保持自然风光、田园风貌，突出历史记忆、地域特色，规划建设特色村落，充分利用清洁能源，建成基础设施完善、服务体系健全、基层治理有效、公共服务水平较高的宜居宜业宜游的美丽乡村。美丽乡村规划建设用地规模约50平方公里。</p><h3 id="第三节-起步区空间布局"><a href="#第三节-起步区空间布局" class="headerlink" title="第三节　起步区空间布局"></a>第三节　起步区空间布局</h3><p>　　顺应自然、随形就势，综合考虑地形地貌、水文条件、生态环境等因素，科学布局城市建设组团，形成“北城、中苑、南淀”的总体空间格局。“北城”即充分利用地势较高的北部区域，集中布局五个城市组团，各组团功能相对完整，空间疏密有度，组团之间由绿廊、水系和湿地隔离；“中苑”即利用地势低洼的中部区域，恢复历史上的大溵古淀，结合海绵城市建设，营造湿地与城市和谐共融的特色景观；“南淀”即南部临淀区域，通过对安新县城和淀边村镇改造提升和减量发展，严控临淀建设，利用白洋淀生态资源和燕南长城遗址文化资源，塑造传承文化特色、展现生态景观、保障防洪安全的白洋淀滨水岸线。</p><p>　　先行规划建设启动区。在起步区适当区域规划建设启动区，面积20－30平方公里，重点承接北京非首都功能疏解，突出创新特色，提供优质公共服务，集聚一批互联网、大数据、人工智能、前沿信息技术、生物技术、现代金融、总部经济等创新型、示范性重点项目，发挥引领带动作用；加强生态环境建设，打造韧性安全的城市基础设施，精心塑造城市特色，形成宜居宜业现代化城市风貌。</p><h2 id="第三章-塑造新时代城市风貌"><a href="#第三章-塑造新时代城市风貌" class="headerlink" title="第三章　塑造新时代城市风貌"></a>第三章　塑造新时代城市风貌</h2><p>　　坚持中西合璧、以中为主、古今交融，弘扬中华优秀传统文化，保留中华文化基因，彰显地域文化特色；加强城市设计，塑造城市特色，保护历史文化，形成体现历史传承、文明包容、时代创新的新区风貌。</p><h3 id="第一节-总体城市设计"><a href="#第一节-总体城市设计" class="headerlink" title="第一节　总体城市设计"></a>第一节　总体城市设计</h3><p>　　统筹各类空间资源，整合生态人文要素，依托白洋淀清新优美的生态环境，利用城镇周边开阔自然的田野风光，随形就势，平原建城，形成疏密有度、水城共融的城镇空间，清新明亮的宜人环境，舒展起伏的天际线，展现新时代城市形象。</p><p>　　起步区城市设计。融合城水林田淀等特色要素，深化“北城、中苑、南淀”的空间结构设计，形成“一方城、两轴线、五组团、十景苑、百花田、千年林、万顷波”的空间意象。传承中华营城理念，构建布局规制对称、街坊尺度宜人的中心“方城”；按照传承历史、开创未来的设计理念，塑造体现中华文明、凝聚城市精神、承载中心功能的城市轴线；按照功能相对完整、空间疏密有度的理念，布局五个尺度适宜、功能混合、职住均衡的紧凑组团；利用水文地貌和历史文化，塑造以大溵古淀为核心的生态苑囿；保留农耕记忆、营造花海景观，形成三季有花、四季有绿的都市田园风光；大规模植树造林，形成起步区外围林带环绕、内部树木葱郁的良好生态；开展白洋淀生态环境修复，展现碧波万顷、荷塘苇海的水域生态景观，实现城淀共生共荣。</p><p>　　规划设计城市轴线。南北中轴线展示历史文化生态特色，突出中轴对称、疏密有致、灵动均衡；东西轴线利用交通廊道串联城市组团，集聚创新要素、事业单位、总部企业、金融机构等。</p><p>　　塑造城市天际线。传承中华文化基因，充分体现对称、天人合一、街坊等中华营城理念，广泛吸收借鉴全球优秀的城市设计成果，塑造轮廓舒展、韵律起伏的城市天际线，形成独具特色的城市空间形态。严格控制建筑高度，不能到处是水泥森林和玻璃幕墙；根据城市功能布局和产业特点，在新区特定范围规划建设高层建筑，集中承载中央商务、金融、企业总部等功能。精心设计建筑顶部，优化美化建筑第五立面，构建形态色彩整体和谐统一的城市空间界面和轮廓线。</p><p>　　启动区城市设计。充分利用区位条件，以淀泊景观为依托规划设计启动区空间布局，形成城淀相望的格局。通过轴带空间设计，实现启动区核心功能与景观环境的有机融合。组团外构建生态湿地网络，组团内串联景观水体，形成内外相连、城水相依的特色景观。注重园林绿化的文化内涵和景观效果，构建城市公园与游憩绿地，实现城中有园、园中有城。</p><h3 id="第二节-城市风貌特色"><a href="#第二节-城市风貌特色" class="headerlink" title="第二节　城市风貌特色"></a>第二节　城市风貌特色</h3><p>　　塑造中华风范、淀泊风光、创新风尚的城市风貌。城市空间格局秩序规整、灵动自然，体现中华风范；环境景观城景应和、蓝绿交织，凸显淀泊风光；建筑设计古今融合、中西合璧、多元包容，展示创新风尚。</p><p>　　打造中西合璧、以中为主、古今交融的建筑风貌。传承中华建筑文化基因，吸收世界优秀建筑设计理念和手法，坚持开放、包容、创新、面向未来，形成独具特色的建筑风格。严谨细致做好建筑设计，塑造出既体现我国建筑特色又吸收国外建筑精华，既有古典神韵又具现代气息，融于自然、端正大气的优秀建筑，营造多样化、有活力的城市空间环境。</p><p>　　因地制宜设计丰富多样的环境景观。结合城市组团布局以及城市各级中心、重要公共空间和标志性建筑，打造城市空间景观廊道和景观节点体系；利用城市森林、组团隔离带，营造大尺度绿色空间；依托白洋淀、重要水系、湿地，塑造滨水活动空间，丰富亲水活动类型；保留有价值历史遗存，推广种植乡土植物，形成多层次、多季节、多色彩的植物群落配置，再现林淀环绕的华北水乡、城绿交融的中国画卷。</p><p>　　营造优美、安全、舒适、共享的城市公共空间。提高公共空间覆盖率、连续性，注重城市绿道、公园布局与开放空间的串联融合，实现5分钟步行可达；注重街区、邻里空间设计，形成尺度宜人、亲切自然、全龄友好的社区环境；注重人性化、艺术化设计，提升城市空间品质与文化品位，打造具有文化特色和历史记忆的公共空间。</p><h3 id="第三节-历史文化保护"><a href="#第三节-历史文化保护" class="headerlink" title="第三节　历史文化保护"></a>第三节　历史文化保护</h3><p>　　保护与合理利用文物古迹。严格保护省级以上文物保护单位、红色文化以及其他重要文物遗存，重点保护和利用南阳遗址、宋辽边关地道、燕南长城遗址等代表性历史遗存。结合历史遗存保护，建设考古遗址公园、遗址博物馆、陈列馆。</p><p>　　保护与发展历史古城、传统村镇。将标志性历史遗存的保护与城市公共空间的建设有机结合，保护传统村镇内历史空间格局清晰、传统风貌较为完整的核心地段，传承与展示水乡生产习俗和民俗文化活动。</p><p>　　传承与弘扬优秀传统文化。弘扬以雁翎队为代表的红色革命文化，加强圈头村音乐会、安新芦苇画等非物质文化遗产的保护与传承；发掘与保护老地名、老字号、历史名人、民间传说等其他优秀传统文化。开展口述史、民俗、文化典籍的整理、出版、阐释和普及，引导公众自觉保护与传承历史文化。</p><h2 id="第四章-打造优美自然生态环境"><a href="#第四章-打造优美自然生态环境" class="headerlink" title="第四章　打造优美自然生态环境"></a>第四章　打造优美自然生态环境</h2><p>　　践行生态文明理念，尊重自然、顺应自然、保护自然，统筹城水林田淀系统治理，做好白洋淀生态环境保护，恢复“华北之肾”功能；大规模植树造林，开展国土绿化，构建宁静、和谐、美丽的自然环境；推动区域流域协同治理，全面提升生态环境质量，建成新时代的生态文明典范城市。</p><h3 id="第一节-实施白洋淀生态修复"><a href="#第一节-实施白洋淀生态修复" class="headerlink" title="第一节　实施白洋淀生态修复"></a>第一节　实施白洋淀生态修复</h3><p>　　恢复淀泊水面。实施退耕还淀，淀区逐步恢复至360平方公里左右。建立多水源补水机制，统筹引黄入冀补淀、上游水库及本地非常规水资源，合理调控淀泊生态水文过程，使白洋淀正常水位保持在6.5－7.0米。建设水系连通工程，联合调度安格庄、西大洋、王快、龙门等上游水库水量，恢复淀泊水动力过程。</p><p>　　实现水质达标。优化流域产业结构，加强水环境治理，坚持流域“控源－截污－治河”系统治理，实施入淀河流水质目标管理，全面治理工业污染源，强化城镇、乡村污水收集处理，有效治理农业面源污染，打造良好河流生态环境，确保入淀河流水质达标。合理划定清淤范围，科学有序实施淀内生态清淤，消除内源污染，修复水体底部水生动物栖息生态环境，提升淀泊水环境质量，将白洋淀水质逐步恢复到Ⅲ－Ⅳ类。</p><p>　　开展生态修复。利用自然本底优势，结合生态清淤，优化淀区生态格局，对现有苇田荷塘进行微地貌改造和调控，修复多元生境，展现白洋淀荷塘苇海自然景观。实施生态过程调控，恢复退化区域的原生水生植被，促进水生动物土著种增殖和种类增加，恢复和保护鸟类栖息地，提高生物多样性，优化生态系统结构，增强白洋淀生态自我修复能力。</p><p>　　远景规划建设白洋淀国家公园。完善生物资源保护策略，保护淀区独特的自然生境和景观，保持淀区湿地生态系统完整性，努力建成人与自然和谐共生的试验区和科普教育基地。</p><p>　　创新生态环境管理。优化完善白洋淀及上游生态环境管理机制，加强生态空间管控体系建设，实施智能生态管控，全面建成与生态文明发展要求相适应的生态环境管理模式。</p><h3 id="第二节-加强生态环境建设"><a href="#第二节-加强生态环境建设" class="headerlink" title="第二节　加强生态环境建设"></a>第二节　加强生态环境建设</h3><p>　　构建新区生态安全格局。规划建设“一淀、三带、九片、多廊”，形成林城相融、林水相依的生态城市。“一淀”即开展白洋淀环境治理和生态修复，恢复“华北之肾”功能；“三带”即建设环淀绿化带、环起步区绿化带、环新区绿化带，优化城淀之间、组团之间和新区与周边区域之间的生态空间结构；“九片”即在城市组团间和重要生态涵养区建设九片大型森林斑块，增强碳汇能力和生物多样性保护功能；“多廊”即沿新区主要河流和交通干线两侧建设多条绿色生态廊道，发挥护蓝、增绿、通风、降尘等作用。</p><p>　　开展大规模植树造林。采用近自然绿化及多种混交方式，突出乡土树种和地方特色，在新区绿化带及生态廊道建设生态防护林和景观生态林，形成平原林网体系，实现生态空间的互联互通。开展大规模国土绿化行动，将新区森林覆盖率由现状的11%提高到40%。</p><p>　　塑造高品质城区生态环境。建设城市通风廊道，构造城淀局地气流微循环系统，将白洋淀凉爽空气输送到城市中心。构建由大型郊野生态公园、大型综合公园及社区公园组成的宜人便民公园体系，实现森林环城、湿地入城，3公里进森林，1公里进林带，300米进公园，街道100%林荫化，绿化覆盖率达到50%。</p><p>　　提升区域生态安全保障。构建衔接“太行山脉－渤海湾”和“京南生态绿楔－拒马河－白洋淀”生态廊道，形成连山通海、南北交融的区域生态安全格局。实施重要生态系统保护和修复工程，优化生态安全屏障体系，提升生态系统质量。</p><h3 id="第三节-开展环境综合治理"><a href="#第三节-开展环境综合治理" class="headerlink" title="第三节　开展环境综合治理"></a>第三节　开展环境综合治理</h3><p>　　推动区域环境协同治理。新区及周边和上游地区协同制定产业政策，实行负面清单制度，依法关停、严禁新建高污染、高耗能企业和项目。提升传统产业的清洁生产、节能减排和资源综合利用水平，加强生态保护和环境整治，强化综合监管。集中清理整治散乱污企业、农村生活垃圾和工业固体废弃物。开展地下水环境调查评估，全面开展渗坑、排污沟渠综合整治。</p><p>　　改善大气环境质量。优化能源消费结构，终端能源消费全部为清洁能源。严格控制移动源污染，实行国内最严格的机动车排放标准，严格监管非道路移动源；巩固农村清洁取暖工程效果，实现新区散煤“清零”；构建过程全覆盖、管理全方位、责任全链条的建筑施工扬尘治理体系。根据区域大气传输影响规律，在石家庄－保定－北京大气传输带上，系统治理区域大气环境。</p><p>　　严守土壤环境安全底线。落实土壤污染防治行动计划，推进固体废物堆存场所排查整治，加强污染源防控、检测、治理，确保土壤环境安全。</p><h2 id="第五章-发展高端高新产业"><a href="#第五章-发展高端高新产业" class="headerlink" title="第五章　发展高端高新产业"></a>第五章　发展高端高新产业</h2><p>　　瞄准世界科技前沿，面向国家重大战略需求，通过承接符合新区定位的北京非首都功能疏解，积极吸纳和集聚创新要素资源，高起点布局高端高新产业，推进军民深度融合发展，加快改造传统产业，建设实体经济、科技创新、现代金融、人力资源协同发展的现代产业体系。</p><h3 id="第一节-承接北京非首都功能疏解"><a href="#第一节-承接北京非首都功能疏解" class="headerlink" title="第一节　承接北京非首都功能疏解"></a>第一节　承接北京非首都功能疏解</h3><p>　　明确承接重点。在高等学校和科研机构方面，重点承接著名高校在新区设立分校、分院、研究生院等，承接国家重点实验室、工程研究中心等国家级科研院所、创新平台、创新中心。在医疗健康机构方面，重点承接高端医疗机构在雄安新区设立分院和研究中心，加强与国内知名医学研究机构合作。在金融机构方面，承接银行、保险、证券等金融机构总部及分支机构，鼓励金融骨干企业、分支机构开展金融创新业务。在高端服务业方面，重点承接软件和信息服务、设计、创意、咨询等领域的优势企业，以及现代物流、电子商务等企业总部。在高技术产业方面，重点承接新一代信息技术、生物医药和生命健康、节能环保、高端新材料等领域的央企以及创新型民营企业、高成长性科技企业。支持中关村科技园在雄安新区设立分园区。</p><p>　　营造承接环境。打造一流硬件设施环境，有序推进基础设施建设，完善配套条件，推动疏解对象顺利落地。打造优质公共服务环境，率先建设一批高水平的幼儿园、中小学、医院等公共服务设施，提供租购并举的多元化住房保障，有效吸引北京人口转移。打造便民高效政务服务环境，建立新区政务服务平台，简化审批程序和环节，提供一站式服务。打造创新开放政策环境，在土地、财税、金融、人才、对外开放等方面，制定实施一揽子政策措施，确保疏解对象来得了、留得住、发展好。</p><h3 id="第二节-明确产业发展重点"><a href="#第二节-明确产业发展重点" class="headerlink" title="第二节　明确产业发展重点"></a>第二节　明确产业发展重点</h3><p>　　新一代信息技术产业。围绕建设数字城市，重点发展下一代通信网络、物联网、大数据、云计算、人工智能、工业互联网、网络安全等信息技术产业。近期依托5G率先大规模商用、IPv6率先布局，培育带动相关产业快速发展。发展物联网产业，推进智能感知芯片、智能传感器和感知终端研发及产业化。搭建国家新一代人工智能开放创新平台，重点实现无人系统智能技术的突破，建设开放式智能网联车示范区，支撑无人系统应用和产业发展。打造国际领先的工业互联网网络基础设施和平台，形成国际先进的技术与产业体系。推动信息安全技术研发应用，发展规模化自主可控的网络空间安全产业。超前布局区块链、太赫兹、认知计算等技术研发及试验。</p><p>　　现代生命科学和生物技术产业。率先发展脑科学、细胞治疗、基因工程、分子育种、组织工程等前沿技术，培育生物医药和高性能医疗器械产业，加强重大疾病新药创制。实施生物技术药物产业化示范工程、医疗器械创新发展工程、健康大数据与健康服务推广工程，建设世界一流的生物技术与生命科学创新示范中心、高端医疗和健康服务中心、生物产业基地。</p><p>　　新材料产业。聚焦人工智能、宽带通信、新型显示、高端医疗、高效储能等产业发展对新材料的重大需求，在新型能源材料、高技术信息材料、生物医学材料、生物基材料等领域开展应用基础研究和产业化，突破产业化制备瓶颈，培育新区产业发展新增长点。</p><p>　　高端现代服务业。接轨国际，发展金融服务、科创服务、商务服务、智慧物流、现代供应链、数字规划、数字创意、智慧教育、智慧医疗等现代服务业，促进制造业和服务业深度融合。集聚银行、证券、信托、保险、租赁等金融业态，依法合规推进金融创新，推广应用先进金融科技。围绕创新链构建服务链，发展创业孵化、技术转移转化、科技咨询、知识产权、检验检测认证等科技服务业，建设国家质量基础设施研究基地。发展设计、咨询、会展、电子商务等商务服务业，建设具有国际水准的总部商务基地。发展创意设计、高端影视等文化产业，打造国际文化交流重要基地。发展国际仲裁、律师事务所等法律服务业。</p><p>　　绿色生态农业。建设国家农业科技创新中心，发展以生物育种为主体的现代生物科技农业，推动苗木、花卉的育种和栽培研发，建设现代农业设施园区。融入科技、人文等元素，发展创意农业、认养农业、观光农业、都市农业等新业态，建设一二三产业融合发展示范区。</p><p>　　对符合发展方向的传统产业实施现代化改造提升，推进产业向数字化、网络化、智能化、绿色化发展。</p><h3 id="第三节-打造全球创新高地"><a href="#第三节-打造全球创新高地" class="headerlink" title="第三节　打造全球创新高地"></a>第三节　打造全球创新高地</h3><p>　　搭建国际一流的科技创新平台。按照国家科技创新基地总体部署，积极布局建设国家实验室、国家重点实验室、工程研究中心等一批国家级创新平台，努力打造全球创新资源聚集地。围绕集聚高端创新要素，加强与国内外知名教育科研机构及企业合作，建立以企业为主体、市场为导向、产学研深度融合的技术创新体系。推动建设一批未来产业研究院。</p><p>　　建设国际一流的科技教育基础设施。加强重大科技基础设施建设，实施一批国家科教创新工程，集中资源建设若干“人无我有、人有我优”的开放型重大科研设施、科技创新平台，布局一批公共大数据、基础研发支撑、技术验证试验等开放式科技创新支撑平台，全面提高创新支撑能力。建设世界一流研究型大学，培育一批优势学科，建设一批特色学院和高精尖研究中心；发挥高校在科技创新体系中的作用，集聚人才、学科、资源和平台优势，与科研院所、企业等合作，面向国家重大战略需求，打造知识溢出效应明显的大学园区；按照产教深度融合、中高职有效衔接的要求，建设具有国际先进水平的现代职业教育体系；整合各类科教资源，集中力量打造国际人才培训基地，为创新发展提供源头支撑。</p><p>　　构建国际一流的创新服务体系。创新国际科技合作模式，打造国际科技创新合作试验区，率先开展相关政策和机制试点。举办多层次多领域学术交流活动，搭建国际科技合作交流平台。发挥创新型领军企业引领作用，面向产业链上下游中小企业，构建线上线下融合的创新支撑服务体系。加快培育科技型中小企业，构建全链条孵化服务体系。加强知识产权保护及综合运用，形成产权创造、保护、交易、运用及管理的良性循环。</p><h3 id="第四节-完善产业空间布局"><a href="#第四节-完善产业空间布局" class="headerlink" title="第四节　完善产业空间布局"></a>第四节　完善产业空间布局</h3><p>　　坚持产城融合、职住均衡和以水定产、以产兴城原则，采取集中与分散相结合的方式，推动形成起步区、外围组团和特色小城镇协同发展的产业格局。</p><p>　　起步区。构建一流的承接平台、基础设施、公共服务，重点承接北京疏解的事业单位、总部企业、金融机构、高等院校、科研院所等功能，重点发展人工智能、信息安全、量子技术、超级计算等尖端技术产业基地，建设国家医疗中心。</p><p>　　五个外围组团。与起步区分工协作，按功能定位承接北京非首都功能疏解，布局电子信息、生命科技、文化创意、军民融合、科技研发等高端高新产业，以及支撑科技创新和产业发展的基础设施。</p><p>　　周边特色小城镇。因镇制宜，有序承接北京非首都功能疏解，布局形成各具特色的产业发展格局。北部小城镇主要以高端服务、网络智能、军民融合等产业为特色。南部小城镇主要以现代农业、生态环保、生物科技、科技金融、文化创意等产业为特色。</p><h2 id="第六章-提供优质共享公共服务"><a href="#第六章-提供优质共享公共服务" class="headerlink" title="第六章　提供优质共享公共服务"></a>第六章　提供优质共享公共服务</h2><p>　　坚持以人民为中心、注重保障和改善民生，引入京津优质教育、医疗卫生、文化体育等资源，建设优质共享的公共服务设施，提升公共服务水平，构建多元化的住房保障体系，增强新区承载力、集聚力和吸引力，打造宜居宜业、可持续发展的现代化新城。</p><h3 id="第一节-布局优质公共服务设施"><a href="#第一节-布局优质公共服务设施" class="headerlink" title="第一节　布局优质公共服务设施"></a>第一节　布局优质公共服务设施</h3><p>　　构建城市基本公共服务设施网络。建设“城市－组团－社区”三级公共服务设施体系，形成多层次、全覆盖、人性化的基本公共服务网络。城市级大型公共服务设施布局于城市中心地区，主要承担国际交往功能，承办国内大型活动，承接北京区域性公共服务功能疏解；组团级公共服务设施围绕绿地公园和公交枢纽布局，主要承担城市综合服务功能，提供全方位、全时段的综合服务；社区级公共服务设施布局于社区中心，主要承担日常生活服务功能，构建宜居宜业的高品质生活环境。</p><p>　　构建社区、邻里、街坊三级生活圈。社区中心配置中学、医疗服务机构、文化活动中心、社区服务中心、专项运动场地等设施，形成15分钟生活圈。邻里中心配置小学、社区活动中心、综合运动场地、综合商场、便民市场等设施，形成10分钟生活圈。街坊中心配置幼儿园、24小时便利店、街头绿地、社区服务站、文化活动站、社区卫生服务站、小型健身场所、快递货物集散站等设施，形成5分钟生活圈。</p><p>　　构建城乡一体化公共服务设施。城郊农村共享城市教育、医疗、文化等服务配套设施。特色小城镇参照城市社区标准，配置学校、卫生院、敬老院、文化站、运动健身场地等公共服务设施，提高优质公共服务覆盖率，构建乡镇基础生活圈。美丽乡村配置保障性基本公共服务设施、基础性生产服务设施和公共活动场所。大幅提高村镇公共交通服务水平，实现校车、公交等多种方式的绿色便捷出行。</p><h3 id="第二节-提升公共服务水平"><a href="#第二节-提升公共服务水平" class="headerlink" title="第二节　提升公共服务水平"></a>第二节　提升公共服务水平</h3><p>　　优先发展现代化教育。按照常住人口规模合理均衡配置教育资源，布局高质量的学前教育、义务教育、高中阶段教育，实现全覆盖。引进优质基础教育资源，创新办学模式，创建一批高水平的幼儿园、中小学校，培育建设一批国际学校、国际交流合作示范学校。支持“双一流”建设高校在新区办学，以新机制、新模式努力建设世界一流的雄安大学，统筹科研平台和设施、产学研用一体化创新中心资源，构建高水平、开放式、国际化高等教育聚集高地。统筹利用国内外教育资源，开展与国际高端职业教育机构的深度合作，规划建设新区职业院校，建设集继续教育、职业培训、老年教育等功能为一体的社区学院。</p><p>　　高标准配置医疗卫生资源。引进京津及国内外优质医疗资源，建设集临床服务、医疗教育、医学科研和成果转化为一体的医疗综合体；加快应急救援、全科、儿科、妇产科等领域建设，建设国际一流、国内领先的区域卫生应急体系和专科医院；全面打造15分钟基层医疗服务圈，基层医疗卫生机构标准化达标率100%；加快新区全民健康信息平台建设，大力发展智能医疗，建设健康医疗大数据应用中心，构建体系完整、分工明确、功能互补、密切协作的医疗卫生服务体系。</p><p>　　建立完备的公共文化服务体系。围绕建设多层次公共文化服务设施，在数字网络环境下，高标准布局建设博物馆、图书馆、美术馆、剧院等，在街道、社区建设综合文化站和文化服务中心。统筹文化要素资源，合理布局文化产业，促进文化产业高质量发展，推动公共文化服务与文化产业融合发展。</p><p>　　构建完善的全民健身体系。建设体育健身设施网络，鼓励体育设施与其他公共服务设施共建共享。开展全民健身活动，促进群众体育、竞技体育、体育产业、体育文化等各领域协调发展；积极承接京津丰富的赛事资源，引进国内外高端体育赛事，形成高水平、品牌化、持续性的系列赛事；充分发挥新区优势，大力发展健身休闲产业；以信息网络为技术支撑，努力创建智能型公共体育服务体系。</p><p>　　提升社会保障基本服务水平。以普惠性、保基本、均等化、可持续为目标，创新社会保障服务体系，建立健全社会保障基本制度，完善服务项目，提高服务标准，加大投入力度。切实保障残障人员、老人、儿童的教育、文化、医疗等基本公共服务，统筹考虑养老服务设施配置，建立健全未成年人关爱保护体系和殡葬公共服务体系。建立劳动就业服务制度，提供多层次公共就业服务，努力提升人民群众的获得感、幸福感、安全感。</p><h3 id="第三节-建立新型住房保障体系"><a href="#第三节-建立新型住房保障体系" class="headerlink" title="第三节　建立新型住房保障体系"></a>第三节　建立新型住房保障体系</h3><p>　　优化居住空间布局。统筹居住和就业，促进职住均衡。在轨道车站、大容量公共交通廊道节点周边，优先安排住宅用地；在城市核心区和就业岗位集聚、公共交通便捷、具有较高商业价值的地区，布局混合性居住空间，实现合理公交通勤圈内的职住均衡。</p><p>　　改革创新住房制度。坚持房子是用来住的、不是用来炒的定位，建立多主体供给、多渠道保障、租购并举的住房制度。坚持保障基本、兼顾差异、满足多层次个性化需求，建立多元化住房供应体系。坚持市场主导、政府引导，形成供需匹配、结构合理、流转有序、支出与消费能力基本适应的住房供应格局。完善多层次住房供给政策和市场调控体制，严控房地产开发，建立严禁投机的长效机制。探索房地产金融产品创新。</p><h2 id="第七章-构建快捷高效交通网"><a href="#第七章-构建快捷高效交通网" class="headerlink" title="第七章　构建快捷高效交通网"></a>第七章　构建快捷高效交通网</h2><p>　　按照网络化布局、智能化管理、一体化服务要求，加快建立连接雄安新区与京津及周边其他城市、北京新机场之间的轨道交通网络；完善雄安新区与外部连通的高速公路、干线公路网；坚持公交优先，综合布局各类城市交通设施，实现多种交通方式的顺畅换乘和无缝衔接，打造便捷、安全、绿色、智能交通体系。</p><h3 id="第一节-完善区域综合交通网络"><a href="#第一节-完善区域综合交通网络" class="headerlink" title="第一节　完善区域综合交通网络"></a>第一节　完善区域综合交通网络</h3><p>　　优化高速铁路网。构建“四纵两横”区域高速铁路交通网络，重点加强雄安新区和北京、天津、石家庄等城市的联系。“四纵”为京广高铁、京港台高铁京雄－雄商段、京雄－石雄城际、新区至北京新机场快线，“两横”为津保铁路、津雄城际－京昆高铁忻雄段，实现新区高效融入“轨道上的京津冀”，20分钟到北京新机场，30分钟到北京、天津，60分钟到石家庄。</p><p>　　完善高速公路网。构建“四纵三横”区域高速公路网。“四纵”为京港澳高速、大广高速、京雄高速（含新机场北线高速支线）、新机场至德州高速，“三横”为荣乌高速新线、津雄高速、津石高速，实现新区60分钟到北京、天津，90分钟到石家庄。加强新区与天津港、黄骅港交通联系，畅通新区出海通道。</p><p>　　提升航空服务水平。依托高速铁路、高速公路网络，加强新区与北京新机场、首都国际机场、天津滨海机场、石家庄正定机场之间的快速高效联系。</p><p>　　合理布局综合交通枢纽。依托高铁、城际站，强化路网对接和多种交通方式衔接，构建综合交通枢纽，形成“两主两辅”枢纽格局。“两主”为雄安高铁站、城际站，高铁站枢纽布局在昝岗组团，依托国家高铁网，便捷联系全国；城际站枢纽布局在启动区，站城一体，实现与京津冀核心城市直连直通。“两辅”为白洋淀站、白沟站，依托既有线路，服务新区北部外围组团，兼顾货运物流。</p><h3 id="第二节-构建新区便捷交通体系"><a href="#第二节-构建新区便捷交通体系" class="headerlink" title="第二节　构建新区便捷交通体系"></a>第二节　构建新区便捷交通体系</h3><p>　　规划建设运行高效的城市轨道交通。按照网络化、多模式、集约型的原则，以起步区和外围组团为主体布局轨道交通网络，实现起步区与外围组团、城镇的便捷联系。根据新区建设步骤和人口规模、交通出行需求，有序建设轨道交通，对地铁作规划空间预留。加强规划控制并预留市域、区域轨道交通通道走廊空间。规划中低运量轨道交通系统，衔接大运量轨道交通。</p><p>　　构建功能完备的新区骨干道路网。外迁荣乌高速新区段，改造原线位为城市快速路，形成起步区与雄县、昝岗组团及保定市区之间的快速通道。外迁G230、G336、G106等公路，形成新区公路外环，分流过境交通。构建以起步区和雄县、昝岗组团为主体，外围组团和特色小城镇全覆盖、网络化布局的骨干道路网络，建设舒适宜人的环淀景观道路。</p><p>　　构建快速公交专用通道。因地制宜构建网络化、全覆盖、快速高效的公共交通专用通道，兼顾物流配送；充分利用智能交通技术和装备，提高公交系统效率，增强安全、便捷和舒适度，实现高品质、智能化的公共交通和物流配送服务。</p><p>　　科学规划路网密度。起步区外围布局交通性干道，内部按城市街道理念设计，提高路网密度，起步区路网密度达到10－15公里/平方公里，合理设计道路宽度。</p><p>　　构建内外衔接的绿道网络。布局区域绿道、城市绿道、社区绿道三级网络，由城市绿道串联各综合公园、社区公园，形成城乡一体、区域联动的城市绿道体系。营造独立舒适的绿道环境，设置适宜骑行、步行的慢行系统，与机动车空间隔离，承载市民健身、休闲、娱乐功能。满足群众性文体活动和赛事需求，安排适宜慢行要求的各类设施。</p><p>　　打造集约智能共享的物流体系。构建由分拨中心、社区配送中心组成的两级城乡公共物流配送设施体系，分拨中心与对外交通枢纽一体布局，社区配送中心依托各城乡社区服务中心布局，服务新区生产生活物资及快件集散。</p><h3 id="第三节-打造绿色智能交通系统"><a href="#第三节-打造绿色智能交通系统" class="headerlink" title="第三节　打造绿色智能交通系统"></a>第三节　打造绿色智能交通系统</h3><p>　　提高绿色交通和公共交通出行比例。构建“公交＋自行车＋步行”的出行模式，起步区绿色交通出行比例达到90%。加强交通与用地布局协调，推广交通枢纽与城市功能一体化开发模式，在公共交通廊道、轨道站点周边集中布局公共服务设施。提升公共交通系统覆盖的人口数量，起步区公共交通占机动化出行比例达到80%。</p><p>　　建立服务优质、形式多样的新型公交系统。新区布局“干线＋普线”两级城乡公交网络，干线服务起步区与外围组团、城镇，普线连接外围组团与村镇的公交系统。起步区布局“快线＋干线＋支线”三级城区公交网络，快线服务区内组团间出行，干线服务组团内出行，支线灵活设置线路、站点深入社区，实现地面地下协同调度、各类公交便捷换乘的高品质服务。</p><p>　　搭建智能交通体系框架。以数据流程整合为核心，适应不同应用场景，以物联感应、移动互联、人工智能等技术为支撑，构建实时感知、瞬时响应、智能决策的新型智能交通体系框架。</p><p>　　建设数字化智能交通基础设施。通过交通网、信息网、能源网“三网合一”，基于智能驾驶汽车等新型载运工具，实现车车、车路智能协同，提供一体化智能交通服务。</p><p>　　示范应用共享化智能运载工具。推进智能驾驶运载工具的示范应用，发展需求响应型的定制化公共交通系统，智能生成线路，动态响应需求。探索建立智能驾驶和智能物流系统。</p><p>　　打造全局动态的交通管控系统。建立数据驱动的智能化协同管控系统，探索智能驾驶运载工具的联网联控，采用交叉口通行权智能分配，保障系统运行安全，提升系统运行效率。</p><h2 id="第八章-建设绿色智慧新城"><a href="#第八章-建设绿色智慧新城" class="headerlink" title="第八章　建设绿色智慧新城"></a>第八章　建设绿色智慧新城</h2><p>　　按照绿色、智能、创新要求，推广绿色低碳的生产生活方式和城市建设运营模式，使用先进环保节能材料和技术工艺标准进行城市建设，营造优质绿色市政环境，加强综合地下管廊建设，同步规划建设数字城市，筑牢绿色智慧城市基础。</p><h3 id="第一节-坚持绿色低碳发展"><a href="#第一节-坚持绿色低碳发展" class="headerlink" title="第一节　坚持绿色低碳发展"></a>第一节　坚持绿色低碳发展</h3><p>　　严格控制碳排放。优化能源结构，推进资源节约和循环利用，推广绿色低碳的生产生活方式和城市建设运营模式，保护碳汇空间、提升碳汇能力。</p><p>　　确定用水总量和效率红线。按照以水定城、以水定人的要求，强化用水总量管理。实行最严格水资源管理制度，实施节约用水制度化管理，对城市生活、农业等各类用水强度指标严格管控，全面推进节水型社会建设。</p><p>　　建设海绵城市。尊重自然本底，构建河湖水系生态缓冲带，提升城市生态空间在雨洪调蓄、雨水径流净化、生物多样性等方面的功能，促进生态良性循环。综合采用“雨水花园、下沉式绿地、生态湿地”等低影响开发设施，实现中小降雨100%自然积存、净化，规划城市建设区雨水年径流总量控制率不低于85%。</p><p>　　推广绿色建筑。全面推动绿色建筑设计、施工和运行，开展节能住宅建设和改造。新建政府投资及大型公共建筑全面执行三星级绿色建筑标准。</p><p>　　使用绿色建材。引导选用绿色建材，开发选用当地特色的自然建材、清洁生产和更高环保认证水准的建材、旧物利用和废弃物再生的建材，积极稳妥推广装配式、可循环利用的建筑方式。</p><h3 id="第二节-构建绿色市政基础设施体系"><a href="#第二节-构建绿色市政基础设施体系" class="headerlink" title="第二节　构建绿色市政基础设施体系"></a>第二节　构建绿色市政基础设施体系</h3><p>　　建设集约高效的供水系统。划分城镇供水分区，各分区间设施集成共享、互为备用，提高供水效率。因地制宜推进雨水和再生水等各类非常规水资源利用，实现用水分类分质供应，采用管网分区计量管理，提高管网精细化、信息化管理水平，有效节约水资源。</p><p>　　完善雨污分流的雨水排除工程系统。加强城市排水河道、排涝渠、雨水调蓄区、雨水管网和泵站等工程建设，实现建成区雨水系统全覆盖。新建雨水系统全部实行雨水、污水分流制，逐步将容城、雄县、安新县城现有合流系统改造为分流制。</p><p>　　建设循环再生的污水处理系统。统筹考虑污水收集处理和再生利用的便捷性、经济性，建设适度分散的设施。在特色小城镇、村庄推广分散式生态化的污水处理技术。</p><p>　　完善保障有力的供电系统。增强区域电力供应，建设区域特高压供电网络。改造提升现有变电站，新建500千伏和220千伏变电站。积极引入风电、光电等可再生能源，作为新区电力供应的重要来源。新区供电可靠率达到99.999%。</p><p>　　建设安全可靠燃气供应系统。根据新区发展需要，以长输管道天然气为主要气源，LNG为调峰应急气源，新建若干门站、LNG储配站，形成多源多向、互联互通的新区燃气输配工程系统。</p><p>　　建设清洁环保的供热系统。科学利用地热资源，统筹天然气、电力、地热、生物质等能源供给方式，形成多能互补的清洁供热系统。</p><p>　　建设先进专业的垃圾处理系统。按照减量化、资源化、无害化的要求，全面实施垃圾源头分类减量、分类运输、分类中转、分类处置，建设兼具垃圾分类与再生资源回收功能的交投点、中转站、终端处理设施、生态环境园，最终实现原生垃圾零填埋，生活垃圾无害化处理率达到100%，城市生活垃圾回收资源利用率达到45%以上。</p><h3 id="第三节-合理开发利用地下空间"><a href="#第三节-合理开发利用地下空间" class="headerlink" title="第三节　合理开发利用地下空间"></a>第三节　合理开发利用地下空间</h3><p>　　有序利用地下空间。按照安全、高效、适度的原则，结合城市功能需求，积极利用浅层、次浅层空间，有条件利用次深层空间，弹性预留深层空间；协调各系统的空间布局，制定相互避让原则，明确各系统平面及竖向层次关系，实施分层管控及引导。</p><p>　　优先布局基础设施。在城市干路、高强度开发和管线密集地区，根据城市发展需要，建设干线、支线和缆线管廊等多级网络衔接的市政综合管廊系统。建设地下综合防灾设施，形成平灾结合、高效利用的地下综合防灾系统。</p><p>　　建立统筹协调机制。坚持统筹规划、整体设计、统一建设、集中管理，健全管理体制和运行机制，完善用地制度和权籍管理，推进地下空间管理信息化建设，保障地下空间有序利用。</p><h3 id="第四节-同步建设数字城市"><a href="#第四节-同步建设数字城市" class="headerlink" title="第四节　同步建设数字城市"></a>第四节　同步建设数字城市</h3><p>　　坚持数字城市与现实城市同步规划、同步建设，适度超前布局智能基础设施，推动全域智能化应用服务实时可控，建立健全大数据资产管理体系，打造具有深度学习能力、全球领先的数字城市。</p><p>　　加强智能基础设施建设。与城市基础设施同步建设感知设施系统，形成集约化、多功能监测体系，打造城市全覆盖的数字化标识体系，构建城市物联网统一开放平台，实现感知设备统一接入、集中管理、远程调控和数据共享、发布；打造地上地下全通达、多网协同的泛在无线网络，构建完善的城域骨干网和统一的智能城市专网；搭建云计算、边缘计算等多元普惠计算设施，实现城市数据交换和预警推演的毫秒级响应，打造汇聚城市数据和统筹管理运营的智能城市信息管理中枢，对城市全局实时分析，实现公共资源智能化配置。</p><p>　　构建全域智能化环境。推进数字化、智能化城市规划和建设，建立城市智能运行模式，建设智能能源、交通、物流系统等；构建城市智能治理体系，建设全程在线、高效便捷，精准监测、高效处置，主动发现、智能处置的智能政务、智能环保、数字城管。建立企业与个人数据账户，探索建立全数字化的个人诚信体系。健全城市智能民生服务，搭建普惠精准、定制服务的智能教育医疗系统，打造以人为本、全时空服务的智能社区。</p><p>　　建立数据资产管理体系。构建透明的全量数据资源目录、大数据信用体系和数据资源开放共享管理体系。建设安全可信的网络环境，建立安全态势感知、监测、预警、溯源、处置网络系统，打造全时、全域、全程的网络安全态势感知决策体系，加强网络安全相关制度建设。</p><h2 id="第九章-构筑现代化城市安全体系"><a href="#第九章-构筑现代化城市安全体系" class="headerlink" title="第九章　构筑现代化城市安全体系"></a>第九章　构筑现代化城市安全体系</h2><p>　　牢固树立和贯彻落实总体国家安全观，坚持政府主导与社会参与相结合，坚持以防为主、防抗救相结合，坚持常态减灾和非常态救灾相统一，针对自然灾害和城市运行安全、公共安全领域的突发事件，高标准规划建设重大防灾减灾基础设施，全面提升监测预警、预防救援、应急处置、危机管理等综合防范能力，形成全天候、系统性、现代化的城市安全保障体系，建设安全雄安。</p><h3 id="第一节-构建城市安全和应急防灾体系"><a href="#第一节-构建城市安全和应急防灾体系" class="headerlink" title="第一节　构建城市安全和应急防灾体系"></a>第一节　构建城市安全和应急防灾体系</h3><p>　　构筑城市安全运行体系。在新区水源保障、流域及城市防洪、能源供应、交通运营等与城市运行密切相关的各领域，运用区域协同、层级设防、智慧防灾、立体防护等防灾策略，抓住规划建设运营关键环节，超前布局、高质量建设、高效率管理，构建安全韧性的保障体系，为新区规划建设提供可靠支撑。</p><p>　　健全灾害预防体系。深化城市地震、气象、地质、生物等领域的灾害风险评估，建立水源、防洪、能源、交通等安全隐患防控体系，加强监测预警。优化城市综合防灾布局，合理确定防灾分区。构建城乡覆盖、区域协同，陆、水、空、地下全方位消防系统，加强“智慧消防”建设，城乡消防安全达到国际先进水平。建立安全可靠、体系完备、平战结合的人防工程系统，实现人防建设与城市建设融合发展。</p><p>　　构建城市公共安全体系。用最严谨的标准、最严格的监管、最严厉的处罚、最严肃的问责，建立科学完善的食品药品安全治理体系。加强城乡公共卫生设施建设和制度建设。开展爱国卫生运动，倡导健康文明生活方式，严防生物灾害与疫病疫情发生。高标准建设智能化社会治安防控体系，加强治安协同防控，提升应对突发公共事件的能力。加强电信网、广播电视网、互联网等基础网络的安全监管与保障，建立城市智能信息容灾备份系统。落实安全生产责任制，坚决防止重特大事故发生。</p><p>　　健全综合应急体系。按照防空防灾一体化、平战结合、平灾结合的原则，完善应急指挥救援系统，建立安全生产、市场监管、应急保障、环境保护、治安防控、消防安全、道路交通等部门公共数据资源共享机制。利用公园绿地、体育场馆、各类学校等旷地及地下空间，布局建设合理的避难场所及避难通道，形成就地避难、就近避难、步行避难的分级分类疏散系统。以干线公路网、城市干道网为主通道，建立安全、可靠、高效的疏散救援通道系统。建设供水、供电、燃气、交通等生命线应急保障系统；加强救灾物资储备，形成完备的救灾物资、生活必需品、医药物资和能源储备物资供应系统。严格相关管理制度，统筹加强各种应急保障设施运行维护、管理和保障。</p><p>　　提升综合防灾水平。利用信息智能等技术，构建全时全域、多维数据融合的城市安全监控体系，形成人机结合的智能研判决策和响应能力，做到响应过程无缝隙切换、指挥决策零延迟、事态进展实时可查可评估。全面提高综合防灾和城市设施安全标准，增强城市综合防灾能力。</p><h3 id="第二节-保障新区水安全"><a href="#第二节-保障新区水安全" class="headerlink" title="第二节　保障新区水安全"></a>第二节　保障新区水安全</h3><p>　　构建水源保障体系。依托南水北调、引黄入冀补淀等区域调水工程，合理利用上游水、当地水、再生水，完善新区供水网络，强化水源互联互通，形成多源互补的新区供水格局。</p><p>　　完善大清河流域防洪体系。按照上蓄、中疏、下排、适滞的原则，充分发挥白洋淀上游山区水库的拦蓄作用，疏通白洋淀行洪通道，适当加大下游河道的泄洪能力，加强堤防和蓄滞洪区建设，提升大清河流域防洪能力。</p><p>　　建设新区防洪安全体系。按照分区设防、重点保障原则，结合新区城镇规模及规划布局，确定起步区防洪标准为200年一遇，五个外围组团防洪标准为100年一遇，其他特色小城镇防洪标准原则上为50年一遇；综合采用“蓄、疏、固、垫、架”等措施，确保千年大计万无一失。坚持新区防洪设施建设与生态环境保护、城市建设相结合，顺应自然，实现人水和谐共处。</p><p>　　确保新区防涝安全。起步区内涝防治标准整体为50年一遇，五个外围组团内涝防治标准为30年一遇，其他特色小城镇为20年一遇。统筹用地竖向、排水管网、城市河道、调蓄水面等排水防涝设施，构建生态措施和工程措施相结合的系统化排水防涝体系，确保排水防涝安全。起步区内部建立纵横交织、主次分级的排涝通道，利用城市水系、蓝绿空间以及大溵古淀调蓄涝水，在线实时监测白洋淀水位，适时抽排城市内部雨水，构建“北截、中疏、南蓄、适排”的排水防涝格局。</p><h3 id="第三节-增强城市抗震能力"><a href="#第三节-增强城市抗震能力" class="headerlink" title="第三节　增强城市抗震能力"></a>第三节　增强城市抗震能力</h3><p>　　提高城市抗震防灾标准。新区抗震基本设防烈度Ⅷ度，学校、医院、生命线系统等关键设施按基本烈度Ⅷ度半抗震设防，避难建筑、应急指挥中心等城市要害系统按基本烈度Ⅸ度抗震设防。其他重大工程依据地震安全性评价结果进行抗震设防。</p><h3 id="第四节-保障新区能源供应安全"><a href="#第四节-保障新区能源供应安全" class="headerlink" title="第四节　保障新区能源供应安全"></a>第四节　保障新区能源供应安全</h3><p>　　落实安全、绿色、高效能源发展战略，突出节约、智能，打造绿色低碳、安全高效、智慧友好、引领未来的现代能源系统，实现电力、燃气、热力等清洁能源稳定安全供应，为新区建设发展夯实基础。</p><p>　　电力。坚持绿色供电，形成以接受区外清洁电力为主、区内分布式可再生能源发电为辅的供电方式。依托现有冀中南特高压电网，完善区域电网系统，充分消纳冀北、内蒙等北部地区风电、光电，形成跨区域、远距离、大容量的电力输送体系，保障新区电力供应安全稳定、多能互补和清洁能源全额消纳。长远谋划利用沿海核电。与华北电网一体化规划建设区内输配电网，配套相应的储能、应急设施，实现清洁电力多重保障。</p><p>　　燃气。构建多气源、多层级、广覆盖的城乡燃气供应体系。依托国家气源主干通道和气源点，建设新区接入系统，合理布局区内燃气管网，保障新区用气供应；长远谋划利用更为清洁的替代燃料。</p><p>　　热力。科学利用区内地热资源，综合利用城市余热资源，合理利用新区周边热源，规划建设区内清洁热源和高效供热管网，确保供热安全。</p><p>　　节能。坚持节能优先，发展绿色建筑，推行绿色出行，加快开展梯级利用、循环利用，建设集能源开发、输送、转换、服务及终端消费于一体的多能互补区域能源系统，把新区打造成为高效节能示范区。</p><p>　　智能。结合数字城市建设，运用互联网、物联网融合技术，推进能源管理智慧化、能源服务精细化、能源利用高效化，打造新区智能能源系统，进一步提高能源安全保障水平。</p><h2 id="第十章-保障规划有序有效实施"><a href="#第十章-保障规划有序有效实施" class="headerlink" title="第十章　保障规划有序有效实施"></a>第十章　保障规划有序有效实施</h2><p>　　雄安新区是留给子孙后代的历史遗产，必须坚持大历史观，保持历史耐心，稳扎稳打，一茬接着一茬干。完善规划体系，制定配套政策法规和技术规范，创新体制机制，强化政策保障，做好与周边区域规划衔接，加强新区及毗邻地区管控，促进协调发展，加强组织领导，保障规划有序有效实施，确保一张蓝图干到底。</p><h3 id="第一节-完善规划体系"><a href="#第一节-完善规划体系" class="headerlink" title="第一节　完善规划体系"></a>第一节　完善规划体系</h3><p>　　完善规划编制体系。新区规划纲要是编制新区各级各类规划的准则和指南，是指导新区建设发展的基本依据。坚持以规划纲要为统领、以控制性详细规划为重点、以专项规划为支撑，形成全域覆盖、分层管理、分类指导、多规合一的规划体系。按照把每一寸土地都规划得清清楚楚后再开工建设的要求，结合建设时序，深化细化控制性详细规划、修建性详细规划及各类专项规划，为新区全面建设做好准备。</p><p>　　健全规划管理体制。河北省承担新区各类规划的组织编制、审批、实施、管理等职责，落实多规合一，按法定程序和要求开展建设项目的审批、管理。</p><p>　　建立规划法规体系。依据国家有关法律法规和本规划纲要，研究推进雄安新区规划条例立法，按照创造“雄安质量”的要求，制定雄安新区规划技术标准、雄安新区规划建设管理技术规定等建设标准和技术规范。</p><p>　　畅通公众参与渠道。坚持开门开放编规划，汇众智、聚众力，搭建全过程、全方位的公众参与平台，健全规划公开制度，鼓励引导各领域专家和公众积极参与，在后续规划编制、决策、实施中发挥作用，确保规划反映民意，凝聚起人民群众建设新区的正能量。</p><p>　　统筹安排规划实施时序。根据相关阶段建设目标要求，制定各类规划实施方案和行动计划，适时启动重大项目建设，确保新区建设顺利进行。</p><h3 id="第二节-建立规划实施制度机制"><a href="#第二节-建立规划实施制度机制" class="headerlink" title="第二节　建立规划实施制度机制"></a>第二节　建立规划实施制度机制</h3><p>　　加强组织领导。在党中央、国务院领导下，按照京津冀协同发展领导小组部署要求，领导小组办公室加强综合协调，中央和国家机关有关部委、单位，北京市、天津市等方面大力支持，河北省委和省政府履行主体责任，雄安新区管委会负责规划纲要的具体实施。建立新区规划委员会制度，发挥组织协调和咨询审查作用，完善规划实施统筹决策机制。</p><p>　　加强规划监督评估。健全规划实施监管和考核问责制度，强化对规划实施的监督，确保规划有序落地。搭建新区国土空间基础信息平台和数字规划建设管理平台，建立“实施－监测－评估－维护”机制，提升规划的适应性。</p><p>　　强化规划刚性约束。本规划纲要与相关规划经批准后必须严格执行，任何部门和个人不得随意修改、违规变更，坚决维护规划的严肃性和权威性，确保一张蓝图干到底。</p><p>　　建立重大事项报告制度。在规划执行中遇有重大事项，及时向党中央、国务院和京津冀协同发展领导小组请示报告。</p><h3 id="第三节-创新体制机制与政策"><a href="#第三节-创新体制机制与政策" class="headerlink" title="第三节　创新体制机制与政策"></a>第三节　创新体制机制与政策</h3><p>　　围绕推进雄安新区规划实施，坚持深化改革、扩大开放，制定出台支持政策，打造体制机制新高地，为新区建设发展创造良好条件，发挥对全国全面深化改革扩大开放的引领示范作用。</p><p>　　深化行政体制改革。推进新区机构和行政管理体制改革，实行大部门制和扁平化管理，新区管理机构工作人员实行聘任制，优化干部培养选拔机制；按照河北省授权，新区行使有关行政审批权限和管理权限，推进行政审批制度改革，全面实行负面清单管理，建立全新的投资项目审批制度，提高行政服务效率；深化事业单位改革，强化公益属性，探索政事分开、管办分离的有效形式。</p><p>　　深化财税金融改革。建立长期稳定的资金筹措机制，中央财政通过设立雄安综合财力补助、统筹安排各类转移支付资金和加大地方政府长期债务支持力度等方式支持新区建设。对符合税制改革和新区发展方向的税收政策，在现行税收制度框架内支持在新区优先实施，对需要先行先试的可依法依规优先试点。支持雄安新区立足本地实际，率先在相关领域开展服务实体经济的金融创新或金融试验试点示范工作，推动国家级交易平台等重大金融项目先行先试，支持金融业对外开放新举措在新区落地。</p><p>　　创新人才人口管理。探索实行有利于激发新区创新活力的人事、薪酬、住房、税收、养老等政策。探索实行个人所得税改革。实行开放便捷的人才引进制度，在技术移民和外籍人才入境、停居留、永久居留等方面制定更加便利的措施，建立人才特区。推进人口管理创新，实施积分落户和居住证制度，建立以居住证为载体的公共服务提供机制。</p><p>　　推进土地管理制度改革。统筹解决新区所需建设用地规模、耕地保有量、永久基本农田保护面积和耕地占补平衡指标。创新土地供应政策，构建出让、划拨、作价出资（或入股）、租赁或先租后让、租让结合的多元化土地利用和土地供应模式。以土地综合整治为平台，统筹推进城水林田淀系统治理。</p><p>　　积极扩大对内对外开放。主动服务北京国际交往中心功能，利用京津冀三地对外开放基础和雄安新区自然环境优势，构筑对外交流平台。吸引国家对外开放平台、“一带一路”国际组织优先在新区布局，在新区举办国际及国内高端论坛。支持以雄安新区为核心设立中国（河北）自由贸易试验区，建设中外政府间合作项目（园区）和综合保税区，大幅度取消或降低外资准入限制，全面实行准入前国民待遇加负面清单管理模式，更好地以开放促改革、以开放促发展。</p><h3 id="第四节-强化区域协同发展"><a href="#第四节-强化区域协同发展" class="headerlink" title="第四节　强化区域协同发展"></a>第四节　强化区域协同发展</h3><p>　　加强新区及毗邻地区管控。划定新区周边一定范围为管控区，实施统一规划、严格管控，实行统一负面清单管理。划定城镇开发边界，严格控制城镇建设方向，防止“贴边”发展。建设新区周边绿色生态屏障，加强流域生态修复、水系连通、入淀河流综合治理，开展平原植树造林和大气污染联防联治。加快腾退与生态功能相冲突的用地，防止城乡建设无序发展，抑制人口过度聚集。严格产业准入管制，新区周边严禁高耗水、高耗能及高污染项目进入。</p><p>　　推进新区与周边地区协调发展。加强与国家有关单位、京津两市经常性、制度性协商，解决好涉及区域协同发展的相关规划建设问题。按照科学规划、合理布局的原则，新区着力与北京中心城区、北京城市副中心和天津市在功能上优势互补，实现错位发展、互利共赢；加强新区与保定、廊坊、沧州等周边地区相关规划的衔接，统筹承接北京非首都功能疏解，统筹推进新型城镇化建设，统筹安排教育、医疗、卫生、体育等功能，统筹布局生态、产业、交通和基础设施，实行协同规划、产业联动，努力打造协调发展示范区。</p><h2 id="附表：新区规划主要指标"><a href="#附表：新区规划主要指标" class="headerlink" title="附表：新区规划主要指标"></a>附表：新区规划主要指标</h2><p><img src="https://pic.lixl.cn/2020/129855813_15243164620331n.jpg" alt="新区规划主要指标"></p><h2 id="附图"><a href="#附图" class="headerlink" title="　附图"></a>　附图</h2><p>　　1.京津冀区域空间格局示意图</p><p>　　2.区域轨道交通规划图</p><p>　　3.区域高速公路规划图</p><p>　　4.新区城乡空间布局结构示意图</p><p>　　5.起步区空间布局示意图</p><p>　　6.白洋淀流域生态环境治理和保护规划图</p><p><img src="https://pic.lixl.cn/2020/129855813_15243157884891n.jpg" alt="2018年4月21日 图表：京津冀区域空间格局示意图 新华社发"></p><p><img src="https://pic.lixl.cn/2020/129855813_15243158790941n.jpg" alt="2018年4月21日 图表：区域轨道交通规划图 新华社发"></p><p><img src="https://pic.lixl.cn/2020/129855813_15243159146451n.jpg" alt="2018年4月21日 图表：区域高速公路规划图 新华社发"></p><p><img src="https://pic.lixl.cn/2020/129855813_15243159878051n.jpg" alt="2018年4月21日 图表：新区城乡空间布局结构示意图 新华社发"></p><p><img src="https://pic.lixl.cn/2020/129855813_15243160205561n.jpg" alt="2018年4月21日 图表：起步区空间布局示意图 新华社发"></p><p><img src="https://pic.lixl.cn/2020/129855813_15243160499701n.jpg" alt="2018年4月21日 图表：白洋淀流域生态环境治理和保护规划图 新华社发"></p>]]></content>
      
      
      <categories>
          
          <category> 政府规划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 政府规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>附录5、Kubectl 命令行界面</title>
      <link href="/2020/042827624.html"/>
      <url>/2020/042827624.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文是《<a href="https://www.lixl.cn/books/Docker/1-Overview/">Docker必知必会系列</a>》第十三篇，原文发布于个人博客：<a href="https://www.lixl.cn/">悟尘记</a>。</p><p>上一篇：<a href="https://www.lixl.cn/books/Docker/appendix4-docker-compose-file/">Docker必知必会系列（附录4）：Docker-compose 配置文件编写</a></p></blockquote><h2 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h2><p>Kubectl 是一个命令行接口，用于对 Kubernetes 集群运行命令。<code>kubectl</code> 在 $HOME/.kube 目录中寻找一个名为 config 的文件。您可以通过设置环境变量 KUBECONFIG 或设置[<code>--kubeconfig</code>参数指定其它配置文件。</p><h2 id="二、语法"><a href="#二、语法" class="headerlink" title="二、语法"></a>二、语法</h2><p>使用以下语法 <code>kubectl</code> 从终端窗口运行命令：</p><pre class="line-numbers language-shell"><code class="language-shell">kubectl [command] [TYPE] [NAME] [flags]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>其中 <code>command</code>、<code>TYPE</code>、<code>NAME</code> 和 <code>flags</code> 分别是：</p><ul><li><p><code>command</code>：指定要对一个或多个资源执行的操作，例如 <code>create</code>、<code>get</code>、<code>describe</code>、<code>delete</code>。</p></li><li><p><code>TYPE</code>：指定资源类型。资源类型不区分大小写，可以指定单数、复数或缩写形式。</p></li><li><p><code>NAME</code>：指定资源的名称。名称区分大小写。如果省略名称，则显示所有资源的详细信息 <code>kubectl get pods</code>。</p></li><li><p><code>flags</code>: 指定可选的参数。例如，可以使用 <code>-s</code> 或 <code>-server</code> 参数指定 Kubernetes API 服务器的地址和端口。</p></li></ul><blockquote><p>从命令行指定的参数会覆盖默认值和任何相应的环境变量。</p><p>如果需要帮助，只需从终端窗口运行 <code>kubectl help</code> 即可。</p></blockquote><h2 id="三、kubectl-命令列表"><a href="#三、kubectl-命令列表" class="headerlink" title="三、kubectl 命令列表"></a>三、kubectl 命令列表</h2><p>下表包含所有 kubectl 操作的简短描述和普通语法：</p><table><thead><tr><th align="left">操作</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>annotate</code></td><td align="left">添加或更新一个或多个资源的注解。</td></tr><tr><td align="left"><code>api-versions</code></td><td align="left">列出可用的 API 版本。</td></tr><tr><td align="left"><code>apply</code></td><td align="left">从文件或 stdin 对资源应用配置更改。</td></tr><tr><td align="left"><code>attach</code></td><td align="left">附加到正在运行的容器，查看输出流或与容器（stdin）交互。</td></tr><tr><td align="left"><code>autoscale</code></td><td align="left">自动伸缩由副本控制器管理的一组 pod。</td></tr><tr><td align="left"><code>cluster-info</code></td><td align="left">显示有关集群中主服务器和服务的端口信息。</td></tr><tr><td align="left"><code>config</code></td><td align="left">修改 kubeconfig 文件。有关详细信息，请参阅各个子命令。</td></tr><tr><td align="left"><code>create</code></td><td align="left">从文件或 stdin 创建一个或多个资源。</td></tr><tr><td align="left"><code>delete</code></td><td align="left">从文件、标准输入或指定标签选择器、名称、资源选择器或资源中删除资源。</td></tr><tr><td align="left"><code>describe</code></td><td align="left">显示一个或多个资源的详细状态。</td></tr><tr><td align="left"><code>diff</code></td><td align="left">将 live 配置和文件或标准输入做对比 (<strong>BETA</strong>)</td></tr><tr><td align="left"><code>edit</code></td><td align="left">使用默认编辑器编辑和更新服务器上一个或多个资源的定义。</td></tr><tr><td align="left"><code>exec</code></td><td align="left">对 pod 中的容器执行命令。</td></tr><tr><td align="left"><code>explain</code></td><td align="left">获取多种资源的文档。例如 pod, node, service 等。</td></tr><tr><td align="left"><code>expose</code></td><td align="left">将副本控制器、服务或 pod 作为新的 Kubernetes 服务暴露。</td></tr><tr><td align="left"><code>get</code></td><td align="left">列出一个或多个资源。</td></tr><tr><td align="left"><code>label</code></td><td align="left">添加或更新一个或多个资源的标签。</td></tr><tr><td align="left"><code>logs</code></td><td align="left">在 pod 中打印容器的日志。</td></tr><tr><td align="left"><code>patch</code></td><td align="left">使用策略合并 patch 程序更新资源的一个或多个字段。</td></tr><tr><td align="left"><code>port-forward</code></td><td align="left">将一个或多个本地端口转发到一个 pod。</td></tr><tr><td align="left"><code>proxy</code></td><td align="left">运行 Kubernetes API 服务器的代理。</td></tr><tr><td align="left"><code>replace</code></td><td align="left">从文件或标准输入中替换资源。</td></tr><tr><td align="left"><code>rolling-update</code></td><td align="left">通过逐步替换指定的副本控制器及其 pod 来执行滚动更新。</td></tr><tr><td align="left"><code>run</code></td><td align="left">在集群上运行指定的镜像。</td></tr><tr><td align="left"><code>scale</code></td><td align="left">更新指定副本控制器的大小。</td></tr><tr><td align="left"><code>stop</code></td><td align="left">不推荐：相反，请参阅 kubectl delete。</td></tr><tr><td align="left"><code>version</code></td><td align="left">显示运行在客户端和服务器上的 Kubernetes 版本。</td></tr></tbody></table><p>有关命令操作的更多信息，请参阅 <a href="https://kubernetes.io/docs/user-guide/kubectl/" target="_blank" rel="noopener">kubectl</a> 参考文档。</p><h2 id="四、资源类型"><a href="#四、资源类型" class="headerlink" title="四、资源类型"></a>四、资源类型</h2><p>列出全部支持的资源类型和它们的简称，无论它们是否是 <code>namespaced</code>, <code>Kind</code>。</p><pre class="line-numbers language-bash"><code class="language-bash">kubectl api-resources<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>用于探索 API 资源的其他操作：</p><pre class="line-numbers language-bash"><code class="language-bash">kubectl api-resources --namespaced<span class="token operator">=</span>true      <span class="token comment" spellcheck="true"># 所有在命名空间中的资源</span>kubectl api-resources --namespaced<span class="token operator">=</span>false     <span class="token comment" spellcheck="true"># 所有不在命名空间中的资源</span>kubectl api-resources -o name                <span class="token comment" spellcheck="true"># 输出简单的所有资源（只是资源名称）</span>kubectl api-resources -o wide                <span class="token comment" spellcheck="true"># 具有扩展（又称 "wide"）输出的所有资源</span>kubectl api-resources --verbs<span class="token operator">=</span>list,get       <span class="token comment" spellcheck="true"># 支持 "list" 和 "get" 请求动词的所有资源</span>kubectl api-resources --api-group<span class="token operator">=</span>extensions <span class="token comment" spellcheck="true"># "extensions" API 组中的所有资源</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="五、上下文和配置"><a href="#五、上下文和配置" class="headerlink" title="五、上下文和配置"></a>五、上下文和配置</h2><p>设置 <code>kubectl</code> 与哪个 Kubernetes 集群进行通信并修改配置信息。</p><pre class="line-numbers language-bash"><code class="language-bash">kubectl config view <span class="token comment" spellcheck="true"># 显示合并的 kubeconfig 配置。</span><span class="token comment" spellcheck="true"># 同时使用多个 kubeconfig 文件并查看合并的配置</span>KUBECONFIG<span class="token operator">=</span>~/.kube/config:~/.kube/kubconfig2 kubectl config view<span class="token comment" spellcheck="true"># 获取 e2e 用户的密码</span>kubectl config view -o jsonpath<span class="token operator">=</span><span class="token string">'{.users[?(@.name == "e2e")].user.password}'</span>kubectl config current-context              <span class="token comment" spellcheck="true"># 展示当前所处的上下文</span>kubectl config use-context my-cluster-name  <span class="token comment" spellcheck="true"># 设置默认的上下文为 my-cluster-name</span><span class="token comment" spellcheck="true"># 添加新的集群配置到 kubeconf 中，使用 basic auth 进行鉴权</span>kubectl config set-credentials kubeuser/foo.kubernetes.com --username<span class="token operator">=</span>kubeuser --password<span class="token operator">=</span>kubepassword<span class="token comment" spellcheck="true"># 使用特定的用户名和命名空间设置上下文。</span>kubectl config set-context gce --user<span class="token operator">=</span>cluster-admin --namespace<span class="token operator">=</span>foo \  <span class="token operator">&amp;&amp;</span> kubectl config use-context gce<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="六、常用命令备忘"><a href="#六、常用命令备忘" class="headerlink" title="六、常用命令备忘"></a>六、常用命令备忘</h2><h3 id="Apply"><a href="#Apply" class="headerlink" title="Apply"></a>Apply</h3><p>通过定义 Kubernetes 资源的文件管理应用程序。它通过运行 <code>kubectl apply</code> 在集群中创建和更新资源。这是在生产中管理 Kubernetes 应用程序的推荐方法。详情请查阅 <a href="https://kubectl.docs.kubernetes.io/" target="_blank" rel="noopener">Kubectl 文档</a>。</p><h3 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h3><p>Kubernetes 配置可以用 json 或 yaml 定义。可以使用的文件扩展名有 <code>.yaml</code>，<code>.yml</code> 和 <code>.json</code>。</p><pre class="line-numbers language-bash"><code class="language-bash">kubectl apply -f ./my-manifest.yaml           <span class="token comment" spellcheck="true"># 创建资源</span>kubectl apply -f ./my1.yaml -f ./my2.yaml     <span class="token comment" spellcheck="true"># 使用多个文件创建</span>kubectl apply -f ./dir                        <span class="token comment" spellcheck="true"># 从目录下的全部配置文件创建资源</span>kubectl apply -f https://git.io/vPieo         <span class="token comment" spellcheck="true"># 从 url 中创建资源</span>kubectl create deployment nginx --image<span class="token operator">=</span>nginx  <span class="token comment" spellcheck="true"># 启动单实例 nginx</span>kubectl explain pods,svc                       <span class="token comment" spellcheck="true"># 获取 pod，svc 配置的文档说明</span><span class="token comment" spellcheck="true"># 从标准输入中的多个 YAML 对象中创建</span><span class="token function">cat</span> <span class="token operator">&lt;&lt;</span>EOF <span class="token operator">|</span> kubectl apply -f -apiVersion: v1kind: Podmetadata:  name: busybox-sleepspec:  containers:  - name: busybox    image: busybox    args:    - <span class="token function">sleep</span>    - <span class="token string">"1000000"</span>---apiVersion: v1kind: Podmetadata:  name: busybox-sleep-lessspec:  containers:  - name: busybox    image: busybox    args:    - <span class="token function">sleep</span>    - <span class="token string">"1000"</span>EOF<span class="token comment" spellcheck="true"># 创建有多个 key 的 Secret</span><span class="token function">cat</span> <span class="token operator">&lt;&lt;</span>EOF <span class="token operator">|</span> kubectl apply -f -apiVersion: v1kind: Secretmetadata:  name: mysecrettype: Opaquedata:  password: <span class="token punctuation">$(</span>echo -n <span class="token string">"s33msi4"</span> <span class="token operator">|</span> base64 -w0<span class="token punctuation">)</span>  username: <span class="token punctuation">$(</span>echo -n <span class="token string">"jane"</span> <span class="token operator">|</span> base64 -w0<span class="token punctuation">)</span>EOF<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="获取和查找资源"><a href="#获取和查找资源" class="headerlink" title="获取和查找资源"></a>获取和查找资源</h3><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 使用 get 命令获取基本输出</span>kubectl get services                          <span class="token comment" spellcheck="true"># 列出当前命名空间下的所有 services</span>kubectl get pods --all-namespaces             <span class="token comment" spellcheck="true"># 列出所有命名空间下的全部的 pods</span>kubectl get pods -o wide                      <span class="token comment" spellcheck="true"># 列出当前命名空间下的全部 pods，有更多的详细信息</span>kubectl get deployment my-dep                 <span class="token comment" spellcheck="true"># 列出某个特定的 deployment</span>kubectl get pods --include-uninitialized      <span class="token comment" spellcheck="true"># 列出当前命名空间下的全部 pods，包含未初始化的</span>kubectl get pod my-pod -o yaml                <span class="token comment" spellcheck="true"># 获取一个 pod 的 YAML</span>kubectl get pod my-pod -o yaml --export       <span class="token comment" spellcheck="true"># 获取一个没有集群特定信息的 YAML</span><span class="token comment" spellcheck="true"># 使用 describe 命令获取详细输出</span>kubectl describe nodes my-nodekubectl describe pods my-podkubectl get services --sort-by<span class="token operator">=</span>.metadata.name <span class="token comment" spellcheck="true"># 列出当前命名空间下所有 services，按照名称排序</span><span class="token comment" spellcheck="true"># 列出 pods 按照重启次数进行排序</span>kubectl get pods --sort-by<span class="token operator">=</span><span class="token string">'.status.containerStatuses[0].restartCount'</span><span class="token comment" spellcheck="true"># 列出测试命名空间中的 Pod，按容量排序</span>kubectl get pods -n <span class="token function">test</span> --sort-by<span class="token operator">=</span>.spec.capacity.storage  <span class="token comment" spellcheck="true"># 获取包含 app=cassandra 标签全部 pods 的 version 标签</span>kubectl get pods --selector<span class="token operator">=</span>app<span class="token operator">=</span>cassandra -o \  jsonpath<span class="token operator">=</span><span class="token string">'{.items[*].metadata.labels.version}'</span><span class="token comment" spellcheck="true"># 获取所有工作节点(使用选择器以排除标签名称为 'node-role.kubernetes.io/master' 的结果)</span>kubectl get node --selector<span class="token operator">=</span><span class="token string">'!node-role.kubernetes.io/master'</span><span class="token comment" spellcheck="true"># 获取当前命名空间中正在运行的 pods</span>kubectl get pods --field-selector<span class="token operator">=</span>status.phase<span class="token operator">=</span>Running<span class="token comment" spellcheck="true"># 获取全部 node 的 ExternalIP 地址</span>kubectl get nodes -o jsonpath<span class="token operator">=</span><span class="token string">'{.items[*].status.addresses[?(@.type=="ExternalIP")].address}'</span><span class="token comment" spellcheck="true"># 列出属于某个特定 RC 的 pods 的名称</span><span class="token comment" spellcheck="true"># "jq" 命令对于 jsonpath 过于复杂的转换非常有用，可以在 https://stedolan.github.io/jq/ 找到它。</span>sel<span class="token operator">=</span>$<span class="token punctuation">{</span><span class="token punctuation">$(</span>kubectl get rc my-rc --output<span class="token operator">=</span>json <span class="token operator">|</span> jq -j <span class="token string">'.spec.selector | to_entries | .[] | "\(.key)=\(.value),"'</span><span class="token punctuation">)</span>%?<span class="token punctuation">}</span><span class="token keyword">echo</span> <span class="token variable"><span class="token variable">$(</span>kubectl get pods --selector<span class="token operator">=</span>$sel --output<span class="token operator">=</span>jsonpath<span class="token operator">=</span><span class="token punctuation">{</span>.items<span class="token punctuation">..</span>metadata.name<span class="token punctuation">}</span><span class="token variable">)</span></span><span class="token comment" spellcheck="true"># 显示所有 Pod 的标签(或任何其他支持标签的 Kubernetes 对象)</span><span class="token comment" spellcheck="true"># 也可以使用 "jq"</span><span class="token keyword">for</span> item <span class="token keyword">in</span> <span class="token variable"><span class="token variable">$(</span> kubectl get pod --output<span class="token operator">=</span>name<span class="token variable">)</span></span><span class="token punctuation">;</span> <span class="token keyword">do</span> <span class="token function">printf</span> <span class="token string">"Labels for %s\n"</span> <span class="token string">"<span class="token variable">$item</span>"</span> <span class="token operator">|</span> <span class="token function">grep</span> --color -E <span class="token string">'[^/]+$'</span> <span class="token operator">&amp;&amp;</span> kubectl get <span class="token string">"<span class="token variable">$item</span>"</span> --output<span class="token operator">=</span>json <span class="token operator">|</span> jq -r -S <span class="token string">'.metadata.labels | to_entries | .[] | " \(.key)=\(.value)"'</span> 2<span class="token operator">></span>/dev/null<span class="token punctuation">;</span> <span class="token function">printf</span> <span class="token string">"\n"</span><span class="token punctuation">;</span> <span class="token keyword">done</span><span class="token comment" spellcheck="true"># 或也可以使用此命令来获取与容器关联的所有标签</span>kubectl get pods --show-labels<span class="token comment" spellcheck="true"># 检查哪些节点处于 ready</span>JSONPATH<span class="token operator">=</span><span class="token string">'{range .items[*]}{@.metadata.name}:{range @.status.conditions[*]}{@.type}={@.status};{end}{end}'</span> \ <span class="token operator">&amp;&amp;</span> kubectl get nodes -o jsonpath<span class="token operator">=</span><span class="token string">"<span class="token variable">$JSONPATH</span>"</span> <span class="token operator">|</span> <span class="token function">grep</span> <span class="token string">"Ready=True"</span><span class="token comment" spellcheck="true"># 列出被一个 pod 使用的全部 secret</span>kubectl get pods -o json <span class="token operator">|</span> jq <span class="token string">'.items[].spec.containers[].env[]?.valueFrom.secretKeyRef.name'</span> <span class="token operator">|</span> <span class="token function">grep</span> -v null <span class="token operator">|</span> <span class="token function">sort</span> <span class="token operator">|</span> <span class="token function">uniq</span><span class="token comment" spellcheck="true"># 列出 events，按照创建时间排序</span>kubectl get events --sort-by<span class="token operator">=</span>.metadata.creationTimestamp<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="更新资源"><a href="#更新资源" class="headerlink" title="更新资源"></a>更新资源</h3><p>从版本 1.11 开始，<code>rolling-update</code> 已被弃用，使用 <code>rollout</code> 代替。</p><pre class="line-numbers language-bash"><code class="language-bash">kubectl <span class="token keyword">set</span> image deployment/frontend www<span class="token operator">=</span>image:v2               <span class="token comment" spellcheck="true"># 滚动更新 "frontend" deployment 的 "www" 容器镜像</span>kubectl rollout <span class="token function">history</span> deployment/frontend                      <span class="token comment" spellcheck="true"># 检查部署的历史记录，包括版本 </span>kubectl rollout undo deployment/frontend                         <span class="token comment" spellcheck="true"># 回滚到上次部署版本</span>kubectl rollout undo deployment/frontend --to-revision<span class="token operator">=</span>2         <span class="token comment" spellcheck="true"># 回滚到特定部署版本</span>kubectl rollout status -w deployment/frontend                    <span class="token comment" spellcheck="true"># Watch "frontend" deployment 的滚动升级状态直到完成</span><span class="token comment" spellcheck="true"># 从 1.11 版本开始弃用</span>kubectl rolling-update frontend-v1 -f frontend-v2.json           <span class="token comment" spellcheck="true"># (弃用) 滚动升级 frontend-v1 的 pods</span>kubectl rolling-update frontend-v1 frontend-v2 --image<span class="token operator">=</span>image:v2  <span class="token comment" spellcheck="true"># (弃用) 修改资源的名称并更新镜像</span>kubectl rolling-update frontend --image<span class="token operator">=</span>image:v2                 <span class="token comment" spellcheck="true"># (弃用) 更新 frontend 的 pods 的镜像</span>kubectl rolling-update frontend-v1 frontend-v2 --rollback        <span class="token comment" spellcheck="true"># (弃用) 终止已经进行中的 rollout</span><span class="token function">cat</span> pod.json <span class="token operator">|</span> kubectl replace -f -                              <span class="token comment" spellcheck="true"># 通过传入到标准输入的 JSON 来替换 pod</span><span class="token comment" spellcheck="true"># 强制进行替换，会删除然后再创建资源，会导致服务不可用。</span>kubectl replace --force -f ./pod.json<span class="token comment" spellcheck="true"># 为多副本的 nginx 创建服务，使用 80 端口提供服务，连接到容器的 8000 端口。</span>kubectl expose rc nginx --port<span class="token operator">=</span>80 --target-port<span class="token operator">=</span>8000<span class="token comment" spellcheck="true"># 更新单容器 pod 的镜像标签到 v4</span>kubectl get pod mypod -o yaml <span class="token operator">|</span> <span class="token function">sed</span> <span class="token string">'s/\(image: myimage\):.*$/\1:v4/'</span> <span class="token operator">|</span> kubectl replace -f -kubectl label pods my-pod new-label<span class="token operator">=</span>awesome                      <span class="token comment" spellcheck="true"># 添加标签</span>kubectl annotate pods my-pod icon-url<span class="token operator">=</span>http://goo.gl/XXBTWq       <span class="token comment" spellcheck="true"># 添加注解</span>kubectl autoscale deployment foo --min<span class="token operator">=</span>2 --max<span class="token operator">=</span>10                <span class="token comment" spellcheck="true"># 使 "foo" deployment 自动伸缩容</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="局部更新资源"><a href="#局部更新资源" class="headerlink" title="局部更新资源"></a>局部更新资源</h3><pre class="line-numbers language-bash"><code class="language-bash">kubectl patch node k8s-node-1 -p <span class="token string">'{"spec":{"unschedulable":true}}'</span> <span class="token comment" spellcheck="true"># 部分更新 node</span><span class="token comment" spellcheck="true">#更新容器的镜像；spec.containers[*].name 是必须的。因为它是一个合并 key。</span>kubectl patch pod valid-pod -p <span class="token string">'{"spec":{"containers":[{"name":"kubernetes-serve-hostname","image":"new image"}]}}'</span><span class="token comment" spellcheck="true"># 使用带位置数组的 json patch 更新容器的镜像</span>kubectl patch pod valid-pod --type<span class="token operator">=</span><span class="token string">'json'</span> -p<span class="token operator">=</span><span class="token string">'[{"op": "replace", "path": "/spec/containers/0/image", "value":"new image"}]'</span><span class="token comment" spellcheck="true"># 使用带位置数组的 json patch 禁用 deployment 的 livenessProbe</span>kubectl patch deployment valid-deployment  --type json   -p<span class="token operator">=</span><span class="token string">'[{"op": "remove", "path": "/spec/template/spec/containers/0/livenessProbe"}]'</span><span class="token comment" spellcheck="true"># 在带位置数组中添加元素 </span>kubectl patch sa default --type<span class="token operator">=</span><span class="token string">'json'</span> -p<span class="token operator">=</span><span class="token string">'[{"op": "add", "path": "/secrets/1", "value": {"name": "whatever" } }]'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="编辑资源"><a href="#编辑资源" class="headerlink" title="编辑资源"></a>编辑资源</h3><p>在编辑器中编辑任何 API 资源</p><pre class="line-numbers language-bash"><code class="language-bash">kubectl edit svc/docker-registry                      <span class="token comment" spellcheck="true"># 编辑名为 docker-registry 的 service</span>KUBE_EDITOR<span class="token operator">=</span><span class="token string">"nano"</span> kubectl edit svc/docker-registry   <span class="token comment" spellcheck="true"># 使用其他编辑器</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="对资源进行伸缩"><a href="#对资源进行伸缩" class="headerlink" title="对资源进行伸缩"></a>对资源进行伸缩</h3><pre class="line-numbers language-bash"><code class="language-bash">kubectl scale --replicas<span class="token operator">=</span>3 rs/foo                                 <span class="token comment" spellcheck="true"># 将名为 'foo' 的副本集伸缩到 3 副本</span>kubectl scale --replicas<span class="token operator">=</span>3 -f foo.yaml                            <span class="token comment" spellcheck="true"># 将在 "foo.yaml" 中的特定资源伸缩到 3 个副本</span>kubectl scale --current-replicas<span class="token operator">=</span>2 --replicas<span class="token operator">=</span>3 deployment/mysql  <span class="token comment" spellcheck="true"># 如果名为 mysql 的 deployment 的副本当前是 2，那么将它伸缩到 3</span>kubectl scale --replicas<span class="token operator">=</span>5 rc/foo rc/bar rc/baz                   <span class="token comment" spellcheck="true"># 伸缩多个 replication controllers</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="删除资源"><a href="#删除资源" class="headerlink" title="删除资源"></a>删除资源</h3><pre class="line-numbers language-bash"><code class="language-bash">kubectl delete -f ./pod.json                                              <span class="token comment" spellcheck="true"># 删除在 pod.json 中指定的类型和名称的 pod</span>kubectl delete pod,service baz foo                                        <span class="token comment" spellcheck="true"># 删除名称为 "baz" 和 "foo" 的 pod 和 service</span>kubectl delete pods,services -l name<span class="token operator">=</span>myLabel                              <span class="token comment" spellcheck="true"># 删除包含 name=myLabel 标签的 pods 和 services</span>kubectl delete pods,services -l name<span class="token operator">=</span>myLabel --include-uninitialized      <span class="token comment" spellcheck="true"># 删除包含 label name=myLabel 标签的 pods 和 services，包括未初始化的</span>kubectl -n my-ns delete po,svc --all                                      <span class="token comment" spellcheck="true"># 删除在 my-ns 命名空间中全部的 pods 和 services ，包括未初始化的</span><span class="token comment" spellcheck="true"># 删除所有与 pattern1 或 pattern2 匹配的 pod</span>kubectl get pods  -n mynamespace --no-headers<span class="token operator">=</span>true <span class="token operator">|</span> <span class="token function">awk</span> <span class="token string">'/pattern1|pattern2/{print <span class="token variable">$1</span>}'</span> <span class="token operator">|</span> <span class="token function">xargs</span>  kubectl delete -n mynamespace pod<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="与运行中的-Pods-进行交互"><a href="#与运行中的-Pods-进行交互" class="headerlink" title="与运行中的 Pods 进行交互"></a>与运行中的 Pods 进行交互</h3><pre class="line-numbers language-bash"><code class="language-bash">kubectl logs my-pod                                 <span class="token comment" spellcheck="true"># 获取 pod 日志(标准输出)</span>kubectl logs -l name<span class="token operator">=</span>myLabel                        <span class="token comment" spellcheck="true"># 获取 pod label name=myLabel 日志(标准输出)</span>kubectl logs my-pod --previous                      <span class="token comment" spellcheck="true"># 获取上个容器实例的 pod 日志(标准输出)</span>kubectl logs my-pod -c my-container                 <span class="token comment" spellcheck="true"># 获取 pod 的容器日志 (标准输出, 多容器的场景)</span>kubectl logs -l name<span class="token operator">=</span>myLabel -c my-container        <span class="token comment" spellcheck="true"># 获取 label name=myLabel pod 的容器日志 (标准输出, 多容器的场景)</span>kubectl logs my-pod -c my-container --previous      <span class="token comment" spellcheck="true"># 获取 pod 的上个容器实例日志 (标准输出, 多容器的场景)</span>kubectl logs -f my-pod                              <span class="token comment" spellcheck="true"># 流式输出 pod 的日志 (标准输出)</span>kubectl logs -f my-pod -c my-container              <span class="token comment" spellcheck="true"># 流式输出 pod 容器的日志 (标准输出, 多容器的场景)</span>kubectl logs -f -l name<span class="token operator">=</span>myLabel --all-containers    <span class="token comment" spellcheck="true"># 流式输出 label name=myLabel pod 的日志 (标准输出)</span>kubectl run -i --tty busybox --image<span class="token operator">=</span>busybox -- sh  <span class="token comment" spellcheck="true"># 以交互式 shell 运行 pod</span>kubectl attach my-pod -i                            <span class="token comment" spellcheck="true"># 进入到一个运行中的容器中</span>kubectl port-forward my-pod 5000:6000               <span class="token comment" spellcheck="true"># 在本地计算机上侦听端口 5000 并转发到 my-pod 上的端口 6000</span>kubectl <span class="token function">exec</span> my-pod -- <span class="token function">ls</span> /                         <span class="token comment" spellcheck="true"># 在已有的 pod 中运行命令(单容器的场景)</span>kubectl <span class="token function">exec</span> my-pod -c my-container -- <span class="token function">ls</span> /         <span class="token comment" spellcheck="true"># 在已有的 pod 中运行命令(多容器的场景)</span>kubectl <span class="token function">top</span> pod POD_NAME --containers               <span class="token comment" spellcheck="true"># 显示给定 pod 和容器的监控数据</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="与节点和集群进行交互"><a href="#与节点和集群进行交互" class="headerlink" title="与节点和集群进行交互"></a>与节点和集群进行交互</h3><pre class="line-numbers language-bash"><code class="language-bash">kubectl cordon my-node                                                <span class="token comment" spellcheck="true"># 设置 my-node 节点为不可调度</span>kubectl drain my-node                                                 <span class="token comment" spellcheck="true"># 对 my-node 节点进行驱逐操作，为节点维护做准备</span>kubectl uncordon my-node                                              <span class="token comment" spellcheck="true"># 设置 my-node 节点为可以调度</span>kubectl <span class="token function">top</span> node my-node                                              <span class="token comment" spellcheck="true"># 显示给定 node 的指标</span>kubectl cluster-info                                                  <span class="token comment" spellcheck="true"># 显示 master 和 services 的地址</span>kubectl cluster-info dump                                             <span class="token comment" spellcheck="true"># 将当前集群状态输出到标准输出</span>kubectl cluster-info dump --output-directory<span class="token operator">=</span>/path/to/cluster-state   <span class="token comment" spellcheck="true"># 将当前集群状态输出到 /path/to/cluster-state</span><span class="token comment" spellcheck="true"># 如果已存在具有该键和效果的污点，则其值将按指定替换</span>kubectl taint nodes foo dedicated<span class="token operator">=</span>special-user:NoSchedule<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="七、适用于-Docker-用户的-kubectl"><a href="#七、适用于-Docker-用户的-kubectl" class="headerlink" title="七、适用于 Docker 用户的 kubectl"></a>七、适用于 Docker 用户的 kubectl</h2><p>您可以使用 Kubernetes 命令行工具 kubectl 与 API 服务器进行交互。如果您熟悉 Docker 命令行工具，则使用 kubectl 非常简单。但是，docker 命令和 kubectl 命令之间有一些区别。以下显示了 docker 子命令，并描述了等效的 kubectl 命令。</p><h3 id="运行-nginx-部署并将其暴露"><a href="#运行-nginx-部署并将其暴露" class="headerlink" title="运行 nginx 部署并将其暴露"></a>运行 nginx 部署并将其暴露</h3><p>使用 docker 命令：</p><pre class="line-numbers language-shell"><code class="language-shell">docker run -d --restart=always -e DOMAIN=cluster --name nginx-app -p 80:80 nginx<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>使用 kubectl 命令：</p><pre class="line-numbers language-shell"><code class="language-shell"># 启动运行 nginx 的 Podkubectl run --image=nginx nginx-app --port=80 --env="DOMAIN=cluster"# 通过服务公开端口kubectl expose deployment nginx-app --port=80 --name=nginx-http<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="列出哪些正在运行"><a href="#列出哪些正在运行" class="headerlink" title="列出哪些正在运行"></a>列出哪些正在运行</h3><p>使用 docker 命令：</p><pre class="line-numbers language-shell"><code class="language-shell">docker ps -a<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>使用 kubectl 命令：</p><pre class="line-numbers language-shell"><code class="language-shell">kubectl get po  # pod/pods 均可<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="连接到已经运行在容器中的进程"><a href="#连接到已经运行在容器中的进程" class="headerlink" title="连接到已经运行在容器中的进程"></a>连接到已经运行在容器中的进程</h3><p>使用 docker 命令：</p><pre class="line-numbers language-shell"><code class="language-shell">$ docker psCONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                NAMES55c103fa1296        nginx               "nginx -g 'daemon of…"   5 minutes ago       Up 5 minutes        0.0.0.0:80->80/tcp   nginx-app$ docker attach 55c103fa1296...<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>kubectl:</p><pre class="line-numbers language-shell"><code class="language-shell">$ kubectl get podsNAME              READY     STATUS    RESTARTS   AGEnginx-app-5jyvm   1/1       Running   0          10m$ kubectl attach -it nginx-app-5jyvm...<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>要从容器中分离，可以输入 Ctrl + P，然后按 Ctrl + Q。</p><h3 id="在容器中执行命令"><a href="#在容器中执行命令" class="headerlink" title="在容器中执行命令"></a>在容器中执行命令</h3><p>使用 docker 命令：</p><pre class="line-numbers language-shell"><code class="language-shell">docker exec -ti 55c103fa1296 /bin/sh<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>kubectl:</p><pre class="line-numbers language-shell"><code class="language-shell">kubectl exec -ti nginx-app-5jyvm -- /bin/sh<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="查看运行中进程的日志"><a href="#查看运行中进程的日志" class="headerlink" title="查看运行中进程的日志"></a>查看运行中进程的日志</h3><p>使用 docker 命令：</p><pre class="line-numbers language-shell"><code class="language-shell">docker logs -f nginx<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>使用 kubectl 命令：</p><pre class="line-numbers language-shell"><code class="language-shell">kubectl logs -f nginx-app-zibvs<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在 docker 中，进程的每个调用的输出都是被连接起来的，但是对于 kubernetes，每个调用都是分开的。要查看以前在 kubernetes 中执行的输出，请执行以下操作：</p><pre class="line-numbers language-shell"><code class="language-shell">kubectl logs --previous nginx-app-zibvs<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="停止和删除运行中的进程"><a href="#停止和删除运行中的进程" class="headerlink" title="停止和删除运行中的进程"></a>停止和删除运行中的进程</h3><p>使用 docker 命令：</p><pre class="line-numbers language-shell"><code class="language-shell">$ docker psCONTAINER ID        IMAGE               COMMAND                CREATED             STATUS              PORTS                         NAMESa9ec34d98787        nginx               "nginx -g 'daemon of"  22 hours ago        Up 22 hours         0.0.0.0:80->80/tcp, 443/tcp   nginx-app$ docker stop a9ec34d98787a9ec34d98787$ docker rm a9ec34d98787a9ec34d98787<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用 kubectl 命令：</p><pre class="line-numbers language-shell"><code class="language-shell">$ kubectl get deployment nginx-appNAME        DESIRED   CURRENT   UP-TO-DATE   AVAILABLE   AGEnginx-app   1         1         1            1           2m$ kubectl get po -l run=nginx-appNAME                         READY     STATUS    RESTARTS   AGEnginx-app-2883164633-aklf7   1/1       Running   0          2m$ kubectl delete deployment nginx-appdeployment "nginx-app" deleted$ kubectl get po -l run=nginx-app# Return nothing<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><strong>注意：</strong> 使用 kubectl 命令，不直接删除 Pod。要删除拥有该 pod 的 Deployment。如果直接删除 pod，Deployment 将会重新创建该 pod。</p></blockquote><h3 id="查看客户端和服务端的版本"><a href="#查看客户端和服务端的版本" class="headerlink" title="查看客户端和服务端的版本"></a>查看客户端和服务端的版本</h3><p>使用 docker 命令：</p><pre class="line-numbers language-shell"><code class="language-shell">docker version<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>使用 kubectl 命令：</p><pre class="line-numbers language-shell"><code class="language-shell">kubectl version<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="获取有关环境和配置的各种信息"><a href="#获取有关环境和配置的各种信息" class="headerlink" title="获取有关环境和配置的各种信息"></a>获取有关环境和配置的各种信息</h3><p>使用 docker 命令：</p><pre class="line-numbers language-shell"><code class="language-shell">docker info<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>使用 kubectl 命令：</p><pre class="line-numbers language-shell"><code class="language-shell">kubectl cluster-info<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="八、格式化输出"><a href="#八、格式化输出" class="headerlink" title="八、格式化输出"></a>八、格式化输出</h2><p>要以特定格式将详细信息输出到终端窗口，可以将 <code>-o</code> 或 <code>--output</code> 参数添加到支持的 <code>kubectl</code> 命令。</p><table><thead><tr><th align="left">输出格式</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>-o=custom-columns=&lt;spec&gt;</code></td><td align="left">使用逗号分隔的自定义列列表打印表格</td></tr><tr><td align="left"><code>-o=custom-columns-file=&lt;filename&gt;</code></td><td align="left">使用 <code>&lt;filename&gt;</code> 文件中的自定义列模板打印表格</td></tr><tr><td align="left"><code>-o=json</code></td><td align="left">输出 JSON 格式的 API 对象</td></tr><tr><td align="left"><code>-o=jsonpath=&lt;template&gt;</code></td><td align="left">打印 <code>jsonpath</code>表达式中定义的字段</td></tr><tr><td align="left"><code>-o=jsonpath-file=&lt;filename&gt;</code></td><td align="left">在 <code>&lt;filename&gt;</code> 文件中打印由 <code>jsonpath</code> 表达式定义的字段。</td></tr><tr><td align="left"><code>-o=name</code></td><td align="left">仅打印资源名称而不打印任何其他内容</td></tr><tr><td align="left"><code>-o=wide</code></td><td align="left">使用任何其他信息以纯文本格式输出，对于 pod 来说，包含了节点名称</td></tr><tr><td align="left"><code>-o=yaml</code></td><td align="left">输出 YAML 格式的 API 对象</td></tr></tbody></table><h2 id="九、Kubectl-日志输出控制"><a href="#九、Kubectl-日志输出控制" class="headerlink" title="九、Kubectl 日志输出控制"></a>九、Kubectl 日志输出控制</h2><p>Kubectl 日志输出详细程度是通过 <code>-v</code> 或者 <code>--v</code> 来控制的，参数后跟了一个数字表示日志的级别。</p><table><thead><tr><th align="left">详细程度</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>--v=0</code></td><td align="left">通常对此有用，<em>始终</em>对运维人员可见。</td></tr><tr><td align="left"><code>--v=1</code></td><td align="left">如果您不想要详细程度，则为合理的默认日志级别。</td></tr><tr><td align="left"><code>--v=2</code></td><td align="left">有关服务的有用稳定状态信息以及可能与系统中的重大更改相关的重要日志消息。这是大多数系统的建议默认日志级别。</td></tr><tr><td align="left"><code>--v=3</code></td><td align="left">有关更改的扩展信息。</td></tr><tr><td align="left"><code>--v=4</code></td><td align="left">Debug 级别。</td></tr><tr><td align="left"><code>--v=6</code></td><td align="left">显示请求的资源。</td></tr><tr><td align="left"><code>--v=7</code></td><td align="left">显示 HTTP 请求头。</td></tr><tr><td align="left"><code>--v=8</code></td><td align="left">显示 HTTP 请求内容。</td></tr><tr><td align="left"><code>--v=9</code></td><td align="left">显示 HTTP 请求内容而不截断内容。</td></tr></tbody></table><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>官方文档：<a href="https://kubernetes.io/zh/docs/reference/kubectl/overview/" target="_blank" rel="noopener">https://kubernetes.io/zh/docs/reference/kubectl/overview/</a></li></ul><h2 id="相关文章"><a href="#相关文章" class="headerlink" title="相关文章"></a>相关文章</h2><ul><li>上一篇：<a href="https://www.lixl.cn/books/Docker/appendix4-docker-compose-file/">Docker必知必会系列（附录4）：Docker-compose 配置文件编写</a></li><li>下一篇：没有了</li></ul><h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>至此，本系列文章已经阅读完成。</p><p>获取最新内容，请访问我的个人博客：<a href="https://www.lixl.cn">悟尘记</a>。</p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DevOps </tag>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>附录4、Docker-compose 配置文件编写指南</title>
      <link href="/2020/042615936.html"/>
      <url>/2020/042615936.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文是《<a href="https://www.lixl.cn/books/Docker/1-Overview/">Docker必知必会系列</a>》第十二篇，原文发布于个人博客：<a href="https://www.lixl.cn/">悟尘记</a>。</p><p>上一篇：<a href="https://www.lixl.cn/books/Docker/appendix3-docker-compose-command/">Docker必知必会系列（附录3）：Docker-compose 命令使用指南</a></p></blockquote><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Compose 配置文件采用 YAML 格式，用于定义 <a href="https://docs.docker.com/compose/compose-file/#service-configuration-reference" target="_blank" rel="noopener">services</a>（服务）, <a href="https://docs.docker.com/compose/compose-file/#network-configuration-reference" target="_blank" rel="noopener">networks</a>（网络）和 <a href="https://docs.docker.com/compose/compose-file/#volume-configuration-reference" target="_blank" rel="noopener">volumes</a>（卷）。</p><p>文件的默认路径为<code>./docker-compose.yml</code>。有多种版本格式——1、2、2.x 和3.x。 有关每个版本与Docker的兼容性、包含哪些内容以及如何升级的最新信息，请参阅官方文档： <a href="https://docs.docker.com/compose/compose-file/compose-versioning/" target="_blank" rel="noopener">关于版本和升级</a>。</p><p>服务定义包含应用于该服务启动的每个容器的配置，就像将命令行参数传递给 <code>docker run</code>一样。同样，网络和卷定义类似于 <code>docker network create</code>和<code>docker volume create</code>。</p><p>与 <code>docker run</code> 一样，Dockerfile 中指定的选项，例如 <code>CMD</code>、 <code>EXPOSE</code>、 <code>VOLUME</code>、 <code>ENV</code>，在缺省情况下都是遵守的——不需要再次以 <code>docker-compose</code> 方式指定它们。</p><p>您可以使用类似 Bash 的<code>${VARIABLE}</code>语法在配置值中使用环境变量 - 有关完整详细信息，请参见<a href="https://docs.docker.com/compose/compose-file/#variable-substitution" target="_blank" rel="noopener">变量替换</a>。</p><h2 id="文件结构和示例"><a href="#文件结构和示例" class="headerlink" title="文件结构和示例"></a>文件结构和示例</h2><p>这是一个投票应用程序的 Compose 文件示例：</p><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token key atrule">version</span><span class="token punctuation">:</span> <span class="token string">"3.8"</span><span class="token key atrule">services</span><span class="token punctuation">:</span>  <span class="token key atrule">redis</span><span class="token punctuation">:</span>    <span class="token key atrule">image</span><span class="token punctuation">:</span> redis<span class="token punctuation">:</span>alpine    <span class="token key atrule">ports</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> <span class="token string">"6379"</span>    <span class="token key atrule">networks</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> frontend    <span class="token key atrule">deploy</span><span class="token punctuation">:</span>      <span class="token key atrule">replicas</span><span class="token punctuation">:</span> <span class="token number">2</span>      <span class="token key atrule">update_config</span><span class="token punctuation">:</span>        <span class="token key atrule">parallelism</span><span class="token punctuation">:</span> <span class="token number">2</span>        <span class="token key atrule">delay</span><span class="token punctuation">:</span> 10s      <span class="token key atrule">restart_policy</span><span class="token punctuation">:</span>        <span class="token key atrule">condition</span><span class="token punctuation">:</span> on<span class="token punctuation">-</span>failure  <span class="token key atrule">db</span><span class="token punctuation">:</span>    <span class="token key atrule">image</span><span class="token punctuation">:</span> postgres<span class="token punctuation">:</span><span class="token number">9.4</span>    <span class="token key atrule">volumes</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> db<span class="token punctuation">-</span>data<span class="token punctuation">:</span>/var/lib/postgresql/data    <span class="token key atrule">networks</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> backend    <span class="token key atrule">deploy</span><span class="token punctuation">:</span>      <span class="token key atrule">placement</span><span class="token punctuation">:</span>        <span class="token key atrule">constraints</span><span class="token punctuation">:</span>          <span class="token punctuation">-</span> <span class="token string">"node.role==manager"</span>  <span class="token key atrule">vote</span><span class="token punctuation">:</span>    <span class="token key atrule">image</span><span class="token punctuation">:</span> dockersamples/examplevotingapp_vote<span class="token punctuation">:</span>before    <span class="token key atrule">ports</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> <span class="token string">"5000:80"</span>    <span class="token key atrule">networks</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> frontend    <span class="token key atrule">depends_on</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> redis    <span class="token key atrule">deploy</span><span class="token punctuation">:</span>      <span class="token key atrule">replicas</span><span class="token punctuation">:</span> <span class="token number">2</span>      <span class="token key atrule">update_config</span><span class="token punctuation">:</span>        <span class="token key atrule">parallelism</span><span class="token punctuation">:</span> <span class="token number">2</span>      <span class="token key atrule">restart_policy</span><span class="token punctuation">:</span>        <span class="token key atrule">condition</span><span class="token punctuation">:</span> on<span class="token punctuation">-</span>failure  <span class="token key atrule">result</span><span class="token punctuation">:</span>    <span class="token key atrule">image</span><span class="token punctuation">:</span> dockersamples/examplevotingapp_result<span class="token punctuation">:</span>before    <span class="token key atrule">ports</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> <span class="token string">"5001:80"</span>    <span class="token key atrule">networks</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> backend    <span class="token key atrule">depends_on</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> db    <span class="token key atrule">deploy</span><span class="token punctuation">:</span>      <span class="token key atrule">replicas</span><span class="token punctuation">:</span> <span class="token number">1</span>      <span class="token key atrule">update_config</span><span class="token punctuation">:</span>        <span class="token key atrule">parallelism</span><span class="token punctuation">:</span> <span class="token number">2</span>        <span class="token key atrule">delay</span><span class="token punctuation">:</span> 10s      <span class="token key atrule">restart_policy</span><span class="token punctuation">:</span>        <span class="token key atrule">condition</span><span class="token punctuation">:</span> on<span class="token punctuation">-</span>failure  <span class="token key atrule">worker</span><span class="token punctuation">:</span>    <span class="token key atrule">image</span><span class="token punctuation">:</span> dockersamples/examplevotingapp_worker    <span class="token key atrule">networks</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> frontend      <span class="token punctuation">-</span> backend    <span class="token key atrule">deploy</span><span class="token punctuation">:</span>      <span class="token key atrule">mode</span><span class="token punctuation">:</span> replicated      <span class="token key atrule">replicas</span><span class="token punctuation">:</span> <span class="token number">1</span>      <span class="token key atrule">labels</span><span class="token punctuation">:</span> <span class="token punctuation">[</span>APP=VOTING<span class="token punctuation">]</span>      <span class="token key atrule">restart_policy</span><span class="token punctuation">:</span>        <span class="token key atrule">condition</span><span class="token punctuation">:</span> on<span class="token punctuation">-</span>failure        <span class="token key atrule">delay</span><span class="token punctuation">:</span> 10s        <span class="token key atrule">max_attempts</span><span class="token punctuation">:</span> <span class="token number">3</span>        <span class="token key atrule">window</span><span class="token punctuation">:</span> 120s      <span class="token key atrule">placement</span><span class="token punctuation">:</span>        <span class="token key atrule">constraints</span><span class="token punctuation">:</span>          <span class="token punctuation">-</span> <span class="token string">"node.role==manager"</span>  <span class="token key atrule">visualizer</span><span class="token punctuation">:</span>    <span class="token key atrule">image</span><span class="token punctuation">:</span> dockersamples/visualizer<span class="token punctuation">:</span>stable    <span class="token key atrule">ports</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> <span class="token string">"8080:8080"</span>    <span class="token key atrule">stop_grace_period</span><span class="token punctuation">:</span> 1m30s    <span class="token key atrule">volumes</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> <span class="token string">"/var/run/docker.sock:/var/run/docker.sock"</span>    <span class="token key atrule">deploy</span><span class="token punctuation">:</span>      <span class="token key atrule">placement</span><span class="token punctuation">:</span>        <span class="token key atrule">constraints</span><span class="token punctuation">:</span>          <span class="token punctuation">-</span> <span class="token string">"node.role==manager"</span><span class="token key atrule">networks</span><span class="token punctuation">:</span>  <span class="token key atrule">frontend</span><span class="token punctuation">:</span>  <span class="token key atrule">backend</span><span class="token punctuation">:</span><span class="token key atrule">volumes</span><span class="token punctuation">:</span>  db<span class="token punctuation">-</span>data<span class="token punctuation">:</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="配置指令"><a href="#配置指令" class="headerlink" title="配置指令"></a>配置指令</h2><h3 id="build"><a href="#build" class="headerlink" title="build"></a>build</h3><p>指定 <code>Dockerfile</code> 所在文件夹的路径,<code>Compose</code> 将会利用它自动构建镜像。如：</p><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token key atrule">version</span><span class="token punctuation">:</span> <span class="token string">'3.8'</span><span class="token key atrule">services</span><span class="token punctuation">:</span>  <span class="token key atrule">webapp</span><span class="token punctuation">:</span>    <span class="token key atrule">build</span><span class="token punctuation">:</span> ./dir<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="context、dockerfile和args"><a href="#context、dockerfile和args" class="headerlink" title="context、dockerfile和args"></a>context、dockerfile和args</h4><p>可以使用 <code>context</code> 指定文件夹路径（可以是包含 Dockerfile 的目录路径，也可以是 git 存储库的 url），使用 <code>dockerfile</code> 指定 <code>Dockerfile</code> 文件名，使用 <code>arg</code> 为 <code>Dockerfile</code>中的变量赋值。如：</p><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token key atrule">version</span><span class="token punctuation">:</span> <span class="token string">'3.8'</span><span class="token key atrule">services</span><span class="token punctuation">:</span>  <span class="token key atrule">webapp</span><span class="token punctuation">:</span>    <span class="token key atrule">build</span><span class="token punctuation">:</span>      <span class="token key atrule">context</span><span class="token punctuation">:</span> ./dir      <span class="token key atrule">dockerfile</span><span class="token punctuation">:</span> Dockerfile<span class="token punctuation">-</span>alternate      <span class="token key atrule">args</span><span class="token punctuation">:</span>        <span class="token key atrule">buildno</span><span class="token punctuation">:</span> <span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果在 <code>build</code> 同时指定了 <code>image</code>，那么 Compose 会使用在 <code>image</code> 中指定的名字和标签来命名最终构建的镜像。如:</p><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token key atrule">build</span><span class="token punctuation">:</span> ./dir<span class="token key atrule">image</span><span class="token punctuation">:</span> webapp<span class="token punctuation">:</span>tag<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>这将从 <code>./dir</code>构建，生成名为 <code>webapp</code>，标签为：<code>tag</code> 的镜像。</p><h4 id="cache-from"><a href="#cache-from" class="headerlink" title="cache_from"></a>cache_from</h4><p>可以使用 <code>cache_from</code> 指定构建镜像时使用的缓存：</p><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token key atrule">build</span><span class="token punctuation">:</span>  <span class="token key atrule">context</span><span class="token punctuation">:</span> .  <span class="token key atrule">cache_from</span><span class="token punctuation">:</span>    <span class="token punctuation">-</span> alpine<span class="token punctuation">:</span>latest    <span class="token punctuation">-</span> corp/web_app<span class="token punctuation">:</span><span class="token number">3.14</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="labels"><a href="#labels" class="headerlink" title="labels"></a>labels</h4><p>通过标签向生成的镜像添加元数据：</p><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token key atrule">build</span><span class="token punctuation">:</span>  <span class="token key atrule">context</span><span class="token punctuation">:</span> .  <span class="token key atrule">labels</span><span class="token punctuation">:</span>    <span class="token key atrule">com.example.description</span><span class="token punctuation">:</span> <span class="token string">"Accounting webapp"</span>    <span class="token key atrule">com.example.department</span><span class="token punctuation">:</span> <span class="token string">"Finance"</span>    <span class="token key atrule">com.example.label-with-empty-value</span><span class="token punctuation">:</span> <span class="token string">""</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token key atrule">build</span><span class="token punctuation">:</span>  <span class="token key atrule">context</span><span class="token punctuation">:</span> .  <span class="token key atrule">labels</span><span class="token punctuation">:</span>    <span class="token punctuation">-</span> <span class="token string">"com.example.description=Accounting webapp"</span>    <span class="token punctuation">-</span> <span class="token string">"com.example.department=Finance"</span>    <span class="token punctuation">-</span> <span class="token string">"com.example.label-with-empty-value"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="network"><a href="#network" class="headerlink" title="network"></a>network</h4><p>设置构建期间 <code>run</code> 指令要链接的网络：</p><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token key atrule">build</span><span class="token punctuation">:</span>  <span class="token key atrule">context</span><span class="token punctuation">:</span> .  <span class="token key atrule">network</span><span class="token punctuation">:</span> host   <span class="token comment" spellcheck="true"># 可以设置为 none 禁用网络</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="sim-size"><a href="#sim-size" class="headerlink" title="sim_size"></a>sim_size</h4><p>设置所构建容器的<code>/dev/shm</code>分区大小：</p><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token key atrule">build</span><span class="token punctuation">:</span>  <span class="token key atrule">context</span><span class="token punctuation">:</span> .  <span class="token key atrule">shm_size</span><span class="token punctuation">:</span> <span class="token string">'2gb'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="target"><a href="#target" class="headerlink" title="target"></a>target</h4><p>按照在 <code>Dockerfile</code> 中定义的方式构建指定的阶段。 有关详细信息，请参阅 <a href="https://docs.docker.com/develop/develop-images/multistage-build/" target="_blank" rel="noopener">多阶段构建</a> 文档。</p><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token key atrule">build</span><span class="token punctuation">:</span>  <span class="token key atrule">context</span><span class="token punctuation">:</span> .  <span class="token key atrule">target</span><span class="token punctuation">:</span> prod<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="cap-add-cap-drop"><a href="#cap-add-cap-drop" class="headerlink" title="cap_add, cap_drop"></a>cap_add, cap_drop</h3><p>添加或删除容器的内核能力：</p><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token key atrule">cap_add</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> ALL  <span class="token comment" spellcheck="true"># 让容器拥有所有能力</span><span class="token key atrule">cap_drop</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> NET_ADMIN  <span class="token comment" spellcheck="true"># 移除 NET_ADMIN 功能</span>  <span class="token punctuation">-</span> SYS_ADMIN  <span class="token comment" spellcheck="true"># 移除 SYS_ADMIN 功能</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="cgroup-parent"><a href="#cgroup-parent" class="headerlink" title="cgroup_parent"></a>cgroup_parent</h3><p>指定父 <code>cgroup</code> 组，意味着将继承该组的资源限制，如：<code>cgroup_parent: m-executor-abcd</code></p><h3 id="command"><a href="#command" class="headerlink" title="command"></a>command</h3><p>覆盖容器启动后默认执行的命令。如：<code>command: echo &quot;hello world&quot;</code></p><h3 id="configs"><a href="#configs" class="headerlink" title="configs"></a>configs</h3><p>使用<code>configs</code> 按服务授予对配置的访问权限。详细内容请查看 <a href="https://docs.docker.com/compose/compose-file/#configs" target="_blank" rel="noopener">官方文档</a>。</p><h3 id="container-name"><a href="#container-name" class="headerlink" title="container_name"></a>container_name</h3><p>指定容器名称。默认将会使用 <code>项目名称_服务名称_序号</code> 这样的格式。</p><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token key atrule">container_name</span><span class="token punctuation">:</span> lixl<span class="token punctuation">-</span>web<span class="token punctuation">-</span>container<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>注意: 指定容器名称后，该服务将无法进行扩展（scale），因为 Docker 不允许多个容器具有相同的名称。</p></blockquote><h3 id="depends-on"><a href="#depends-on" class="headerlink" title="depends_on"></a>depends_on</h3><p>指定服务之间的依赖关系，以便按顺序启动服务。以下例子中会先启动 <code>redis</code> <code>db</code> 再启动 <code>web</code></p><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token key atrule">version</span><span class="token punctuation">:</span> <span class="token string">'3.8'</span><span class="token key atrule">services</span><span class="token punctuation">:</span>  <span class="token key atrule">web</span><span class="token punctuation">:</span>    <span class="token key atrule">build</span><span class="token punctuation">:</span> .    <span class="token key atrule">depends_on</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> db      <span class="token punctuation">-</span> redis  <span class="token key atrule">redis</span><span class="token punctuation">:</span>    <span class="token key atrule">image</span><span class="token punctuation">:</span> redis  <span class="token key atrule">db</span><span class="token punctuation">:</span>    <span class="token key atrule">image</span><span class="token punctuation">:</span> postgres<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>注意：<code>web</code> 服务不会等待 <code>redis</code> <code>db</code> 「完全启动」之后才启动。如果需要等待服务准备就绪，请参阅<a href="https://docs.docker.com/compose/startup-order/" target="_blank" rel="noopener">控制启动顺序</a> 获取有关此问题的更多信息以及解决该问题的策略。</p></blockquote><h3 id="deploy"><a href="#deploy" class="headerlink" title="deploy"></a>deploy</h3><p>仅用于 <code>Swarm mode</code>，详细内容请查看 <a href="https://docs.docker.com/compose/compose-file/#deploy" target="_blank" rel="noopener">官方文档</a>。</p><h3 id="devices"><a href="#devices" class="headerlink" title="devices"></a>devices</h3><p>指定设备映射关系。使用与 docker 客户端 <code>--device</code> 相同的选项格式：</p><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token key atrule">devices</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token string">"/dev/ttyUSB0:/dev/ttyUSB0"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="dns"><a href="#dns" class="headerlink" title="dns"></a>dns</h3><p>自定义 <code>DNS</code> 服务器，可以是单个值或列表。</p><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token key atrule">dns</span><span class="token punctuation">:</span> 8.8.8.8<span class="token key atrule">dns</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> 8.8.8.8  <span class="token punctuation">-</span> 114.114.114.114<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="dns-search"><a href="#dns-search" class="headerlink" title="dns_search"></a>dns_search</h3><p>配置 <code>DNS</code> 搜索域，可以是单个值或列表。</p><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token key atrule">dns_search</span><span class="token punctuation">:</span> example.com<span class="token key atrule">dns_search</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> dc1.example.com  <span class="token punctuation">-</span> dc2.example.com<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="entrypoint"><a href="#entrypoint" class="headerlink" title="entrypoint"></a>entrypoint</h3><p>重写默认入口点，如：<code>entrypoint: [&quot;php&quot;, &quot;-d&quot;, &quot;memory_limit=-1&quot;, &quot;vendor/bin/phpunit&quot;]</code></p><h3 id="env-file"><a href="#env-file" class="headerlink" title="env_file"></a>env_file</h3><p>从文件中添加环境变量。可以是单个值或列表。</p><p>如果通过 <code>docker-compose -f FILE</code> 方式来指定了 Compose 文件，则 <code>env_file</code> 中变量的路径相对于文件所在目录。</p><p>在 <code>environment</code> 声明的变量，会覆盖这些值。即使这些值为空或未定义。</p><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token key atrule">env_file</span><span class="token punctuation">:</span> .env<span class="token key atrule">env_file</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> ./common.env  <span class="token punctuation">-</span> ./apps/web.env  <span class="token punctuation">-</span> /opt/secrets.env<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>env文件中每一行必须符合 <code>VAL=VAL</code> 格式，以 <code>#</code> 开头的行被视为注释，并被忽略。空行也会被忽略。</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 设置环境</span>PRCK_ENV<span class="token operator">=</span>development<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="environment"><a href="#environment" class="headerlink" title="environment"></a>environment</h3><p>设置环境变量。你可以使用数组或字典两种格式。任何布尔值(True、 False、 yes、 no)都需要用引号括起来，以确保 YML 解析器不会将它们转换为 True 或 False。</p><p>只有名称的变量会自动解析为 Compose 运行主机上对应变量的值，可以用来防止泄露不必要的数据。</p><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token key atrule">environment</span><span class="token punctuation">:</span>  <span class="token key atrule">RACK_ENV</span><span class="token punctuation">:</span> development  <span class="token key atrule">SESSION_SECRET</span><span class="token punctuation">:</span><span class="token key atrule">environment</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> RACK_ENV=development  <span class="token punctuation">-</span> SESSION_SECRET<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="expose"><a href="#expose" class="headerlink" title="expose"></a>expose</h3><p>在不将端口发布到主机的情况下公开端口——它们只能被链接的服务访问。 只能指定内部端口。</p><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token key atrule">expose</span><span class="token punctuation">:</span> <span class="token punctuation">-</span> <span class="token string">"3000"</span> <span class="token punctuation">-</span> <span class="token string">"8000"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="external-links"><a href="#external-links" class="headerlink" title="external_links"></a>external_links</h3><blockquote><p>注意：不推荐使用，建议使用 <code>networks</code> 指令代替。</p></blockquote><p>链接到 <code>docker-compose.yml</code> 外部的容器，甚至并非 <code>Compose</code> 管理的外部容器。</p><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token key atrule">external_links</span><span class="token punctuation">:</span> <span class="token punctuation">-</span> redis_1 <span class="token punctuation">-</span> project_db_1<span class="token punctuation">:</span>mysql <span class="token punctuation">-</span> project_db_1<span class="token punctuation">:</span>postgresql<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="extra-hosts"><a href="#extra-hosts" class="headerlink" title="extra_hosts"></a>extra_hosts</h3><p>添加主机名映射，使用与 Docker 中的 <code>--add-host</code> 参数相同的值：</p><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token key atrule">extra_hosts</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token string">"somehost:162.242.195.82"</span>  <span class="token punctuation">-</span> <span class="token string">"otherhost:50.31.209.229"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>会在启动后的服务容器的 <code>/etc/hosts</code> 文件中添加如下两条条目。</p><pre class="line-numbers language-bash"><code class="language-bash">162.242.195.82  somehost50.31.209.229   otherhost<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="healthcheck"><a href="#healthcheck" class="headerlink" title="healthcheck"></a>healthcheck</h3><p>通过命令检查容器是否健康运行。</p><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token key atrule">healthcheck</span><span class="token punctuation">:</span>  <span class="token key atrule">test</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">"CMD"</span><span class="token punctuation">,</span> <span class="token string">"curl"</span><span class="token punctuation">,</span> <span class="token string">"-f"</span><span class="token punctuation">,</span> <span class="token string">"http://localhost"</span><span class="token punctuation">]</span>  <span class="token key atrule">interval</span><span class="token punctuation">:</span> 1m30s  <span class="token key atrule">timeout</span><span class="token punctuation">:</span> 10s  <span class="token key atrule">retries</span><span class="token punctuation">:</span> <span class="token number">3</span>  <span class="token key atrule">start_period</span><span class="token punctuation">:</span> 40s<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>test</code> 必须是字符串或列表。 如果是一个列表，则第一个参数必须是 <code>NONE</code>、 <code>CMD</code> 或 <code>CMD-shell</code>。 如果它是一个字符串，那么它等价于指定 <code>CMD-SHELL</code>，然后指定该字符串。以下写法效果是一样的。</p><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token comment" spellcheck="true"># Hit the local web app</span><span class="token key atrule">test</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">"CMD"</span><span class="token punctuation">,</span> <span class="token string">"curl"</span><span class="token punctuation">,</span> <span class="token string">"-f"</span><span class="token punctuation">,</span> <span class="token string">"http://localhost"</span><span class="token punctuation">]</span><span class="token key atrule">test</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">"CMD-SHELL"</span><span class="token punctuation">,</span> <span class="token string">"curl -f http://localhost || exit 1"</span><span class="token punctuation">]</span><span class="token key atrule">test</span><span class="token punctuation">:</span> curl <span class="token punctuation">-</span>f https<span class="token punctuation">:</span>//localhost <span class="token punctuation">|</span><span class="token punctuation">|</span> exit 1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>要禁用镜像默认健康检查设置，可以使用 <code>disable: true</code>。 这相当于指定 test: [“NONE”]。</p><h3 id="image"><a href="#image" class="headerlink" title="image"></a>image</h3><p>指定要从哪个镜像启动容器。如果镜像在本地不存在，也没有指定了 <code>build</code>，<code>Compose</code> 将会尝试拉取这个镜像。</p><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token key atrule">image</span><span class="token punctuation">:</span> ubuntu<span class="token key atrule">image</span><span class="token punctuation">:</span> example<span class="token punctuation">-</span>registry.com<span class="token punctuation">:</span>4000/postgresql<span class="token key atrule">image</span><span class="token punctuation">:</span> a4bc65fd<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="init"><a href="#init" class="headerlink" title="init"></a>init</h3><p>在容器中运行一个 init，用于转发信号和回收进程。 将此选项设置为 true，以便为服务启用此特性。</p><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token key atrule">version</span><span class="token punctuation">:</span> <span class="token string">"3.8"</span><span class="token key atrule">services</span><span class="token punctuation">:</span>  <span class="token key atrule">web</span><span class="token punctuation">:</span>    <span class="token key atrule">image</span><span class="token punctuation">:</span> alpine<span class="token punctuation">:</span>latest    <span class="token key atrule">init</span><span class="token punctuation">:</span> <span class="token boolean important">true</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>默认使用的 init 二进制文件是 Tini，并安装在守护进程主机上的 <code>/usr/libexec/docker-init</code> 中。 可以通过 <code>init-path</code> 配置选项将守护进程配置为使用自定义 init 二进制文件。</p></blockquote><h3 id="labels-1"><a href="#labels-1" class="headerlink" title="labels"></a>labels</h3><p>为容器添加 Docker 元数据（metadata）信息。</p><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token key atrule">labels</span><span class="token punctuation">:</span>  <span class="token key atrule">com.example.description</span><span class="token punctuation">:</span> <span class="token string">"Accounting webapp"</span>  <span class="token key atrule">com.example.department</span><span class="token punctuation">:</span> <span class="token string">"Finance"</span>  <span class="token key atrule">com.example.label-with-empty-value</span><span class="token punctuation">:</span> <span class="token string">""</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="logging"><a href="#logging" class="headerlink" title="logging"></a>logging</h3><p>配置日志选项。</p><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token key atrule">logging</span><span class="token punctuation">:</span>  <span class="token key atrule">driver</span><span class="token punctuation">:</span> syslog  <span class="token key atrule">options</span><span class="token punctuation">:</span>    <span class="token key atrule">syslog-address</span><span class="token punctuation">:</span> <span class="token string">"tcp://192.168.0.42:123"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>驱动程序名称为服务的容器指定了一个日志驱动程序，与 docker 运行 <code>---log-driver</code> 选项一样。</p><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token key atrule">driver</span><span class="token punctuation">:</span> <span class="token string">"json-file"</span>  <span class="token comment" spellcheck="true"># 默认值</span><span class="token key atrule">driver</span><span class="token punctuation">:</span> <span class="token string">"syslog"</span><span class="token key atrule">driver</span><span class="token punctuation">:</span> <span class="token string">"none"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><blockquote><p>只有 <code>json-file</code> 和 <code>journald</code> 驱动程序可以直接从 <code>docker-compose up</code> 和 <code>docker-compose logs</code> 中获得日志。 使用其他驱动程序都不打印日志。</p></blockquote><p> 可以使用 <code>options</code> 配置日志驱动的相关参数。与 <code>docker run</code> 的 <code>--log-opt</code> 选项一样。如 <code>json-file</code>支持的：</p><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token key atrule">options</span><span class="token punctuation">:</span>  <span class="token key atrule">max-size</span><span class="token punctuation">:</span> <span class="token string">"200k"</span>  <span class="token key atrule">max-file</span><span class="token punctuation">:</span> <span class="token string">"10"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="network-mode"><a href="#network-mode" class="headerlink" title="network_mode"></a>network_mode</h3><p>设置网络模式。和 <code>docker run</code> 的 <code>--network</code> 参数一样。</p><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token key atrule">network_mode</span><span class="token punctuation">:</span> <span class="token string">"bridge"</span><span class="token key atrule">network_mode</span><span class="token punctuation">:</span> <span class="token string">"host"</span><span class="token key atrule">network_mode</span><span class="token punctuation">:</span> <span class="token string">"none"</span><span class="token key atrule">network_mode</span><span class="token punctuation">:</span> <span class="token string">"service:[service name]"</span><span class="token key atrule">network_mode</span><span class="token punctuation">:</span> <span class="token string">"container:[container name/id]"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="networks"><a href="#networks" class="headerlink" title="networks"></a>networks</h3><p>配置容器连接的网络。</p><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token key atrule">services</span><span class="token punctuation">:</span>  <span class="token key atrule">some-service</span><span class="token punctuation">:</span>    <span class="token key atrule">networks</span><span class="token punctuation">:</span>     <span class="token punctuation">-</span> some<span class="token punctuation">-</span>network     <span class="token punctuation">-</span> other<span class="token punctuation">-</span>network<span class="token key atrule">networks</span><span class="token punctuation">:</span>  <span class="token key atrule">some-network</span><span class="token punctuation">:</span>  other<span class="token punctuation">-</span>network<span class="token punctuation">:</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="aliases"><a href="#aliases" class="headerlink" title="aliases"></a>aliases</h4><p>同一网络上的其他容器可以使用服务名称或这个别名连接到服务的一个容器。由于别名是网络范围的，同一个服务在不同的网络上可以有不同的别名。</p><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token key atrule">version</span><span class="token punctuation">:</span> <span class="token string">"3.8"</span><span class="token key atrule">services</span><span class="token punctuation">:</span>  <span class="token key atrule">web</span><span class="token punctuation">:</span>    <span class="token key atrule">image</span><span class="token punctuation">:</span> <span class="token string">"nginx:alpine"</span>    <span class="token key atrule">networks</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> new  <span class="token key atrule">worker</span><span class="token punctuation">:</span>    <span class="token key atrule">image</span><span class="token punctuation">:</span> <span class="token string">"my-worker-image:latest"</span>    <span class="token key atrule">networks</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> legacy  <span class="token key atrule">db</span><span class="token punctuation">:</span>    <span class="token key atrule">image</span><span class="token punctuation">:</span> mysql    <span class="token key atrule">networks</span><span class="token punctuation">:</span>      <span class="token key atrule">new</span><span class="token punctuation">:</span>        <span class="token key atrule">aliases</span><span class="token punctuation">:</span>          <span class="token punctuation">-</span> database      <span class="token key atrule">legacy</span><span class="token punctuation">:</span>        <span class="token key atrule">aliases</span><span class="token punctuation">:</span>          <span class="token punctuation">-</span> mysql<span class="token key atrule">networks</span><span class="token punctuation">:</span>  <span class="token key atrule">new</span><span class="token punctuation">:</span>  legacy<span class="token punctuation">:</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在上面的示例中，提供了三个服务(<code>web</code>、 <code>worker</code> 和 <code>db</code>)以及两个网络(<code>new</code> 和 <code>legacy</code>)。 <code>db</code> 服务在 <code>new</code> 网络上的主机名为 <code>db</code> 或 <code>database</code> ，在 <code>legacy</code> 网络上主机名为 <code>db</code> 或 <code>mysql</code>。</p><h3 id="pid"><a href="#pid" class="headerlink" title="pid"></a>pid</h3><p>将 PID 模式设置为 <code>host</code> ，将与主机系统共享进程命名空间。使用此标志启动的容器可以访问和操作宿主机名称空间中的其他容器，反之亦然。</p><h3 id="ports"><a href="#ports" class="headerlink" title="ports"></a>ports</h3><p>暴露端口信息。使用 <code>HOST:CONTAINER</code> 格式，或者仅指定容器端口（宿主机将随机选择端口）都可以。</p><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token key atrule">ports</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token string">"3000"</span>  <span class="token punctuation">-</span> <span class="token string">"3000-3005"</span>  <span class="token punctuation">-</span> <span class="token string">"8000:8000"</span>  <span class="token punctuation">-</span> <span class="token string">"9090-9091:8080-8081"</span>  <span class="token punctuation">-</span> <span class="token string">"49100:22"</span>  <span class="token punctuation">-</span> <span class="token string">"127.0.0.1:8001:8001"</span>  <span class="token punctuation">-</span> <span class="token string">"127.0.0.1:5000-5010:5000-5010"</span>  <span class="token punctuation">-</span> <span class="token string">"6060:6060/udp"</span>  <span class="token punctuation">-</span> <span class="token string">"12400-12500:1240"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>当使用 <code>HOST:CONTAINER</code> 格式来映射端口时，如果使用的容器端口小于 60 并且没放到引号里，可能会得到错误结果，因为 <code>YAML</code> 会自动解析 <code>xx:yy</code> 这种数字格式为 60 进制。</p><p>为避免出现这种问题，建议数字串都采用引号包括起来的字符串格式。</p></blockquote><h3 id="secrets"><a href="#secrets" class="headerlink" title="secrets"></a>secrets</h3><p>存储敏感数据，例如 <code>mysql</code> 服务密码。</p><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token key atrule">version</span><span class="token punctuation">:</span> <span class="token string">"3.8"</span><span class="token key atrule">services</span><span class="token punctuation">:</span>  <span class="token key atrule">redis</span><span class="token punctuation">:</span>    <span class="token key atrule">image</span><span class="token punctuation">:</span> redis<span class="token punctuation">:</span>latest    <span class="token key atrule">deploy</span><span class="token punctuation">:</span>      <span class="token key atrule">replicas</span><span class="token punctuation">:</span> <span class="token number">1</span>    <span class="token key atrule">secrets</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> my_secret      <span class="token punctuation">-</span> my_other_secret<span class="token key atrule">secrets</span><span class="token punctuation">:</span>  <span class="token key atrule">my_secret</span><span class="token punctuation">:</span>    <span class="token key atrule">file</span><span class="token punctuation">:</span> ./my_secret.txt  <span class="token key atrule">my_other_secret</span><span class="token punctuation">:</span>    <span class="token key atrule">external</span><span class="token punctuation">:</span> <span class="token boolean important">true</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>以上示例授予<code>redis</code>服务对<code>my_secret</code>和<code>my_other_secret</code>秘密的访问权限。 <code>my_secret</code>的值设置为文件<code>./my_secret.txt</code>的内容，并将 <code>my_other_secret</code>定义为外部资源，这意味着它已经在Docker中定义，可以通过运行<code>docker secret create</code> 命令进行定义。如果外部机密不存在，则部署将失败并显示<code>secret not found</code>错误。</p><h3 id="security-opt"><a href="#security-opt" class="headerlink" title="security_opt"></a>security_opt</h3><p>指定容器模板标签（label）机制的默认属性（用户、角色、类型、级别等）。例如配置标签的用户名和角色名。</p><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token key atrule">security_opt</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> label<span class="token punctuation">:</span>user<span class="token punctuation">:</span>USER  <span class="token punctuation">-</span> label<span class="token punctuation">:</span>role<span class="token punctuation">:</span>ROLE<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="stop-grace-period"><a href="#stop-grace-period" class="headerlink" title="stop_grace_period"></a>stop_grace_period</h3><p>指定 <code>stop_signal</code> 在发送 <code>SIGKILL</code> 之前，如果容器无法处理 <code>SIGTERM</code>（或已使用指定的任何停止信号）而试图停止容器的等待时间 。</p><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token key atrule">stop_grace_period</span><span class="token punctuation">:</span> 1s<span class="token key atrule">stop_grace_period</span><span class="token punctuation">:</span> 1m30s<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>默认情况下，<code>stop</code>在发送 <code>SIGKILL</code> 之前等待10秒以退出容器。</p><h3 id="stop-signal"><a href="#stop-signal" class="headerlink" title="stop_signal"></a>stop_signal</h3><p>设置替代信号来停止容器。在默认情况下使用的是 SIGTERM 停止容器。</p><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token key atrule">stop_signal</span><span class="token punctuation">:</span> SIGUSR1<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="sysctls"><a href="#sysctls" class="headerlink" title="sysctls"></a>sysctls</h3><p>配置容器内核参数。</p><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token key atrule">sysctls</span><span class="token punctuation">:</span>  <span class="token key atrule">net.core.somaxconn</span><span class="token punctuation">:</span> <span class="token number">1024</span>  <span class="token key atrule">net.ipv4.tcp_syncookies</span><span class="token punctuation">:</span> <span class="token number">0</span><span class="token key atrule">sysctls</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> net.core.somaxconn=1024  <span class="token punctuation">-</span> net.ipv4.tcp_syncookies=0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="tmpfs"><a href="#tmpfs" class="headerlink" title="tmpfs"></a>tmpfs</h3><p>挂载一个临时文件系统到容器。</p><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token key atrule">tmpfs</span><span class="token punctuation">:</span> /run<span class="token key atrule">tmpfs</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> /run  <span class="token punctuation">-</span> /tmp<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="ulimits"><a href="#ulimits" class="headerlink" title="ulimits"></a>ulimits</h3><p>指定容器的 ulimits 限制值。</p><pre class="line-numbers language-yaml"><code class="language-yaml">  <span class="token key atrule">ulimits</span><span class="token punctuation">:</span>    <span class="token key atrule">nproc</span><span class="token punctuation">:</span> <span class="token number">65535</span>    <span class="token key atrule">nofile</span><span class="token punctuation">:</span>      <span class="token key atrule">soft</span><span class="token punctuation">:</span> <span class="token number">20000</span>      <span class="token key atrule">hard</span><span class="token punctuation">:</span> <span class="token number">40000</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="volumes"><a href="#volumes" class="headerlink" title="volumes"></a>volumes</h3><p>数据卷所挂载路径设置。可以设置为宿主机路径(<code>HOST:CONTAINER</code>)或者数据卷名称(<code>VOLUME:CONTAINER</code>)，并且可以设置访问模式 （<code>HOST:CONTAINER:ro</code>）。</p><p>该指令中路径支持相对路径。</p><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token key atrule">volumes</span><span class="token punctuation">:</span> <span class="token punctuation">-</span> /var/lib/mysql <span class="token punctuation">-</span> cache/<span class="token punctuation">:</span>/tmp/cache <span class="token punctuation">-</span> ~/configs<span class="token punctuation">:</span>/etc/configs/<span class="token punctuation">:</span>ro<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>如果路径为数据卷名称，必须在文件中配置数据卷。</p><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token key atrule">version</span><span class="token punctuation">:</span> <span class="token string">"3"</span><span class="token key atrule">services</span><span class="token punctuation">:</span>  <span class="token key atrule">my_sql</span><span class="token punctuation">:</span>    <span class="token key atrule">image</span><span class="token punctuation">:</span> mysql<span class="token punctuation">:</span><span class="token number">8.0</span>    <span class="token key atrule">volumes</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> mysql_data<span class="token punctuation">:</span>/var/lib/mysql<span class="token key atrule">volumes</span><span class="token punctuation">:</span>  mysql_data<span class="token punctuation">:</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="其它指令"><a href="#其它指令" class="headerlink" title="其它指令"></a>其它指令</h3><p>此外，还有包括 <code>domainname, hostname, ipc, mac_address, privileged, read_only, shm_size, restart, stdin_open, tty, user, working_dir</code> 等指令，基本跟 <code>docker run</code> 中对应参数的功能一致。</p><p>指定容器中运行应用的用户名。</p><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token key atrule">user</span><span class="token punctuation">:</span> nginx<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>指定容器中工作目录。</p><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token key atrule">working_dir</span><span class="token punctuation">:</span> /code<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>指定容器中搜索域名、主机名、mac 地址等。</p><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token key atrule">domainname</span><span class="token punctuation">:</span> your_website.com<span class="token key atrule">hostname</span><span class="token punctuation">:</span> test<span class="token key atrule">mac_address</span><span class="token punctuation">:</span> 08<span class="token punctuation">-</span>00<span class="token punctuation">-</span>27<span class="token punctuation">-</span>00<span class="token punctuation">-</span>0C<span class="token punctuation">-</span>0A<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>允许容器中运行一些特权命令。</p><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token key atrule">privileged</span><span class="token punctuation">:</span> <span class="token boolean important">true</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>指定容器退出后的重启策略为始终重启。该命令对保持服务始终运行十分有效，在生产环境中推荐配置为 <code>always</code> 或者 <code>unless-stopped</code>。</p><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token key atrule">restart</span><span class="token punctuation">:</span> always<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>以只读模式挂载容器的 root 文件系统，意味着不能对容器内容进行修改。</p><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token key atrule">read_only</span><span class="token punctuation">:</span> <span class="token boolean important">true</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>打开标准输入，可以接受外部输入。</p><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token key atrule">stdin_open</span><span class="token punctuation">:</span> <span class="token boolean important">true</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>模拟一个伪终端。</p><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token key atrule">tty</span><span class="token punctuation">:</span> <span class="token boolean important">true</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="读取变量"><a href="#读取变量" class="headerlink" title="读取变量"></a>读取变量</h2><p>Compose 模板文件支持动态读取主机的系统环境变量和当前目录下的 <code>.env</code> 文件中的变量。</p><p>例如，下面的 Compose 文件将从运行它的环境中读取变量 <code>${MONGO_VERSION}</code> 的值，并写入执行的指令中。</p><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token key atrule">version</span><span class="token punctuation">:</span> <span class="token string">"3"</span><span class="token key atrule">services</span><span class="token punctuation">:</span>  <span class="token key atrule">db</span><span class="token punctuation">:</span>    <span class="token key atrule">image</span><span class="token punctuation">:</span> <span class="token string">"mongo:${MONGO_VERSION}"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果执行 <code>MONGO_VERSION=3.2 docker-compose up</code> 则会启动一个 <code>mongo:3.2</code> 镜像的容器。</p><p>若当前目录存在 <code>.env</code> 文件，执行 <code>docker-compose</code> 命令时将从该文件中读取变量。</p><p>在当前目录新建 <code>.env</code> 文件并写入以下内容。</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 支持注释</span>MONGO_VERSION<span class="token operator">=</span>3.6<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>执行 <code>docker-compose up</code> 则会启动一个 <code>mongo:3.6</code> 镜像的容器。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>官方文档： <a href="https://docs.docker.com/compose/compose-file/" target="_blank" rel="noopener">Compose file</a></li><li>Compose文件示例：<a href="https://github.com/docker/awesome-compose" target="_blank" rel="noopener">Awesome compose</a></li><li><a href="https://yeasy.gitbooks.io/docker_practice/compose/compose_file.html" target="_blank" rel="noopener">Compose模板文件</a></li></ul><h2 id="相关文章"><a href="#相关文章" class="headerlink" title="相关文章"></a>相关文章</h2><ul><li>上一篇：<a href="https://www.lixl.cn/books/Docker/appendix3-docker-compose-command/">Docker必知必会系列（附录3）：Docker-compose 命令使用指南</a></li><li>下一篇：<a href="https://www.lixl.cn/books/Docker/appendix5-kubectl/">Docker必知必会系列（附录5）：Kubectl 命令行界面</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DevOps </tag>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>附录3、Docker-compose 命令使用指南</title>
      <link href="/2020/042540674.html"/>
      <url>/2020/042540674.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文是《<a href="https://www.lixl.cn/books/Docker/1-Overview/">Docker必知必会系列</a>》第十一篇，原文发布于个人博客：<a href="https://www.lixl.cn/">悟尘记</a>。</p><p>上一篇：<a href="https://www.lixl.cn/books/Docker/appendix2-dockerfile-best-practices/">Docker必知必会系列（附录2）：Dockerfile 参考及最佳实践</a></p></blockquote><h2 id="命令选项概述和帮助"><a href="#命令选项概述和帮助" class="headerlink" title="命令选项概述和帮助"></a>命令选项概述和帮助</h2><p>您可以通过在命令行执行如下命令来获取相关帮助信息：</p><pre class="line-numbers language-bash"><code class="language-bash">  docker-compose <span class="token punctuation">[</span>-f <span class="token operator">&lt;</span>arg<span class="token operator">></span><span class="token punctuation">..</span>.<span class="token punctuation">]</span> <span class="token punctuation">[</span>options<span class="token punctuation">]</span> <span class="token punctuation">[</span>COMMAND<span class="token punctuation">]</span> <span class="token punctuation">[</span>ARGS<span class="token punctuation">..</span>.<span class="token punctuation">]</span>  docker-compose -h<span class="token operator">|</span>--help<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>命令选项</p><ul><li><code>-f, --file FILE</code> 指定模板文件，默认为 <code>docker-compose.yml</code>，可以指定多个文件。</li><li><code>-p, --project-name NAME</code> 指定项目名称，默认使用所在目录名。</li><li><code>--verbose</code> 输出更多调试信息。</li><li><code>-v, --version</code> 打印版本并退出。</li><li><code>-H, --host HOST</code> 指定连接到哪个守护进程</li></ul><h2 id="命令自动补全"><a href="#命令自动补全" class="headerlink" title="命令自动补全"></a>命令自动补全</h2><p>Compose 为 bash 和 zsh 提供了命令补全功能，Linux 安装：</p><pre class="line-numbers language-bash"><code class="language-bash"> <span class="token function">sudo</span> curl -L https://raw.githubusercontent.com/docker/compose/1.25.5/contrib/completion/bash/docker-compose -o /etc/bash_completion.d/docker-compose<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>其它系统安装，请参考官方文档： <a href="https://docs.docker.com/compose/completion/" target="_blank" rel="noopener">https://docs.docker.com/compose/completion/</a></p><h2 id="命令使用说明"><a href="#命令使用说明" class="headerlink" title="命令使用说明"></a>命令使用说明</h2><h3 id="version（查看版本）"><a href="#version（查看版本）" class="headerlink" title="version（查看版本）"></a>version（查看版本）</h3><p>查看版本信息。</p><h3 id="build（构建服务）"><a href="#build（构建服务）" class="headerlink" title="build（构建服务）"></a>build（构建服务）</h3><p>格式为 <code>docker-compose build [options] [SERVICE...]</code>。</p><p>构建（重新构建）并标记服务，默认为<code>project_service</code>，例如，<code>composetest_db</code>。</p><p>如果更改了服务的 <code>Dockerfile</code> 或构建目录中的内容，请运行<code>docker-compose build</code>以重建它。</p><h3 id="config（验证配置）"><a href="#config（验证配置）" class="headerlink" title="config（验证配置）"></a>config（验证配置）</h3><p>验证并查看 Compose 文件。</p><h3 id="down-（停止服务）"><a href="#down-（停止服务）" class="headerlink" title="down （停止服务）"></a>down （停止服务）</h3><p>停止容器并移除由 <code>up</code> 创建的容器、网络、卷和镜像。 定义为 <code>external</code> 的网络和卷永远不会被移除。</p><h3 id="events（监测时间）"><a href="#events（监测时间）" class="headerlink" title="events（监测时间）"></a>events（监测时间）</h3><p>监测项目中容器事件，使用–json`标志时，每行将打印一个json对象。</p><h3 id="exec（进入容器）"><a href="#exec（进入容器）" class="headerlink" title="exec（进入容器）"></a>exec（进入容器）</h3><p>进入指定的容器，例如通过 <code>docker-compose exec web sh</code> 可进入服务名为 <code>web</code>的容器进行交互式操作。</p><h3 id="help（查看帮助）"><a href="#help（查看帮助）" class="headerlink" title="help（查看帮助）"></a>help（查看帮助）</h3><p>显示命令的帮助和用法说明。</p><h3 id="images（列出镜像）"><a href="#images（列出镜像）" class="headerlink" title="images（列出镜像）"></a>images（列出镜像）</h3><p>列出 Compose 文件中包含的镜像。</p><h3 id="kill（停止服务）"><a href="#kill（停止服务）" class="headerlink" title="kill（停止服务）"></a>kill（停止服务）</h3><p>强制停止运行中的服务容器。格式为 <code>docker-compose kill [options] [SERVICE...]</code>。</p><p>支持通过 <code>-s</code> 参数来指定要发送的信号，例如发送 <code>SIGINT</code> 信号：</p><pre class="line-numbers language-bash"><code class="language-bash">docker-compose <span class="token function">kill</span> -s SIGINT<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="logs（查看日志）"><a href="#logs（查看日志）" class="headerlink" title="logs（查看日志）"></a>logs（查看日志）</h3><p>查看服务的日志输出。格式为 <code>docker-compose logs [options] [SERVICE...]</code>。可选项：</p><pre class="line-numbers language-yml"><code class="language-yml">--no-color          # 关闭不同服务用不同颜色显示的功能-f, --follow        # 实时监控日志-t, --timestamps    # 显示时间戳--tail="all"        # 显示所有日志<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="pause（暂停服务）"><a href="#pause（暂停服务）" class="headerlink" title="pause（暂停服务）"></a>pause（暂停服务）</h3><p>暂停正在运行的容器，可通过 <code>unpause</code> 取消暂停。格式为 <code>docker-compose pause [SERVICE...]</code>。</p><h3 id="port（查看端口）"><a href="#port（查看端口）" class="headerlink" title="port（查看端口）"></a>port（查看端口）</h3><p>打印某个容器所映射的公共端口，格式为 <code>docker-compose port [options] SERVICE PRIVATE_PORT</code>。</p><h3 id="ps（列出服务）"><a href="#ps（列出服务）" class="headerlink" title="ps（列出服务）"></a>ps（列出服务）</h3><p>列出项目中的所有容器。</p><h3 id="pull（拉取镜像）"><a href="#pull（拉取镜像）" class="headerlink" title="pull（拉取镜像）"></a>pull（拉取镜像）</h3><p>拉取服务依赖的镜像。可通过 <code>--ignore-pull-failures</code> 参数忽略拉取镜像过程中的错误。</p><h3 id="push（推送镜像）"><a href="#push（推送镜像）" class="headerlink" title="push（推送镜像）"></a>push（推送镜像）</h3><p>推送服务所依赖的镜像到镜像仓库。</p><h3 id="restart（重启服务）"><a href="#restart（重启服务）" class="headerlink" title="restart（重启服务）"></a>restart（重启服务）</h3><p>重启项目中的服务。</p><h3 id="rm（删除容器）"><a href="#rm（删除容器）" class="headerlink" title="rm（删除容器）"></a>rm（删除容器）</h3><p>删除停止的服务容器。</p><p>默认情况下，不删除附加到容器的匿名卷。您可以使用 <code>-v</code> 覆盖它。要列出所有卷，请使用 <code>docker volume ls</code>。</p><p>任何不在卷中的数据都会丢失。运行不带选项的命令还会删除由 <code>docker-compose up</code> 或 <code>docker-compose run</code> 创建的一次性容器:</p><h3 id="run（运行命令）"><a href="#run（运行命令）" class="headerlink" title="run（运行命令）"></a>run（运行命令）</h3><p>针对服务执行一次性命令。命令选项：</p><ul><li><code>-d</code> 后台运行容器。</li><li><code>--name NAME</code> 为容器指定一个名字。</li><li><code>--entrypoint CMD</code> 覆盖默认的容器启动指令。</li><li><code>-e KEY=VAL</code> 设置环境变量值，可多次使用选项来设置多个环境变量。</li><li><code>-u, --user=&quot;&quot;</code> 指定运行容器的用户名或者 uid。</li><li><code>--no-deps</code> 不自动启动关联的服务容器。</li><li><code>--rm</code> 运行命令后自动删除容器，<code>d</code> 模式下将忽略。</li><li><code>-p, --publish=[]</code> 映射容器端口到本地主机。</li><li><code>--service-ports</code> 配置服务端口并映射到本地主机。</li><li><code>-T</code> 不分配伪 tty，意味着依赖 tty 的指令将无法运行。</li></ul><p>例如，以下命令启动<code>web</code>服务并运行<code>bash</code>命令。</p><pre class="line-numbers language-bash"><code class="language-bash">docker-compose run web <span class="token function">bash</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>该命令类似启动容器后运行指定的命令，相关卷、链接等等都将会按照配置自动创建。有两个重要区别：</p><ul><li>给定命令将会覆盖服务配置中定义的命令。</li><li>不会创建服务配置中指定的任何端口，这样可避免端口冲突。可通过附加 <code>--service-ports</code> 创建端口。还可以使用<code>--publish</code>或<code>-p</code>选项手动指定端口映射。</li></ul><p>默认情况下，所有关联且未运行的服务将会自动被启动。如果不希望自动启动关联的容器，可以使用 <code>--no-deps</code> 选项，例如：</p><pre class="line-numbers language-bash"><code class="language-bash">docker-compose run --no-deps web python manage.py shell<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>将不会启动 web 容器所关联的其它容器。</p><h3 id="start（启动服务）"><a href="#start（启动服务）" class="headerlink" title="start（启动服务）"></a>start（启动服务）</h3><p>启动用于服务的现有容器。</p><h3 id="stop（停止服务）"><a href="#stop（停止服务）" class="headerlink" title="stop（停止服务）"></a>stop（停止服务）</h3><p>停止已经处于运行状态的容器，但不删除它。</p><h3 id="top（查看进程）"><a href="#top（查看进程）" class="headerlink" title="top（查看进程）"></a>top（查看进程）</h3><p>查看各个服务内正在运行的进程。</p><h3 id="unpause（暂停服务）"><a href="#unpause（暂停服务）" class="headerlink" title="unpause（暂停服务）"></a>unpause（暂停服务）</h3><p>恢复处于暂停状态中的服务。</p><h3 id="up（构建并启动服务）"><a href="#up（构建并启动服务）" class="headerlink" title="up（构建并启动服务）"></a>up（构建并启动服务）</h3><p>自动构建，（重新）创建服务，启动服务并在控制台聚合显示每个容器的日志。</p><p>链接的服务都将会被自动启动，除非已经处于运行状态。</p><p>当通过 <code>Ctrl-C</code> 停止命令时，所有容器将会停止。</p><p>如果使用 <code>docker-compose up -d</code>，将会在后台启动并运行所有的容器。</p><p>如果用于服务的容器已经存在，并且在创建容器后更改了服务的配置或镜像，<code>docker-compose up</code> 将会停止并重新创建容器来获取更新（保留通过 <code>volumes-from</code> 挂载的卷）。</p><p>如果不希望应用更新，可使用 <code>--no-recreate</code>参数。如果要强制停止并重新创建所有容器，可使用该 <code>--force-recreate</code>参数。</p><p>如果进程遇到错误，此命令的退出代码为<code>1</code>。如果使用 <code>SIGINT</code>（<code>ctrl</code>+ <code>C</code>）或<code>SIGTERM</code>  中断该进程，则容器停止，退出代码为 <code>0</code>。如果在此关闭阶段再次发送 <code>SIGINT</code> 或 <code>SIGTERM</code> 则会停止正在运行的容器，退出代码为 <code>2</code>。</p><p>命令选项：</p><ul><li><p><code>-d</code> 在后台运行服务容器。</p></li><li><p><code>--no-color</code> 不使用颜色来区分不同的服务的控制台输出。</p></li><li><p><code>--no-deps</code> 不启动服务所链接的容器。</p></li><li><p><code>--force-recreate</code> 强制重新创建容器，不能与 <code>--no-recreate</code> 同时使用。</p></li><li><p><code>--no-recreate</code> 如果容器已经存在了，则不重新创建，不能与 <code>--force-recreate</code> 同时使用。</p></li><li><p><code>--no-build</code> 不自动构建缺失的服务镜像。</p></li><li><p><code>--no-start</code> 仅创建服务但不启动。</p></li><li><p><code>-t, --timeout TIMEOUT</code> 在附加或容器已运行时，超时（默认为 10 秒）关闭容器。</p></li><li><p><code>-V, --renew-anon-volumes</code> 重新创建匿名卷，而不是从以前的容器中检索数据。</p></li><li><p><code>--remove-orphans</code> 删除未在 Compose 文件中定义的服务的容器。</p></li><li><p><code>--scale SERVICE=NUM</code> 设置为服务运行的容器数量。会覆盖 Compose 文件中的 <code>scale</code> 设置。</p></li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>官方文档：<a href="https://docs.docker.com/compose/reference/" target="_blank" rel="noopener">Compose reference</a></li></ul><h2 id="相关文章"><a href="#相关文章" class="headerlink" title="相关文章"></a>相关文章</h2><ul><li>上一篇：<a href="https://www.lixl.cn/books/Docker/appendix2-dockerfile-best-practices/">Docker必知必会系列（附录2）：Dockerfile 参考及最佳实践</a></li><li>下一篇：<a href="https://www.lixl.cn/books/Docker/appendix4-docker-compose-file/">Docker必知必会系列（附录4）：Docker-compose 配置文件编写</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DevOps </tag>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo-admonition 插件安装使用指南</title>
      <link href="/2020/041837756.html"/>
      <url>/2020/041837756.html</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Hexo 内容辅助插件，支持将类似 <a href="https://docutils.sourceforge.io/docs/ref/rst/directives.html" target="_blank" rel="noopener">reStructuredText</a> 的警告提示块添加到 Markdown 文档中。例如 note、warning、error 等提示块，效果如图：</p><p><img src="https://pic.lixl.cn/2020/image-20200419230838823.png" alt="Hexo-admonition 示例效果"></p><p>开发这个插件的动机，是想让 <a href="https://hexo.io" target="_blank" rel="noopener">hexo</a> 与 <a href="https://squidfunk.github.io/mkdocs-material/extensions/admonition/" target="_blank" rel="noopener">Material for MkDocs</a> 的提示信息兼容，让系列文章在基于 MkDocs 搭建的子站中有更好的阅读体验。</p><p>查看更多内容，请访问博文：<a href="https://www.lixl.cn/2020/041837756.html">Hexo-admonition 插件安装使用指南</a>。</p><h2 id="安装说明"><a href="#安装说明" class="headerlink" title="安装说明"></a>安装说明</h2><h3 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件"></a>安装插件</h3><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">npm</span> <span class="token function">install</span> hexo-admonition --save<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="使用指南"><a href="#使用指南" class="headerlink" title="使用指南"></a>使用指南</h2><h3 id="语法说明"><a href="#语法说明" class="headerlink" title="语法说明"></a>语法说明</h3><p>Hexo-admonition 遵循一种简单的语法：每个块都以 <code>!!!</code> 开头，然后是代表提示类型的关键字（<code>type</code>）及标题（<code>title</code>）。例如:</p><pre class="line-numbers language-text"><code class="language-text">!!! note Hexo-admonition 插件使用示例    这是基于 hexo-admonition 插件渲染的一条提示信息。类型为 note，并设置了自定义标题。    提示内容开头留 4 个空格，可以有多行，最后用空行结束此标记。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>在 Hexo 渲染前，将被转换成如下内容：</p><pre class="line-numbers language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>admonition note <span class="token punctuation">"</span></span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>admonition-title<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>Hexo-admonition 插件使用示例<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">></span></span>这是基于 hexo-admonition 插件渲染的一条提示信息。类型为 note，并设置了自定义标题。<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">></span></span>提示内容开头留 4 个空格，可以有多行，最后用空行结束此标记。<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>最终呈现效果如下：</p><p><img src="https://pic.lixl.cn/2020/image-20200420120245339.png" alt="hexo-admonition 插件 note 提示示例"></p><h3 id="支持的类型"><a href="#支持的类型" class="headerlink" title="支持的类型"></a>支持的类型</h3><p>提示类型 <code>type</code> 将用作 CSS 类名称，暂支持如下类型：</p><ul><li><code>note</code></li><li><code>info, todo</code></li><li><code>warning, attention, caution</code></li><li><code>error, failure, missing, fail</code></li></ul><h3 id="设置-隐藏标题"><a href="#设置-隐藏标题" class="headerlink" title="设置/隐藏标题"></a>设置/隐藏标题</h3><p>标题 <code>title</code> 是可选的，当未设置时，将以 <code>type</code> 作为默认值:</p><pre class="line-numbers language-text"><code class="language-text">!!! warning    这是一条采用默认标题的警告信息。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>效果如下：</p><p><img src="https://pic.lixl.cn/2020/image-20200419232137875.png" alt="默认标题警告提示块"></p><p>如果不想显示标题，可以将 <code>title</code> 设置为 <code>&quot;&quot;</code>：</p><pre class="line-numbers language-text"><code class="language-text">!!! Warning ""    这是一条不带标题的警告信息。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>效果如下：</p><p><img src="https://pic.lixl.cn/2020/image-20200419232337937.png" alt="无标题警告提示块"></p><h3 id="嵌套-markdown-标记"><a href="#嵌套-markdown-标记" class="headerlink" title="嵌套 markdown 标记"></a>嵌套 markdown 标记</h3><p>在 <code>hexo-admonition</code> 内部，还可以嵌套标准 Markdown 标签，例如：</p><pre class="line-numbers language-text"><code class="language-text">!!! node "嵌套链接及引用块"    欢迎访问我的博客链接：[悟尘记](https://www.lixl.cn)    >这里嵌套一行引用信息。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>效果如下:</p><p><img src="https://pic.lixl.cn/2020/image-20200419232539536.png" alt="嵌套效果"></p><h3 id="样式配置"><a href="#样式配置" class="headerlink" title="样式配置"></a>样式配置</h3><p>将如下样式放入 hexo 主题的自定义样式文件中（如：<code>my.css</code>），并按自己喜好修改：</p><pre class="line-numbers language-css"><code class="language-css"><span class="token selector"><span class="token class">.admonition</span> </span><span class="token punctuation">{</span>  <span class="token property">margin</span><span class="token punctuation">:</span> <span class="token number">1.5625</span>em <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token property">padding</span><span class="token punctuation">:</span> <span class="token number">.6</span>rem<span class="token punctuation">;</span>  <span class="token property">overflow</span><span class="token punctuation">:</span> hidden<span class="token punctuation">;</span>  <span class="token property">font-size</span><span class="token punctuation">:</span> <span class="token number">.64</span>rem<span class="token punctuation">;</span>  <span class="token property">page-break-inside</span><span class="token punctuation">:</span> avoid<span class="token punctuation">;</span>  <span class="token property">border-left</span><span class="token punctuation">:</span> <span class="token number">.3</span>rem solid <span class="token hexcode">#42b983</span><span class="token punctuation">;</span>  <span class="token property">border-radius</span><span class="token punctuation">:</span> <span class="token number">.3</span>rem<span class="token punctuation">;</span>  <span class="token property">box-shadow</span><span class="token punctuation">:</span> <span class="token number">0</span> <span class="token number">0.1</span>rem <span class="token number">0.4</span>rem <span class="token function">rgba</span><span class="token punctuation">(</span><span class="token number">0</span>,<span class="token number">0</span>,<span class="token number">0</span>,<span class="token number">.05</span><span class="token punctuation">)</span>, <span class="token number">0</span> <span class="token number">0</span> <span class="token number">0.05</span>rem <span class="token function">rgba</span><span class="token punctuation">(</span><span class="token number">0</span>,<span class="token number">0</span>,<span class="token number">0</span>,<span class="token number">.1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token property">background-color</span><span class="token punctuation">:</span> <span class="token hexcode">#fafafa</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token selector">p<span class="token class">.admonition-title</span> </span><span class="token punctuation">{</span>  <span class="token property">position</span><span class="token punctuation">:</span> relative<span class="token punctuation">;</span>  <span class="token property">margin</span><span class="token punctuation">:</span> -<span class="token number">.6</span>rem -<span class="token number">.6</span>rem <span class="token number">.8</span>em -<span class="token number">.6</span>rem <span class="token important">!important</span><span class="token punctuation">;</span>  <span class="token property">padding</span><span class="token punctuation">:</span> <span class="token number">.4</span>rem <span class="token number">.6</span>rem <span class="token number">.4</span>rem <span class="token number">2.5</span>rem<span class="token punctuation">;</span>  <span class="token property">font-weight</span><span class="token punctuation">:</span> <span class="token number">700</span><span class="token punctuation">;</span>  <span class="token property">background-color</span><span class="token punctuation">:</span><span class="token function">rgba</span><span class="token punctuation">(</span><span class="token number">66</span>, <span class="token number">185</span>, <span class="token number">131</span>, <span class="token number">.1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token selector"><span class="token class">.admonition-title</span><span class="token pseudo-element">::before</span> </span><span class="token punctuation">{</span>  <span class="token property">position</span><span class="token punctuation">:</span> absolute<span class="token punctuation">;</span>  <span class="token property">top</span><span class="token punctuation">:</span> <span class="token number">.9</span>rem<span class="token punctuation">;</span>  <span class="token property">left</span><span class="token punctuation">:</span> <span class="token number">1</span>rem<span class="token punctuation">;</span>  <span class="token property">width</span><span class="token punctuation">:</span> <span class="token number">12</span>px<span class="token punctuation">;</span>  <span class="token property">height</span><span class="token punctuation">:</span> <span class="token number">12</span>px<span class="token punctuation">;</span>  <span class="token property">background-color</span><span class="token punctuation">:</span> <span class="token hexcode">#42b983</span><span class="token punctuation">;</span>  <span class="token property">border-radius</span><span class="token punctuation">:</span> <span class="token number">50%</span><span class="token punctuation">;</span>  <span class="token property">content</span><span class="token punctuation">:</span> <span class="token string">' '</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token selector"><span class="token class">.info</span>><span class="token class">.admonition-title</span>, <span class="token class">.todo</span>><span class="token class">.admonition-title</span> </span><span class="token punctuation">{</span>  <span class="token property">background-color</span><span class="token punctuation">:</span> <span class="token function">rgba</span><span class="token punctuation">(</span><span class="token number">0</span>,<span class="token number">184</span>,<span class="token number">212</span>,<span class="token number">.1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token selector"><span class="token class">.warning</span>><span class="token class">.admonition-title</span>, <span class="token class">.attention</span>><span class="token class">.admonition-title</span>, <span class="token class">.caution</span>><span class="token class">.admonition-title</span> </span><span class="token punctuation">{</span>  <span class="token property">background-color</span><span class="token punctuation">:</span> <span class="token function">rgba</span><span class="token punctuation">(</span><span class="token number">255</span>,<span class="token number">145</span>,<span class="token number">0</span>,<span class="token number">.1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token selector"><span class="token class">.failure</span>><span class="token class">.admonition-title</span>, <span class="token class">.missing</span>><span class="token class">.admonition-title</span>, <span class="token class">.fail</span>><span class="token class">.admonition-title</span>, <span class="token class">.error</span>><span class="token class">.admonition-title</span> </span><span class="token punctuation">{</span>  <span class="token property">background-color</span><span class="token punctuation">:</span> <span class="token function">rgba</span><span class="token punctuation">(</span><span class="token number">255</span>,<span class="token number">82</span>,<span class="token number">82</span>,<span class="token number">.1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token selector"><span class="token class">.admonition.info</span>, <span class="token class">.admonition.todo</span> </span><span class="token punctuation">{</span>  <span class="token property">border-color</span><span class="token punctuation">:</span> <span class="token hexcode">#00b8d4</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token selector"><span class="token class">.admonition.warning</span>, <span class="token class">.admonition.attention</span>, <span class="token class">.admonition.caution</span> </span><span class="token punctuation">{</span>  <span class="token property">border-color</span><span class="token punctuation">:</span> <span class="token hexcode">#ff9100</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token selector"><span class="token class">.admonition.failure</span>, <span class="token class">.admonition.missing</span>, <span class="token class">.admonition.fail</span>, <span class="token class">.admonition.error</span> </span><span class="token punctuation">{</span>  <span class="token property">border-color</span><span class="token punctuation">:</span> <span class="token hexcode">#ff5252</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token selector"><span class="token class">.info</span>><span class="token class">.admonition-title</span><span class="token pseudo-element">::before</span>, <span class="token class">.todo</span>><span class="token class">.admonition-title</span><span class="token pseudo-element">::before</span> </span><span class="token punctuation">{</span>  <span class="token property">background-color</span><span class="token punctuation">:</span> <span class="token hexcode">#00b8d4</span><span class="token punctuation">;</span>  <span class="token property">border-radius</span><span class="token punctuation">:</span> <span class="token number">50%</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token selector"><span class="token class">.warning</span>><span class="token class">.admonition-title</span><span class="token pseudo-element">::before</span>, <span class="token class">.attention</span>><span class="token class">.admonition-title</span><span class="token pseudo-element">::before</span>, <span class="token class">.caution</span>><span class="token class">.admonition-title</span><span class="token pseudo-element">::before</span> </span><span class="token punctuation">{</span>  <span class="token property">background-color</span><span class="token punctuation">:</span> <span class="token hexcode">#ff9100</span><span class="token punctuation">;</span>  <span class="token property">border-radius</span><span class="token punctuation">:</span> <span class="token number">50%</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token selector"><span class="token class">.failure</span>><span class="token class">.admonition-title</span><span class="token pseudo-element">::before</span>,<span class="token class">.missing</span>><span class="token class">.admonition-title</span><span class="token pseudo-element">::before</span>,<span class="token class">.fail</span>><span class="token class">.admonition-title</span><span class="token pseudo-element">::before</span>,<span class="token class">.error</span>><span class="token class">.admonition-title</span><span class="token pseudo-element">::before</span></span><span class="token punctuation">{</span>  <span class="token property">background-color</span><span class="token punctuation">:</span> <span class="token hexcode">#ff5252</span><span class="token punctuation">;</span><span class="token punctuation">;</span>  <span class="token property">border-radius</span><span class="token punctuation">:</span> <span class="token number">50%</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token selector"><span class="token class">.admonition</span>><span class="token pseudo-class">:last-child</span> </span><span class="token punctuation">{</span>  <span class="token property">margin-bottom</span><span class="token punctuation">:</span> <span class="token number">0</span> <span class="token important">!important</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="License"><a href="#License" class="headerlink" title="License"></a>License</h2><p>MIT</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://squidfunk.github.io/mkdocs-material/extensions/admonition/" target="_blank" rel="noopener">Material for MkDocs</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>跨团队、流程和应用的主动变革，支撑企业数字化转型</title>
      <link href="/2020/032252398.html"/>
      <url>/2020/032252398.html</url>
      
        <content type="html"><![CDATA[<h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>如今已既成事实的是每家公司其实都是软件公司，快速向客户提供新服务和新功能是公司的关键竞争优势之一。IT 敏捷性是有些初创公司能战胜巨头的基石。</p><p>对于以基础架构为中心的环境而言，其结果之一就是开发人员对自己代码的用途失去了感知力。产品的发布周期较长，而更改速度较慢。在开发人员完成相关工作后，代码将进入测试或运转流程，然后要在数月之后才能发布。由于前期准备时间长，工程师失去了作为开发人员的乐趣，也就是做出创造性工作并见证它在现实生活中发挥作用的乐趣。</p><p>数字化转型以及相关的文化和技术变革（例如 DevOps）所引发的巨变之一，就是重新带来了创建代码的乐趣。开发人员可以创建代码并实际看到运行。这是一种巨大的转变。使得代码创建的即时性得到重现。由于能实时查看应用，从而为开发人员员提供了一个反馈回路，藉此可以让他们重新设计和改进代码，并实现项目的快速推进。</p><h2 id="二、数字化转型意味着什么"><a href="#二、数字化转型意味着什么" class="headerlink" title="二、数字化转型意味着什么"></a>二、数字化转型意味着什么</h2><p>数字化转型是企业的一种战略性变革。促使公司在竞争压力发生变化或新法规出台时能够调整核心服务，在发现漏洞后可以立即推出更新。</p><p>但是，除了“改变现状”之外，还没有数字化转型的通用定义。数字化转型一词有时用于表示新的架构（如微服务）、新的流程（如 DevOps）或新的技术（如容器和应用编程接口（API））。数字化转型并不是某个能够实现的具体目标。这是一种每个企业都必须为自己量身定制的东西。</p><p>没有任何一个架构模式或技术平台可以完美地应用于各种环境。成功实现数字化转型需要清楚地了解企业目标和文化。关键点不在于专注某种模式或某项技术，而是从团队、当前技术债务及业务策略的评估入手，专心致志地按照既定方向将企业向前推进，最终得到想要的结果。</p><p>借助明确的目标和策略，无论现在处于什么状况，都可以不断克服困难（技术债务、设计缺陷等等），实现所设想的进化。这意味着您必须清楚地了解自己所要完成的任务以及与现实之间的差距。</p><h2 id="三、注意房间内的大象"><a href="#三、注意房间内的大象" class="headerlink" title="三、注意房间内的大象"></a>三、注意房间内的大象</h2><p>评估当前的技术前景并完善业务策略绝非易事，往往很难得到这种视角。有一个众所周知的寓言是 “盲人摸象”。故事的重点在于每个人都有不同的观点、有限的信息，以及基于上述观点的假设。这些不同观点所引发的结果说明了团队内部的内在沟通和关系⸺有些可以跳出自己的观点局限，有些则分崩离析。我们所看到的取决于我们是谁、我们在哪里、我们要寻找什么、我们知道什么，以及我们不知道什么。</p><p>任何采用传统应用（和传统团队）的企业，其房间内不止有一只“大象”，其中包括：</p><ul><li>当前的团队结构和沟通模式。</li><li>开发、测试、构建和发布流程。</li><li>技术债务和现有的商用应用。</li><li>部门之间的目标或战略愿景不同。</li></ul><p>这些都是大象，而每个利益相关者都可以从不同的角度看待这些大象。</p><h2 id="四、数字化转型的达尔文进化论观点"><a href="#四、数字化转型的达尔文进化论观点" class="headerlink" title="四、数字化转型的达尔文进化论观点"></a>四、数字化转型的达尔文进化论观点</h2><p>不同类型的改变可能需要不同的基础性变革，有时可能还取决于文化和流程的改变。 罗马不是一日建成的，将数字化转型视为一个逐层推进、环环相扣的连续过程，可能会更具建设性。</p><p><img src="https://pic.lixl.cn/2020/image-20200322163913398.png" alt="“数字进化论主义”的各个阶段"></p><h3 id="1、DevOps-与流程改变"><a href="#1、DevOps-与流程改变" class="headerlink" title="1、DevOps 与流程改变"></a>1、DevOps 与流程改变</h3><p>数字进化的基础是 DevOps。和业务策略一样，应用也体现了创建过程中团队及沟通的情况。DevOps（或类似的流程改变）让更多的利益相关者参与到开发讨论中，并提供了有关运营团队如何维护软件和基础架构（以及客户和合作伙伴如何实际使用这些应用）的深入见解。</p><p>DevOps 在团队之间建立了更紧密的反馈回路，并且需要开诚布公的交流。这种开诚布公的交流是其他演进阶段的基础。</p><h3 id="2、自助式基础架构"><a href="#2、自助式基础架构" class="headerlink" title="2、自助式基础架构"></a>2、自助式基础架构</h3><p>该阶段是一种以技术为中心的变革，旨在引入通常与现代化技术平台相关联的高效率。容器和自助服务目录使开发人员、测试人员和运营团队可以快速启动一致的环境。在有些企业中，新实例的交付时间已从几天缩短到几分钟，而不是让技术人员等待几天。</p><h3 id="3、构建自动化和编排"><a href="#3、构建自动化和编排" class="headerlink" title="3、构建自动化和编排"></a>3、构建自动化和编排</h3><p>构建自动化涉及两方面的改变。从技术角度看，可以采用如 Kubernetes 等高级部署引擎，但也需要流程的改变。许多企业都围绕变更和风险管理制定了严格的流程。如果不对这些流程采用更敏捷的方法，就无法充分利用新的技术。</p><h3 id="4、持续集成-持续交付-CI-CD-管道"><a href="#4、持续集成-持续交付-CI-CD-管道" class="headerlink" title="4、持续集成/持续交付 (CI/CD) 管道"></a>4、持续集成/持续交付 (CI/CD) 管道</h3><p>持续交付就是承诺以快速、迭代的方式交付软件变更。管道的思路是：同时采用流程和技术手段，减少不良代码（或损坏的代码）从制作到部署的风险。它反映了先前步骤（DevOps 以及团队之间的开放式交流、围绕测试和构建的流程，以及自动测试与部署）的成熟度。待所有这些阶段都确定之后，就有可能快速推送代码。这就是管道。</p><h3 id="5、高级部署路径"><a href="#5、高级部署路径" class="headerlink" title="5、高级部署路径"></a>5、高级部署路径</h3><p>一旦用于快速部署的流程和基础架构就位，便可以使用部署系统来减轻更新所带来的任何风险， 评估功能的有效性，并为新想法提供实实在在的测试基础。这其中可以包括在部署过程中（蓝绿部署）采用独立的环境并在它们之间进行负载平衡，使用两个不同的环境来测试用户交互（A/B 测试），或向少数用户推出更新并安全地增加用户数量 （金丝雀发布）。</p><h3 id="6、微服务（或分布式系统）"><a href="#6、微服务（或分布式系统）" class="headerlink" title="6、微服务（或分布式系统）"></a>6、微服务（或分布式系统）</h3><p>微服务是一种执行离散、功能单一的小型应用。整个应用架构可能需要执行数十个或数百个不同的功能，而且每一项功能都要在微服务中定义和编排。微服务架构（或任何分布式计算架构）既复杂又简单。单个服务更为简单，更易于维护、添加和停用，但总体架构却更为复杂。如果做法得当，“基于微服务的设计就会成为您所学优秀应用设计的最终体现”。这种高度分散型架构可以更轻松地进行扩展，更容易引入新的服务或更新，并且降低了系统范围故障的风险。</p><blockquote><p><strong>微服务是一种必需的状态吗？</strong></p><p>鉴于维护的复杂性，数字化演进的最后阶段是微服务。但是，企业演进的最后阶段一定要是微服务吗？</p><p>未必。</p><p>如果演进的其他方面都到位， 那么单体式架构仍可以每周发布一次，并使用高级部署技术、CI/CD 和分布式可扩展基础架构。只有在团队规模较大且需要比按周发布更快的速度，或需要按不同的时间表进行发布时，才应考虑微服务。小型团队或小型代码库不需要分解为微服务代码库。</p></blockquote><h2 id="五、文化改变是前提"><a href="#五、文化改变是前提" class="headerlink" title="五、文化改变是前提"></a>五、文化改变是前提</h2><p>DevOps 将紧急、全力以赴式的工作方法转变为在团队规划、开发、测试和部署中实现更平稳、 更可持续的迭代。这是 DevOps 团队在效率方面实现天文数字式增长的原因所在。</p><p>值得注意的关键点是达尔文（软件）进化过程不只是技术的改变。流程和人员的改变以及基础架构的改变交替发生，而文化的革新更是首当其冲。</p><blockquote><p>康威定律：“任何采用系统设计的企业，其设计结构最终都会不可避免地与该企业的沟通结构相一致。” 针对这方面，有两个彼此相关的解释：</p><ul><li>除非也改变沟通结构，否则单纯改变架构或基础架构不会带来任何改变。</li><li>无论基础架构如何，改变沟通结构都会带来流程和基础架构的改进。</li></ul></blockquote><p>Gartner 实际上有这方面的数据：“有 90% 尝试使用 DevOps 、但没有针对性地解决自身文化基础的企业会走向失败。”</p><p>DevOps 是一种文化的转变，努力打破开发人员、运维团队和业务利益相关者之间的隔阂。这种隔阂是真实存在的，但也是人为造成的。一个团队中可以不止包含工作职能相同的人员。 DevOps 试图重新定义团队，将应用生命周期中涉及的每个人员都纳入其中，并在这些团队之间实现有效沟通。</p><p>文化上的改变是所有技术和流程改变的基础。 如果您更改了沟通方式，结果也会随之而变。一些重大更改有时是从非常简单的步骤开始的。</p><p>无论您的最终应用架构是更完善的单体式应用还是分布式微服务，都需要改变团队结构和沟通方式。无论是在规划应用前还是在部署应用后，都必须确保沟通的顺畅。除非建立并启用支持开放式沟通和反馈的文化，否则按照不同的服务来划分团队很容易造成公司分化成一个个孤岛。</p><h2 id="六、应用架构设计：关注微服务"><a href="#六、应用架构设计：关注微服务" class="headerlink" title="六、应用架构设计：关注微服务"></a>六、应用架构设计：关注微服务</h2><h3 id="设计必要性、技术债务与策略选择"><a href="#设计必要性、技术债务与策略选择" class="headerlink" title="设计必要性、技术债务与策略选择"></a>设计必要性、技术债务与策略选择</h3><p>不知道该如何处理当前的应用，是企业变革的一大阻碍。这就是许多数字化转型计划考虑采用 “淘汰和替换”方法的原因之一；有些时候，重新开始似乎更容易。</p><p>但是，问题在于技术债务是设计的结果。在不清楚要替换什么的情况下拿掉一个应用，意味着同一个不被接受的架构最终还会再次出现。</p><p>您所开发的一切都是您的技术债务。对于非常新的应用，团队经常会在没有明确设计的情况下开始开发工作，这不一定是坏事。不过，也有观点认为，好的设计造就稳定发展，而没有设计则平淡无奇。</p><p><img src="https://pic.lixl.cn/2020/designStaminaGraph.gif" alt="Martin Fowler 设计持久力假设"></p><p>在开始规划架构之前，需要对战略重点和目标有非常清楚的了解。您必须确定客户或最终用户是谁，客户看重的是什么，期望的结果是什么，以及如何衡量成功。</p><ul><li>谁是您的客户或用户？</li><li>他们想要做什么？</li><li>您使用什么基础架构？</li><li>该基础架构生命周期有多长？</li><li>单个工作流有哪些服务或功能需求？</li><li>该工作流的生命周期有多长？</li><li>您的部署路径是什么？需要多久部署一次？</li><li>这会影响哪些业务功能？</li></ul><p>换句话说，不要一开始就想着如何完成某个任务或要使用哪种架构。要从战略目标开始，然后设计支持该目标的架构。</p><h3 id="微服务和单体式应用"><a href="#微服务和单体式应用" class="headerlink" title="微服务和单体式应用"></a>微服务和单体式应用</h3><p>简单来说，单体式应用就是在单个应用中包含所有功能的应用堆栈。无论是服务之间的交互还是开发与交付方式，都采用紧密耦合的形式。更新或扩展单体式应用的某个方面也会对整个应用及其基础架构产生影响。</p><p>单体式应用存在的潜在问题是动态扩展和故障转移。这些问题通常可通过简单的扩展性设计来加以解决，例如横向扩展（在集群中复制该功能）或纵向扩展（镜像实例和扩展硬件）。开发和运维团队也很少考虑可扩展性问题。如果需要一个完整的 50 人团队每 6 到 9 个月发布一个单体式应用，那么通过让五个独立的团队提供五个较小的应用并每隔几周发布一次更新，即可提高可扩展性。</p><p>考虑到最初的简单性以及服务与依赖项之间的清晰关系，单体式架构可能称得上是最古老的应用架构。该架构也更能反映有限的、基于商品的 IT 基础架构以及更严格的开发和发布流程。 由于单体式是一种较为陈旧的架构形式，因此它们常常与传统应用相关联。相比而言，更为现代化的架构则尝试按功能或业务能力来拆分服务，以带来更好的灵活性。这在面向客户的界面（如 API、移动应用或 Web 应用）中尤为常见。这些界面通常较小，需要更加频繁的更新才能满足客户的期望。</p><p>分布式架构的最新定义之一是微服务。与其他模块化设计，像面向服务的架构（SOA）有一些相似之处，但微服务将服务之间的松散耦合转变为服务独立性。通常，单个服务的定义较为明确，可以轻松地在较大的架构中添加、升级或删除服务。这对于动态可扩展性和容错能力都有一定的好处：可以在不占用大量基础架构的情况下按需扩展单个服务，或者可以在不影响其他服务的情况下进行故障转移。</p><p>哪种架构模式最为合适。下意识的反应是认为新的总是最好的，但重要的是应退后一步，评估什么最适合您想要的业务成果。Etsy 和 Netflix 的工程师就微服务持续部署和开发人员自主权的必要性在 Twitter 上展开了一场友好的辩论。Etsy 的工程师指出，他们拥有小规模、 基于功能的敏捷开发团队，可在运行单体式应用的情况下仍实现超快部署（每天约 60 次）。他们找到了一种适合自己和企业文化的系统。</p><p>对于企业而言，问题不在于我们能否用微服务来取代单体式架构，而在于我们的战略目标是什么，为了实现这一目标我们需要做些什么。了解沟通结构和文化、业务功能以及所需的工作流程之后，就会影响服务的耦合方式、服务的生命周期，以及最终的应用架构。</p><h3 id="有关分布式计算的错误见解"><a href="#有关分布式计算的错误见解" class="headerlink" title="有关分布式计算的错误见解"></a>有关分布式计算的错误见解</h3><p>必须要重视有关微服务的错误见解，原因很简单：没有任何系统是完美的。这么做的目的不是要找到解决问题的完美技术（或架构）。相反，专注于文化和沟通并不断完善流程将有助于创建一个成熟、有效的组织体系。在这个基础上，企业才有能力设计满足特定目标的有效架构。</p><h4 id="1、增加了成本和交易费用"><a href="#1、增加了成本和交易费用" class="headerlink" title="1、增加了成本和交易费用"></a>1、增加了成本和交易费用</h4><p>对于真正的分布式计算，所需的基础架构更改可能需要大量的费用。此外，还要涉及重新培训、 学习新技能、调整团队结构以及迁移系统等间接成本。当然，这部分费用将来会改善一些指标 （如上市时间和停机时间的缩短（如果有效实施了新架构）），但这些好处并非立竿见影。</p><h4 id="2、增加了复杂性"><a href="#2、增加了复杂性" class="headerlink" title="2、增加了复杂性"></a>2、增加了复杂性</h4><p>不像单体式架构那样只有单个（灾难性）故障点，微服务架构可能有数百个不同的潜在故障点。 与单体式架构类似，这些故障往往很难跟踪，因为根本原因可能并不那么明显。不过，微服务会增加额外的复杂性，因为服务之间的依赖性更不明显。 甚至更快的发布周期和更敏捷的团队结构也会增加复杂性。有效的沟通对于微服务而言至关重要。每个软件架构都要平衡内在的复杂性。这种复杂性可能隐藏在应用本身中（单体式架构）， 也可能融于团队沟通结构内（微服务）。</p><h4 id="3、系统化思维与设计"><a href="#3、系统化思维与设计" class="headerlink" title="3、系统化思维与设计"></a>3、系统化思维与设计</h4><p>要设计有效的微服务架构，需要缜密的系统化思维。您必须了解服务、业务功能与用户体验之间的相互影响。这种系统化思维还必须扩展到企业文化中的沟通结构和流程层面。Gartner 指出， 在不了解整个系统的情况下，微服务架构的性能与刻板的单体式架构非常像：“如果不采用统筹考虑软件架构、开发基础架构和开发流程的整体化方法，则无法提供最佳结果，会继续遭受单体式软件系统的诸多弊端所带来的切肤之痛。”</p><h4 id="4、资源限制"><a href="#4、资源限制" class="headerlink" title="4、资源限制"></a>4、资源限制</h4><p>鉴于在扩展方面存在的问题，单体式架构的资源限制是显而易见的。系统要么有足够的硬件容量来处理繁重服务上的峰值负载，从而导致不必要的容量冗余，要么就会面对没有足够的容量来处理高峰期的风险。 借助微服务，架构将变得灵活自如，并且由于各个服务的规模都非常小，因此很容易在轻量级的临时资源（例如容器或云实例）上扩展新服务。 因为给定服务的单个资源需求相对较少，所以有时可以忽略整个架构的独特资源需求，或将其压缩到最小。当然，这是基于以下假设：</p><ul><li>网络始终可靠。</li><li>无延迟。</li><li>无限带宽。</li><li>网络保持安全。</li><li>基础架构拓扑不会改变。</li><li>有一个管理员。</li><li>传输成本为零。</li><li>网络同构。</li></ul><h3 id="重新思考有意义的应用"><a href="#重新思考有意义的应用" class="headerlink" title="重新思考有意义的应用"></a>重新思考有意义的应用</h3><p>很多有关数字化转型的讨论都是集中在基础架构和文化上。鉴于它们属于基本要素，这样做是有道理的。但是，基础架构和文化毕竟是“方法”，它对应的“目的”是创建一个对用户有用、与企业相关的应用。</p><p>有意义的应用具有以下特征：</p><ul><li>可以响应用户</li><li>反映核心业务功能或商业目的</li><li>对环境的动态变化具有适应性或应变性</li><li>跨环境互联互通</li><li>轻便、灵活，可进行功能的添加和维护</li></ul><p>当某个应用满足以上这些特征时，它就是一个有意义的应用。单体式和微服务架构都可以反映这些特征。</p><h2 id="七、快速可靠的驱动技术"><a href="#七、快速可靠的驱动技术" class="headerlink" title="七、快速可靠的驱动技术"></a>七、快速可靠的驱动技术</h2><p>数字化转型的主要目标之一是加快应用发布速度。但是，速度只是效率的提高。要想实现转型， 速度还需要有一定的目的性⸺实现快速创新，交付新功能，以及检验新创意。</p><p>评估一个好创意的方法是进行全面、有效的测试，其中不仅包括代码质量，还包括用户体验和偏好。实践出真知。这正是持续交付和高级部署技术的目的。</p><p>CI/CD 是一个快速部署平台；部署技术则是进行实验和完善的工具。 这两个阶段背后则是文化的改变，即鼓励创新并支持失败和冒险。</p><h3 id="自助服务、自动化和-CI-CD"><a href="#自助服务、自动化和-CI-CD" class="headerlink" title="自助服务、自动化和 CI/CD"></a>自助服务、自动化和 CI/CD</h3><p>在数字化转型中，最初的重构举措之一就是转向采用小型动态团队并倡导相互沟通的 DevOps 文化。接下来是技术方面，旨在提供一个支持快速开发周期的基础架构。</p><p>这里有两个密切相关的技术阶段：</p><ul><li><p>弹性、自助服务式基础结构 ― <em>可以根据确切的规范近乎实时地请求和接收实例。</em></p></li><li><p>自动化或编排 ― <em>可以在整个环境中自动创建和管理多个实例。</em></p></li></ul><p>这些技术具有互补性：没有弹性环境，也就无法实现自动化；没有工具来确保一致性和可重复性，也就难以管理数百个实例。弹性基础架构既可以是云（公共云或私有云）、虚拟机，也可以是容器。自动化既可以是基础架构系统中的组件，也可以是外部工具（例如 Kubernetes）。</p><p>容器之所以与 CI/CD 如此密切相关，原因之一就是它们都可以提供严格且可重复的系统环境，这也意味着在完全不同的企业环境之间迁移时问题会更少。</p><p>这种一致性为 CI/CD 的第一部分（持续集成）奠定了良好的基础。借助持续集成，可以在每次检入时不断编译和构建开发中的变更，因而更容易暴露问题。这项工作通常与自动化测试套件结合在一起，用于验证稳定性或功能性。检入、构建和测试所构成的连续过程可确保代码的更高质量。</p><p>一旦持续集成投入运行，企业即可实现持续部署，从而更快地将变更转化为生产。这种速度的提升既有利于开发人员，也有利于运维团队。</p><p>对于庞大的单体式架构（采用完善的流程和技术，以及更传统的应用架构），可以每周发布一次，且进行一次性整体更新，此时对敏捷冲刺流程的要求构成了唯一的约束条件。对于微服务，由于任何服务都可以进行更新，而且冲刺周期可以重叠，因此可以每天对整个架构进行更新。</p><h3 id="高级部署和创新"><a href="#高级部署和创新" class="headerlink" title="高级部署和创新"></a>高级部署和创新</h3><h4 id="用于实验的应用基础架构"><a href="#用于实验的应用基础架构" class="headerlink" title="用于实验的应用基础架构"></a>用于实验的应用基础架构</h4><p>多语言编程代表了敏捷开发环境的核心需求之一。创建实验用平台时，必须考虑开发环境的灵活性和有关的选项。实验用环境必须支持：</p><ul><li>多种语言。</li><li>多个运行时。</li><li>灵活的部署环境。<em>例如云环境、物理环境或混合环境。</em></li><li>灵活或可变的应用架构。<em>让应用可在整个生命周期中适应环境的变化。</em></li><li>开放标准，或实现迭代标准化的能力。</li></ul><p>容器就是这种支持的一个范例。</p><h4 id="创新的部署模式"><a href="#创新的部署模式" class="headerlink" title="创新的部署模式"></a>创新的部署模式</h4><p>先进的部署技术能在结构和透明度方面实现创新。成熟的部署方法能够构建一个真正实现实验、 反馈和分析的环境。更好的实验有助于实现更好的创新。</p><p>这些是常见的部署模式。任何一种方法或全部方法都可能适用，具体取决于您的应用和用户环境的性质。</p><h5 id="蓝绿环境"><a href="#蓝绿环境" class="headerlink" title="蓝绿环境"></a>蓝绿环境</h5><p>蓝绿环境是缓解因推广更改而带来的风险的一种方法。新的构建版本会穿过 CI/CD 管道中的所有环境。对于生产而言，有两个相同的环境（蓝和绿），但只有一个处于活动状态。所做的更改会被推广至生产中的空闲环境。然后，待环境完成验证后，将会切换路由并将流量移至已更新的环境。</p><p><img src="https://pic.lixl.cn/2020/image-20200324103924321.png" alt="蓝绿部署管道"></p><h5 id="金丝雀发布（Canary-releases）"><a href="#金丝雀发布（Canary-releases）" class="headerlink" title="金丝雀发布（Canary releases）"></a>金丝雀发布（Canary releases）</h5><p>金丝雀发布与蓝绿部署类似，不同之处在于其初始发布只针对环境中的部分用户。随着从用户那里不断收集反馈，可以逐渐增加人数，直到最终切换至所有用户为止。</p><p>这可以用作测试技术的一部分，以针对当前生产环境中的一小部分用户，借助实际的流量和使用模式来评估应用的不同功能或设计。</p><h5 id="A-B-测试"><a href="#A-B-测试" class="headerlink" title="A/B 测试**"></a>A/B 测试**</h5><p>A/B 测试将向用户展示两种不同的设计，然后根据所需的指标来评估哪种设计效果更好。既可以直接让用户对自己的体验进行评分或提供反馈，也可以用更加不易察觉的方式完成。例如，将 A/B 测试与金丝雀发布结合在一起，可以对比两种潜在的设计甚至隐藏的功能，然后以当前环境为基准评估用户对不同设计的反应。</p><p>如同金丝雀发布一样，一旦给出的设计取得成功，就可以将它发布到更大的环境中。如果一切进展顺利，还可以将生产环境转变为实验环境，这样团队在设计中就会更具创新性和关联性。</p><p>这种测试正是“数据胜过直觉”的核心所在。</p><h2 id="八、如何教大象跳舞"><a href="#八、如何教大象跳舞" class="headerlink" title="八、如何教大象跳舞"></a>八、如何教大象跳舞</h2><h3 id="1、选择现有阶段"><a href="#1、选择现有阶段" class="headerlink" title="1、选择现有阶段"></a>1、选择现有阶段</h3><p>在更传统的瀑布式环境与完全分布式的微服务之间，有很多阶段。因为数字化转型的目标是让文化、流程、架构和技术发生显著改变。这就意味着您要了解这种变更所要实现的目标，然后清楚地评估实现该目标所需的条件。请思考几个问题：</p><ul><li>您当前有哪些团队或小组？</li><li>这些小组之间采用什么沟通方式？</li><li>规划周期内目前涉及哪些人？</li><li>从功能角度看，当前应用架构与目标应用架构之间有多大差距？</li><li>您的企业对风险或失败的容忍度有多高？</li><li>对自己材料和信息流的了解程度如何？（这是企业价值的体现。）</li><li>您需要多久发布一次更新，以满足客户或运营需求？</li><li>业务目标或开发需求需要哪些新功能？</li></ul><h3 id="2、制定操作规则"><a href="#2、制定操作规则" class="headerlink" title="2、制定操作规则"></a>2、制定操作规则</h3><p>文化的改变是企业针对数字化转型所做的所有流程、技术或架构改变的基础。 尽管道理浅显易懂，但制定一系列得到管理层和不同团队支持的核心规则确实有助于强化数字化转型计划并统一队伍。</p><p>这些规则可能比较简单，但保持清晰明了的态度和行为却大有用处，而这些对于文化的改变而言最为重要，尤其是在其中一些态度或行为（例如鼓励冒险和实验）与当前文化背道而驰的情况下。例如：</p><ul><li>失败不可避免</li><li>要敢于实验</li><li>企业（人员）优先</li><li>追求持续改进</li><li>终身学习</li><li>始终负责</li><li>保持透明</li></ul><h3 id="3、告别庞然大物"><a href="#3、告别庞然大物" class="headerlink" title="3、告别庞然大物"></a>3、告别庞然大物</h3><p>数字化转型会影响您当前的应用和架构。如果您现在采用的是单体式应用，则有两种相关的方法可以开始解决该技术债务：</p><ul><li>在需要更新或替换时，中断现有服务（strangling）。</li><li>在另外的独立服务中创建新功能（starving）。</li></ul><p>这些都不需要全面采用微服务。Gartner 建议将这种渐进式方法应用于分布式架构，因为它“迭代的同时专注于价值领域”。</p><p>无论企业数字化演进的最后阶段是什么，所选择的方法都应涵盖三个基本方面：</p><ul><li>架构设计的敏捷性。</li><li>实验性。</li><li>自动化。</li></ul><h4 id="实现敏捷性设计架构"><a href="#实现敏捷性设计架构" class="headerlink" title="实现敏捷性设计架构"></a>实现敏捷性设计架构</h4><p>无论您的侧重点是简化流程以改进单体式架构的性能还是创建微服务，架构基础都必须具有敏捷性。通常，敏捷就意味着混合。</p><p>Gartner 建议新项目以单体式架构开始，待成熟后再推出微服务。Gartner 研究得出的结论：先采用单体式架构的方法可以降低风险、提高初始生产率，并确保将应用分离和分解为正确的微服务集。”</p><p>请认真阅读 Martin Fowler 的 <a href="https://martinfowler.com/bliki/DesignStaminaHypothesis.html" target="_blank" rel="noopener">DesignStaminaHypothesis</a>，创建一个侧重于清晰性和简易性的开发流程。代码应做到易于理解。功能和用途要明确。随着应用不断成熟，就可以将其发展成更具分布特性的架构形式。拥有良好的开发和部署流程会让这一途径保持敏捷。</p><h4 id="预留试验用的时间和预算"><a href="#预留试验用的时间和预算" class="headerlink" title="预留试验用的时间和预算"></a>预留试验用的时间和预算</h4><p>必须要留出试验新技术和应用功能的预算空间。技术本身并不是目标，但是，数字化战略目标经常需要技术变革作为支撑。缩短服务上市时间可能需要移至容器。 还要预留资源，让开发人员和运维团队可以识别有用的技术并培养相关的技能，以支持最终部署的任何基础架构。</p><h4 id="一切皆自动化"><a href="#一切皆自动化" class="headerlink" title="一切皆自动化"></a>一切皆自动化</h4><p>自动化主要有两个明显的优势：通过消除手动步骤来提高效率，以及内在的一致性和可重复性。实现每个开发（开始时）和部署（随着流程不断成熟）步骤的自动化，也就是可就每个步骤的改变以及在利益相关者从开发向运营再向客户转换时为您的团队提供反馈回路。这种方法提高了整体代码质量。</p><p>第一步，为企业的当前状态设置一条基线，以将其纳入自动化策略。接下来的步骤包括：</p><ul><li>定义相关指标。</li><li>可视化或图解当前的工作流。</li><li>确定不同步骤的主要参与者。</li></ul><h2 id="九、总结"><a href="#九、总结" class="headerlink" title="九、总结"></a>九、总结</h2><p>长期以来，企业应用往往会演变成死板僵化的庞然大物⸺不够透明、更新起来繁琐，且迟迟无法纳入新的功能。然而，这些企业应用同时也提供了开展业务和实现创收的核心功能。这就像是房间里的大象。</p><p>只要对最终状态有明确的认识，就可以将那头大象训练得敏捷并且具备转变能力。数字化转型是个进化过程，没有一种所谓理想的结果，每条演变路径都反映了企业本身的独特意图和个性。</p><p>评估数字化演进的每个阶段：DevOps、自助服务或弹性环境、自动化、CI/CD 管道、高级部署和微服务。围绕最能满足您业务需求的进化阶段，构建自己的数字化转型策略。</p><p>聚焦于打造文化，并在技术变更与相应的流程变更之间取得平衡，以确保您的技术得到团队的全力支持。</p><p>随着流程不断成熟，开始评估您的应用和架构。必要时，隔离或开发独立的服务，并创建可以随着业务优先级变化或出现而调整的敏捷架构。</p><p>最后，培养创新能力。这意味着对风险和失败要有一定的容忍度（在业务目标和客户需求的范围内）。这就要求架构规范在时间、成本和基础架构方面预留出一定资源。</p><p>试验是创新的根本，也为数字化转型的成功提供了更好的机会。此外，试验也让人们重拾最初的喜悦，正是这些喜悦吸引着众多开发人员和运维人员热爱技术， 从事创造性工作并见证创新的产生。</p><h2 id="十、参考"><a href="#十、参考" class="headerlink" title="十、参考"></a>十、参考</h2><ul><li><a href="https://www.redhat.com/cms/managed-files/mi-middleware-teaching-elephant-to-dance-ebook-f8980kc-201709-a4-zh.pdf" target="_blank" rel="noopener">教大象跳舞</a></li><li><a href="http://highscalability.com/blog/2014/7/28/the-great-microservices-vs-monolithic-apps-twitter-melee.html" target="_blank" rel="noopener">卓越的微服务与单体式应用 Twitter Melee</a></li><li><a href="https://martinfowler.com/bliki/DesignStaminaHypothesis.html" target="_blank" rel="noopener">Design stamina hypothesis</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术管理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数字化转型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>云原生（Cloud Native）应用开发，助力企业数字化转型</title>
      <link href="/2020/03214710.html"/>
      <url>/2020/03214710.html</url>
      
        <content type="html"><![CDATA[<h2 id="一、简述"><a href="#一、简述" class="headerlink" title="一、简述"></a>一、简述</h2><p>要在快节奏的软件驱动型市场中取得成功，公司必须改变他们设计、构建和使用应用的方式。应用的快速开发和交付已成为数字化企业必须要满足的一项新需求。</p><p>云原生应用开发是根据众所周知的云计算技巧与技术构建、运行和改进应用的一种方法。基于云技术原理，利用相关服务，并采用为实现云计算敏捷性和自动化而过优化的各种流程，从而完成现有应用的现代化转型并构建新的应用。</p><h2 id="二、什么是云原生应用"><a href="#二、什么是云原生应用" class="headerlink" title="二、什么是云原生应用"></a>二、什么是云原生应用</h2><p>云原生应用旨在充分利用云计算模型，从而提高速度、灵活性和质量并降低部署风险。虽然名字中包含“云原生”三字，但云原生方案的重点并不是应用部署在何处，而是如何构建、部署和管理应用。</p><p>云原生方案与微服务架构类似。然而，尽管微服务可通过构建云原生应用来交付，可企业仍需采取许多措施，才能在生产中熟练地管理微服务。而要想享受云原生应用的各种益处，也并非一定需要微服务。很多企业都通过基于相同的原则，构建出更优秀的模块化单体式应用，从而取得云原生方案的种种效益。</p><p>向云原生应用的开发和交付转型，是一次全方位的变革，涉及企业的文化、流程、架构和技术。因此，这是企业的必经之路，而不是所要到达的目标。这段旅程代表着一个变革周期，而实现变革从来不是一件容易的事。</p><h2 id="三、传统应用开发与云原生应用"><a href="#三、传统应用开发与云原生应用" class="headerlink" title="三、传统应用开发与云原生应用"></a>三、传统应用开发与云原生应用</h2><p>云原生应用开发与传统应用开发之间的差别，充分彰显了变革的必要性。</p><p><strong>表 1. 传统应用开发与云原生应用开发</strong></p><table><thead><tr><th></th><th>传统</th><th>云原生</th></tr></thead><tbody><tr><td>重点关注</td><td>使用寿命和稳定性</td><td>上市速度</td></tr><tr><td>开发方法</td><td>瀑布式半敏捷型开发</td><td>敏捷开发、DevOps</td></tr><tr><td>团队</td><td>相互独立的开发、运维、质量保证和 安全团队</td><td>协作式 DevOps 团队</td></tr><tr><td>交付周期</td><td>长</td><td>短且持续</td></tr><tr><td>应用架构</td><td>紧密耦合<br />单体式</td><td>松散耦合<br />基于服务<br />基于应用编程接口（API）的通信</td></tr><tr><td>基础架构</td><td>以服务器为中心<br />适用于企业内部<br />依赖于基础架构<br />纵向扩展<br />针对峰值容量预先进行置备</td><td>以容器为中心<br />适用于企业内部和云环境<br />可跨基础架构进行移植<br />横向扩展<br />按需提供容量</td></tr></tbody></table><br />由于云原生应用非常注重上市速度，因此，在开发时需要实施更加敏捷且基于服务和 API 的方案和持续交付策略。而这些方案能否成功实施又取决于以下几点：<ul><li>开发和交付团队间的 DevOps 协 作；</li><li>模块化程度更高的架构；</li><li>能够按需横向扩展、</li><li>支持多种环境并实现应用可移植性的灵活基础 架构。</li></ul><p>在利用现代化云技术实现灵活性和敏捷性后，企业会想将传统应用迁移到云环境中，以便进一步提高敏捷性，并充分利用按需提供的计算容量。</p><p>但是，传统平台中内置的很多运维功能，要么对于云环境而言早已过时，要么云环境本身就会提供并实施这些功能。云环境不但能简化主机的生命周期管理，还能帮助企业充分利用不变的基础架构原则，并对主机进行精调以满足单个应用实例的需求。</p><p>每个企业的云原生应用的构建之路可能都不尽相同。仅凭创建微服务无法实现数字化业务所需的服务质量和交付频率。同样地，仅凭采用支持敏捷开发或 IT 自动化的工具也无法加快云原生方案的速度。要想取得成功，企业必须综合考虑相关的实践、技术、流程和理念。</p><h2 id="四、云原生应用生态"><a href="#四、云原生应用生态" class="headerlink" title="四、云原生应用生态"></a>四、云原生应用生态</h2><p>CNCF，全称Cloud Native Computing Foundation（云原生计算基金会），口号是<strong>坚持和整合开源技术来编排容器作为微服务架构的一部分</strong>，其作为致力于云原生应用推广和普及的一支重要力量，不论您是云原生应用的开发者、管理者还是研究人员都有必要了解。</p><p>CNCF 维护了一幅CNCF的全景图:</p><p><img src="https://landscape.cncf.io/images/landscape.png" alt=""></p><h2 id="五、云原生应用的12要素"><a href="#五、云原生应用的12要素" class="headerlink" title="五、云原生应用的12要素"></a>五、云原生应用的12要素</h2><h2 id="六、云原生应用开发-amp-部署原则"><a href="#六、云原生应用开发-amp-部署原则" class="headerlink" title="六、云原生应用开发&amp;部署原则"></a>六、云原生应用开发&amp;部署原则</h2><p>云原生应用开发所构建和运行的应用，旨在充分利用基于四大原则的云计算模型：基于服务的架构、基于 API 的通信、基于容器的基础架构以及 DevOps 流程。</p><p><img src="https://pic.lixl.cn/2020/image-20200321104115727.png" alt="云原生应用开发和部署的四大原则"></p><h3 id="1、基于服务的架构"><a href="#1、基于服务的架构" class="headerlink" title="1、基于服务的架构"></a>1、基于服务的架构</h3><p>基于服务的架构（如微服务）提倡构建松散耦合的模块化服务。其他模块化架构 方案（如迷你服务）采用基于服务的松散耦合设计，可帮助企业提高应用创建速 度，但不会增加复杂性。</p><h3 id="2、基于-API-的通信"><a href="#2、基于-API-的通信" class="headerlink" title="2、基于 API 的通信"></a>2、基于 API 的通信</h3><p>服务通过与技术无关的轻量级 API 来提供，这些 API 可以降低与部署、可扩展性和维护相关的复杂性和费用。企业可以通过所提供的 API 在内部和外部创建新的功能，创造新的商机。</p><p>采用基于 API 的设计时，只能在网上通过调用服务接口来通信，这样可避免因直接链接、共享内存模型或直接读取其他团队的数据存储而带来的风险。这种设计能让应用和服务延伸到不同的设备、拓展出不同的形式。</p><h3 id="3、基于容器的基础架构"><a href="#3、基于容器的基础架构" class="headerlink" title="3、基于容器的基础架构"></a>3、基于容器的基础架构</h3><p>云原生应用依靠容器来构建跨技术环境的通用运行模型，并在不同的环境和基础架构（包括公共、私有和混合云）间实现真正的应用可移植性。容器技术会利用操作系统虚拟化功能来划分多个应用的可用计算资源，并确保这些应用安全无虞、相互独立。</p><p>云原生应用采用横向扩展模式，因此，只需添加更多应用实例，即可增加容量， 而且这样的添加常通过容器基础架构中的自动化功能来实现。</p><p>由于容器的费用低、密度高，因而可在同一虚拟机或物理服务器内托管大量容器， 这使得容器成了交付云原生应用的理想之选。</p><h3 id="4、DevOps-流程"><a href="#4、DevOps-流程" class="headerlink" title="4、DevOps 流程"></a>4、DevOps 流程</h3><p>采用云原生方案时，企业会使用敏捷的方法，依据持续交付和 DevOps 原则来开发应用，这些方法和原则要求开发、质量保证、安全、IT 运维团队以及交付过程中所涉及的其他团队以协作方式构建和交付应用。</p><h2 id="六、八步法构建云原生应用"><a href="#六、八步法构建云原生应用" class="headerlink" title="六、八步法构建云原生应用"></a>六、八步法构建云原生应用</h2><h3 id="1、发展-DEVOPS-文化和实践"><a href="#1、发展-DEVOPS-文化和实践" class="headerlink" title="1、发展 DEVOPS 文化和实践"></a>1、发展 DEVOPS 文化和实践</h3><p>要完成云原生应用的构建之路，开发和 IT 运维团队必须进行多方面的变革，以便更加快速高效地构建和部署应用。要想充分利用新技术，采用更加快速的方案，实现更为密切的合作，企业必须切实遵循 DevOps 的原则和文化价值，并围绕这些价值来进行 组织和规划。</p><p>DevOps 文化的推行不仅要靠工具和技术，也取决于员工是否愿意和信任用集成度和协作度更高的方案来开发和交付应用。企业可以把开源软件项目的文化作为参考，来构建 DevOps 文化。</p><p>倡导大胆尝试、迅速纠误、提升决策透明度，并通过表扬和奖励来促进团队间的相互信任和紧密协作，有助于引导企业完成 DevOps 之旅。</p><p><img src="https://pic.lixl.cn/2020/image-20200321110712585.png" alt="开源文化推动开放创新"></p><p><strong>进一步了解：</strong> <a href="https://www.redhat.com/zh/resources/open-innovation-labs-ebook" target="_blank" rel="noopener">红帽开放创新实验室如何帮助您完成 DevOps 之旅</a></p><h3 id="2、为现有单体应用提速"><a href="#2、为现有单体应用提速" class="headerlink" title="2、为现有单体应用提速"></a>2、为现有单体应用提速</h3><p>组织不能抛弃现有的单体应用程序，这些应用程序这些年来一直在有效地运行其业务。该如何加快现有单体式应用的运行速度？正确的方法是：将您现有的单体式架构迁移到模 块化程度更高、且基于服务的架构中，并采用基于 API 的通信方式，从而实施快速单体式方案。</p><p>在开始实施将单体式应用重构为微服务的艰巨任务前，您可以通过将这些现有应用程序迁移到基于容器的现代平台来加快速度，这不仅可以提高自动化程度，而且可以提高开发速度。然后，您可以识别可使用 API 公开的单体应用程序组件。</p><h3 id="3、使用中间件来加速"><a href="#3、使用中间件来加速" class="headerlink" title="3、使用中间件来加速"></a>3、使用中间件来加速</h3><p>可重用性一直是加快软件开发速度的关键，云原生应用程序也不例外。当您可以使用已优化并集成到基于基础容器的现有服务时，为什么要重新创建如缓存服务，规则或工作流引擎或无服务器框架等基础设施？这些应用程序服务，无论是软件即服务（SaaS），平台即服务（PaaS）还是 iPaaS 产品，都是有效的即用型开发人员工具。将这些可重用组件用于云原生应用程序，最好是已被优化并集成到底层云原生基础架构中的组件，以充分发挥它们的价值。</p><h3 id="4、选择正确的工具"><a href="#4、选择正确的工具" class="headerlink" title="4、选择正确的工具"></a>4、选择正确的工具</h3><p>组织正在从各种运行时和框架中选择最佳工具来解决特定任务。随着语言或框架的选择越来越适合特定的业务应用程序需求，构建云原生应用程序变得越来越多样化。随之而来的复杂性增加值得使用基于容器的应用程序平台，该平台支持框架，语言和体系结构的正确组合，以支持云原生开发。有许多技术和框架可以实现云原生应用程序，例如 Quarkus，Spring Boot，Eclipse MicroProfile，Eclipse Vert.x，DropWizard，Python，Apache OpenWhisk，Node.js，Golang 和 Jakarta EE。根据您要解决的问题，选择最能帮助您解决问题的工具/框架。</p><h3 id="5、构建自助式按需基础架构"><a href="#5、构建自助式按需基础架构" class="headerlink" title="5、构建自助式按需基础架构"></a>5、构建自助式按需基础架构</h3><p>通过自助式地按需置备基础架构，开发人员可以在需要时访问所需的基础架构。</p><p>容器和容器编排技术抽象并简化了对于底层基础架构的访问，并可针对各种基础架构环境（如数据中心、私有云和公共云）进行有效的应用生命周期管理。容器平台还可提供额外的自助服务、自动化和应用生命周期管理功能。该模式使开发人员和运维团队能够快速启用一致的环境，帮助开发人员专注于构建应用，而不会困于与置备基础架构相关的障碍和延迟。</p><p>标准化也是自助模式的要素之一。它有助于企业以一致的方式实现自动化和交付，达成业务目标。容器还有助于实现应用可移植性，包括创建可部署和运行于任何云提供商的云原生应用。</p><p><strong>进一步了解：</strong><a href="https://rht-labs.github.io/practice-library/" target="_blank" rel="noopener">详细了解有助于开启云原生之旅的不同实践和技术</a></p><h3 id="6、通过-IT-自动化加速应用交付"><a href="#6、通过-IT-自动化加速应用交付" class="headerlink" title="6、通过 IT 自动化加速应用交付"></a>6、通过 IT 自动化加速应用交付</h3><p>避免手动执行 IT 任务，是加速交付云原生应用的重点，而实现 IT 或基础架构自动化就是其中的关键所在。从网络和基础架构置备，到应用部署和配置管理，自动化可以整合并应用于任何任务 或组件。</p><p>IT 管理和自动化工具会创建可重复的流程、规则和框架，以替代或减少会延迟上市的劳动密集型人工介入。 这些工具可以进一步延伸到具体的技术（如容器）、方法（如 DevOps），再到更广泛的领域（如云计算、安全性、测试、监控和警报）。因此，自动化是 IT 优化和数字化转型的关键，可以缩短实现价值所需的总时长。</p><p><strong>进一步了解：</strong><a href="https://www.redhat.com/zh/engage/automated-enterprise-ebook-20171115" target="_blank" rel="noopener">自动化企业</a></p><h3 id="7、实施持续交付和高级部署技术"><a href="#7、实施持续交付和高级部署技术" class="headerlink" title="7、实施持续交付和高级部署技术"></a>7、实施持续交付和高级部署技术</h3><p>敏捷开发方法经过不断演变，形成了“早发布，常发布”模式。DevOps 和持续交付方案通过密切联合开发人员、运维、质量保证和安全团队，扩展了这些方法的应用领域，从而改善了软件的交付流程。因此，代码的变动可以快速可靠地推送至生产环境，为开发人员提供快速反馈。这种迭代式快速反馈循环借助 CI/CD 实现， 可将基础架构自动化扩展到端到端自动交付系统，从而涵盖应用 交付的方方面面，包括自动化测试、漏洞扫描、安全合规性和法规检查。自动化交付管道旨在不影响运维能力的情况下提供更新，同时降低交付风险。</p><p>要实现持续交付（CD），首先要实现持续集成（CI）。CI 系统是一组 Build 系统，它们可以监控各种源代码控制存储库的变更情况，运行任何适用的测试，并通过每个源代码控制变更自动构建最新的应用版本，如 Jenkins。</p><p>高级部署模式旨在降低与软件发布相关的风险，构建结果受控且不会对客户造成意外负面影响的 实验环境。该目标对于推动整个企业不断创新至关重要。</p><p>通过消除新部署对客户造成的不便，这些技术使企业能够按照业务所需的频率来交付更新和发布版本。以下是一些可用于实现零停机部署的常用部署技术，具体技术根据用例而定：</p><p><strong>滚动部署</strong>模式不会一次更新应用的所有实例，它会依次将各个实例从负载均衡器中排除，使其无法接收流量，然后再单独更新各个实例。实例更新后，会再次纳入负载均衡器中。此流程会持续进行，直到所有实例都已更新。</p><p><strong>蓝/绿部署</strong>描述的是运行两个相同环境的做法：一个环境处于活动状态，而另一个处于空闲状态。 所做的更改会被推广至空闲环境；然后，待更改在生产中完成验证后，实时流量会切换到已更新的环境。回滚到先前版本就像切换回流量一样简单，但前提是得考虑数据的传输。</p><p><strong>金丝雀发布</strong>类似于蓝/绿部署，需使用两个相同的环境。但是，它的不同之处在于发布的控制方式。 部署新版本后，会向一小部分客户发送新版本，供其在生产中进行测试。如新版本验证成功，则流量会逐渐转移到新版本，同时监控并验证结果，直到向所有用户发送完新版本。</p><p><strong>A/B 测试</strong>将向用户展示两种不同的设计，然后根据所需的指标来评估哪种设计效果更好。既可以直接让用户对自己的体验进行评分或提供反馈，也可以用更加不易察觉的方式完成。例如，将 A/B 测试与金丝雀发布结合在一起，可以对比两种潜在的设计甚至隐藏的功能，然后以当前环境为基准评估用户对不同设计的反应。</p><p>进一步了解：<a href="https://www.redhat.com/cms/managed-files/mi-middleware-teaching-elephant-to-dance-ebook-f8980kc-201709-a4-zh.pdf" target="_blank" rel="noopener">教大象跳舞 — 跨团队、流程和应用的主动变革</a></p><h3 id="8、演进更具模块化的架构"><a href="#8、演进更具模块化的架构" class="headerlink" title="8、演进更具模块化的架构"></a>8、演进更具模块化的架构</h3><p>有许多方法可以演化出更具模块化的体系结构。在微服务体系结构编写软件的方法中，应用程序分解为彼此独立的最小组件。微服务架构非常适合构建云原生应用程序，因为它们满足了云原生应用程序开发的关注焦点，即基于服务和基于 API 的原则。</p><p>但是，微服务架构不容易实现或维护。因此，分析师和主题专家建议对微服务采用 <a href="https://martinfowler.com/bliki/MonolithFirst.html" target="_blank" rel="noopener">MonolithFirst</a> 方案，即要先构建一个单体式应用，就算您想创建的是微服务架构。这么做的目的是：先充分理解您的应用所属的域，然后更好地识别其所含的有限上下文——这些上下文将作为转换成微服务的候选内容。这样做，有助于避免技术债务，比如还没有了解应用的所属域和有限上下文就构建一组微服务，由此产生的修复成本。</p><p>微服务的另一种替代方案是迷你服务。迷你服务是按域划分的多个服务的集合，通常在应用服务器上运行。迷你服务可以提高敏捷性并进行扩展，而无需担心基于微服务的设计和基础架构所带来的复杂性问题。</p><h2 id="七、云原生应用业务场景及方案"><a href="#七、云原生应用业务场景及方案" class="headerlink" title="七、云原生应用业务场景及方案"></a>七、云原生应用业务场景及方案</h2><p>在实现数字化转型时，各个企业都有不同的优先事务。有些企业会遵循现代化的云原生原则，使其现有的应用架构和基础架构实现现代化转型，而有些企业会利用全新的业务模式和应用来实现创新。无论具体的意图和业务场景如何，这些企业的目标都是提高速度和灵活性，并为数字化转型做好准备。</p><p>云原生应用的常见场景大致可根据以下四项业务挑战进行分类：</p><h3 id="1、加速应用交付"><a href="#1、加速应用交付" class="headerlink" title="1、加速应用交付"></a>1、加速应用交付</h3><p><strong>目标：</strong> 加快向客户交付现有应用和新应用的速度。</p><p><strong>方案：</strong> 容器可以提供一个通用平台，使开发、运维、安全性、质量保证和其他团队联合起来，一同采用独立 于基础架构和应用技术的 DevOps。借助 DevOps 方案，团队可以采用自动化及 CI/CD 实践来快速、 放心地发布软件。利用基于容器的自动化功能解决部署问题后，可以缩短应用的交付周期，并使其 适应业务的发展步伐，而不是根据 IT 部门所能交付的内容来调整业务的发展步伐。</p><h3 id="2、对现有应用进行现代化改造"><a href="#2、对现有应用进行现代化改造" class="headerlink" title="2、对现有应用进行现代化改造"></a>2、对现有应用进行现代化改造</h3><p><strong>目标：</strong> 对现有应用进行现代化改造，以满足市场和客户需求，从而加速实现变革。</p><p><strong>方案：</strong> 许多产生价值的业务应用都是传统应用，其设计年代可能远早于数字时代。但是，直接淘汰换新不一定就是最优对策，至少在经济层面上并不可行。此外，也并非所有的传统应用都能现代化。</p><p>如果将传统应用迁移至云环境行得通，容器就可以为其提供相应的支持，消除对于底层基础架构的依赖性。这样，应用就能从企业内部基础架构移植到云端；如果需要，还可以对应用进行重构和重新架构，以实现云原生。容器平台方案还可利用平台的自动化功能和 DevOps 实践来简化现有应用的迁移。</p><h3 id="3、开发新的云原生应用"><a href="#3、开发新的云原生应用" class="headerlink" title="3、开发新的云原生应用"></a>3、开发新的云原生应用</h3><p><strong>目标：</strong> 加快新应用的开发速度，把握各种新商机。</p><p><strong>方案：</strong> 如果企业能将理念快速转化为服务和产品、快速评估它们在新领域中所取得的业务成果，然后再进行快速的调整，那么不断变化的业务和客户需求将为企业带来巨大的商机。集基于服务的架构、 API 整合、容器化服务和编排以及各种 DevOps 实践、自动化功能和工具的强大支持于一身，旨在构建新应用的云原生方案可以加速从理念到创新应用的转化过程。</p><h3 id="4、推动业务创新"><a href="#4、推动业务创新" class="headerlink" title="4、推动业务创新"></a>4、推动业务创新</h3><p><strong>目标：</strong> 加快整个企业的创新速度，以满足不断变化的业务需求。</p><p><strong>方案：</strong> 面对日新月异的世界，停滞不前就意味着落后。IT 团队正在你追我赶，力图快速推出各种新功能和服务，让客户满意并帮助员工更智能地工作。成功取决于不断创新，而不仅仅依赖于新的工具和技 术。要想取得成功，需要推行变革性的新文化、新工具和新流程，以便于在整个企业内实现创新和开展实验。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://www.redhat.com/zh/engage/cloud-native-application-development-20180622" target="_blank" rel="noopener">云原生应用的构建之路</a></li><li><a href="http://highscalability.com/blog/2014/7/28/the-great-microservices-vs-monolithic-apps-twitter-melee.html" target="_blank" rel="noopener">卓越的微服务与单体式应用 Twitter Melee</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 软件设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Cloud Native </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>附录2、Dockerfile 参考及最佳实践</title>
      <link href="/2020/030233344.html"/>
      <url>/2020/030233344.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文是《<a href="https://www.lixl.cn/books/Docker/1-Overview/">Docker必知必会系列</a>》第十篇，原文发布于个人博客：<a href="https://www.lixl.cn/">悟尘记</a>。</p><p>上一篇：<a href="https://www.lixl.cn/books/Docker/appendix1-docker-command/">Docker必知必会系列（附录1）：Docker 常用命令及示例</a></p></blockquote><h2 id="一、Dockerfile-简介"><a href="#一、Dockerfile-简介" class="headerlink" title="一、Dockerfile 简介"></a>一、Dockerfile 简介</h2><p>Dockfile 是一种被 Docker 程序解释的脚本，由一条一条的指令组成，每条指令对应 Linux 下面的一条命令。</p><p>Docker 通过从<code>Dockerfile</code>文本文件中读取指令来自动构建镜像，该文本文件按顺序包含构建镜像所需的所有命令。遵循特定的格式和指令集，您可以在 <a href="https://docs.docker.com/engine/reference/builder/" target="_blank" rel="noopener">Dockerfile 参考</a> 中找到详细信息。</p><p>Docker 镜像由只读层组成，每个只读层代表一个 Dockerfile 指令。各个层堆叠在一起，每个层都是上一层变化的增量。运行镜像并生成容器时，可以在基础层之上添加一个新的可写层（“容器层”）。对运行中容器所做的所有更改（例如写入新文件，修改现有文件和删除文件）都将写入到此可写容器层。</p><h2 id="二、Dockerfile-编写建议"><a href="#二、Dockerfile-编写建议" class="headerlink" title="二、Dockerfile 编写建议"></a>二、Dockerfile 编写建议</h2><p>Dockerfile 的指令是忽略大小写的，建议使用大写，使用<code>#</code>作为注释，每一行只支持一条指令，每条指令可以携带多个参数。Dockerfile 常用指令：</p><table><thead><tr><th>类型</th><th>命令</th></tr></thead><tbody><tr><td>基础镜像信息</td><td>FROM</td></tr><tr><td>维护者信息</td><td>MAINTAINER</td></tr><tr><td>镜像操作指令</td><td>RUN、COPY、ADD、EXPOSE、WORKDIR、ONBUILD、USER、VOLUME 等</td></tr><tr><td>容器启动时执行指令</td><td>CMD、ENTRYPOINT</td></tr></tbody></table><p>下面针对 <code>Dockerfile</code> 中各种指令的最佳编写方式给出建议。</p><h3 id="FROM（指定基础镜像）"><a href="#FROM（指定基础镜像）" class="headerlink" title="FROM（指定基础镜像）"></a>FROM（指定基础镜像）</h3><p>该指令有两种格式：使用 <code>FROM &lt;image&gt;</code> 指定基础镜像为该 image 的最后修改版本。或者实使用 <code>FROM &lt;image&gt;:&lt;tag&gt;</code> 指定基础 image 为该 image 的一个 tag 版本。</p><p>尽可能使用官方仓库当前版本作为你的基础镜像。推荐使用 <a href="https://hub.docker.com/_/alpine/" target="_blank" rel="noopener">Alpine</a> 镜像，因为它被严格控制并保持最小尺寸（目前小于 5 MB），但它仍然是一个完整的发行版。</p><h3 id="LABEL（向镜像添加元数据）"><a href="#LABEL（向镜像添加元数据）" class="headerlink" title="LABEL（向镜像添加元数据）"></a>LABEL（向镜像添加元数据）</h3><p>你可以给镜像添加标签来帮助组织镜像、记录许可信息、辅助自动化构建等。每个标签一行，由 <code>LABEL</code> 开头加上一个或多个键值对。下面的示例展示了各种不同的可能格式。<code>#</code> 开头的行是注释内容。</p><blockquote><p>注意：如果你的字符串中包含空格，必须将字符串放入引号中或者对空格使用转义。如果字符串内容本身就包含引号，必须对引号使用转义。</p></blockquote><pre class="line-numbers language-docker"><code class="language-docker"><span class="token comment" spellcheck="true"># Set one or more individual labels</span><span class="token keyword">LABEL</span> com.example.version=<span class="token string">"0.0.1-beta"</span><span class="token keyword">LABEL</span> vendor=<span class="token string">"ACME Incorporated"</span><span class="token keyword">LABEL</span> com.example.release<span class="token punctuation">-</span>date=<span class="token string">"2015-02-12"</span><span class="token keyword">LABEL</span> com.example.version.is<span class="token punctuation">-</span>production=<span class="token string">""</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>一个镜像可以包含多个标签，可以在一行中指定多个标签，但建议将多个标签放入到一个 <code>LABEL</code> 指令中。</p><pre class="line-numbers language-docker"><code class="language-docker"><span class="token comment" spellcheck="true"># Set multiple labels at once, using line-continuation characters to break long lines</span><span class="token keyword">LABEL</span> vendor=ACME\ Incorporated \    com.example.is<span class="token punctuation">-</span>beta= \    com.example.is<span class="token punctuation">-</span>production=<span class="token string">""</span> \    com.example.version=<span class="token string">"0.0.1-beta"</span> \    com.example.release<span class="token punctuation">-</span>date=<span class="token string">"2015-02-12"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>关于标签的更多信息，可以参考 <a href="https://docs.docker.com/config/labels-custom-metadata/" target="_blank" rel="noopener">Understanding object labels</a>。</p><h3 id="RUN（一般用于安装软件）"><a href="#RUN（一般用于安装软件）" class="headerlink" title="RUN（一般用于安装软件）"></a>RUN（一般用于安装软件）</h3><p><code>RUN</code> 指令是在新镜像内部执行的命令，可以运行任何被基础 image 支持的命令，如：执行某些动作、安装系统软件、配置系统信息之类。为了保持 <code>Dockerfile</code> 文件的可读性，可理解性，以及可维护性，建议将长的或复杂的 <code>RUN</code> 指令用反斜杠 <code>\</code> 分割成多行。</p><h4 id="apt-get"><a href="#apt-get" class="headerlink" title="apt-get"></a>apt-get</h4><p><code>RUN</code> 指令最常见的用法是安装包用的 <code>apt-get</code>。因为 <code>RUN apt-get</code> 指令会安装包，所以有几个问题需要注意。</p><p>不要使用 <code>RUN apt-get upgrade</code> 或 <code>dist-upgrade</code>，因为许多基础镜像中的「必须」包不会在一个非特权容器中升级。如果基础镜像中的某个包过时了，你应该联系它的维护者。如果你确定某个特定的包，比如 <code>foo</code>，需要升级，使用 <code>apt-get install -y foo</code> 就行，该指令会自动升级 <code>foo</code> 包。</p><p>永远将 <code>RUN apt-get update</code> 和 <code>apt-get install</code> 组合成一条 <code>RUN</code> 声明，例如：</p><pre class="line-numbers language-docker"><code class="language-docker"><span class="token keyword">RUN</span> apt<span class="token punctuation">-</span>get update &amp;&amp; apt<span class="token punctuation">-</span>get install <span class="token punctuation">-</span>y \    package<span class="token punctuation">-</span>bar \    package<span class="token punctuation">-</span>baz \    package<span class="token punctuation">-</span>foo<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>将 <code>apt-get update</code> 放在一条单独的 <code>RUN</code> 声明中会导致缓存问题以及后续的 <code>apt-get install</code> 失败。比如，假设你有一个 <code>Dockerfile</code> 文件：</p><pre class="line-numbers language-docker"><code class="language-docker"><span class="token keyword">FROM</span> ubuntu<span class="token punctuation">:</span>18.04<span class="token keyword">RUN</span> apt<span class="token punctuation">-</span>get update<span class="token keyword">RUN</span> apt<span class="token punctuation">-</span>get install <span class="token punctuation">-</span>y curl<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>构建镜像后，所有的层都在 Docker 的缓存中。假设你后来又修改了其中的 <code>apt-get install</code> 添加了一个包：</p><pre class="line-numbers language-docker"><code class="language-docker"><span class="token keyword">FROM</span> ubuntu<span class="token punctuation">:</span>18.04<span class="token keyword">RUN</span> apt<span class="token punctuation">-</span>get update<span class="token keyword">RUN</span> apt<span class="token punctuation">-</span>get install <span class="token punctuation">-</span>y curl nginx<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>Docker 发现修改后的 <code>RUN apt-get update</code> 指令和之前的完全一样。所以，<code>apt-get update</code> 不会执行，而是使用之前的缓存镜像。因为 <code>apt-get update</code> 没有运行，后面的 <code>apt-get install</code> 可能安装的是过时的 <code>curl</code> 和 <code>nginx</code> 版本。</p><p>使用 <code>RUN apt-get update &amp;&amp; apt-get install -y</code> 可以确保你的 Dockerfiles 每次安装的都是包的最新的版本，而且这个过程不需要进一步的编码或额外干预。这项技术叫作 <code>cache busting</code>。你也可以显示指定一个包的版本号来达到 <code>cache-busting</code>，这就是所谓的固定版本，例如：</p><pre class="line-numbers language-docker"><code class="language-docker"><span class="token keyword">RUN</span> apt<span class="token punctuation">-</span>get update &amp;&amp; apt<span class="token punctuation">-</span>get install <span class="token punctuation">-</span>y \    package<span class="token punctuation">-</span>bar \    package<span class="token punctuation">-</span>baz \    package<span class="token punctuation">-</span>foo=1.3.*<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>固定版本会迫使构建过程检索特定的版本，而不管缓存中有什么。这项技术也可以减少因所需包中未预料到的变化而导致的失败。</p><p>下面是一个 <code>RUN</code> 指令的示例模板，展示了所有关于 <code>apt-get</code> 的建议。</p><pre class="line-numbers language-docker"><code class="language-docker"><span class="token keyword">RUN</span> apt<span class="token punctuation">-</span>get update &amp;&amp; apt<span class="token punctuation">-</span>get install <span class="token punctuation">-</span>y \    aufs<span class="token punctuation">-</span>tools \    automake \    build<span class="token punctuation">-</span>essential \    curl \    dpkg<span class="token punctuation">-</span>sig \    libcap<span class="token punctuation">-</span>dev \    libsqlite3<span class="token punctuation">-</span>dev \    mercurial \    reprepro \    ruby1.9.1 \    ruby1.9.1<span class="token punctuation">-</span>dev \    s3cmd=1.1.* \ &amp;&amp; rm <span class="token punctuation">-</span>rf /var/lib/apt/lists/*<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其中 <code>s3cmd</code> 指令指定了一个版本号 <code>1.1.*</code>。如果之前的镜像使用的是更旧的版本，指定新的版本会导致 <code>apt-get udpate</code> 缓存失效并确保安装的是新版本。</p><p>另外，清理掉 apt 缓存 <code>var/lib/apt/lists</code> 可以减小镜像大小。因为 <code>RUN</code> 指令的开头为 <code>apt-get udpate</code>，包缓存总是会在 <code>apt-get install</code> 之前刷新。</p><blockquote><p>注意：官方的 Debian 和 Ubuntu 镜像会自动运行 apt-get clean，所以不需要显式的调用 apt-get clean。</p></blockquote><h3 id="CMD（设置容器启动时默认操作）"><a href="#CMD（设置容器启动时默认操作）" class="headerlink" title="CMD（设置容器启动时默认操作）"></a>CMD（设置容器启动时默认操作）</h3><p><code>CMD</code> 指令的主要目的是为正在执行的容器提供缺省值。指定容器启动时执行的操作。该操作可以是执行自定义脚本，也可以是执行系统命令。该指令只能在文件中存在一次，如果有多个，则只执行最后一条。</p><p><code>CMD</code> 大多数情况下都应该以 <code>CMD [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;...]</code> 的形式使用。因此，如果创建镜像的目的是为了部署某个服务(比如 <code>Apache</code>)，你可能会执行类似于 <code>CMD [&quot;apache2&quot;, &quot;-DFOREGROUND&quot;]</code> 形式的命令。我们建议任何服务镜像都使用这种形式的命令。</p><p>多数情况下，<code>CMD</code> 都需要一个交互式的 <code>shell</code> (bash, Python, perl 等)，例如 <code>CMD [&quot;perl&quot;, &quot;-de0&quot;]</code>，或者 <code>CMD [&quot;PHP&quot;, &quot;-a&quot;]</code>。使用这种形式意味着，当你执行类似 <code>docker run -it python</code> 时，你会进入一个准备好的 <code>shell</code> 中。</p><p><code>CMD</code> 应该在极少的情况下以 <code>CMD [&quot;param&quot;, &quot;param&quot;]</code> 的形式与 <code>ENTRYPOINT</code> 协同使用，除非你和你的镜像使用者都对 <code>ENTRYPOINT</code> 的工作方式十分熟悉。</p><blockquote><p>注意: 不要将 RUN 与 CMD 混淆。 Run 实际上是运行一个命令并提交结果; CMD 在构建时不执行任何操作，但会指定镜像的预期命令。</p></blockquote><h3 id="ENTRYPOINT（设置镜像主命令）"><a href="#ENTRYPOINT（设置镜像主命令）" class="headerlink" title="ENTRYPOINT（设置镜像主命令）"></a>ENTRYPOINT（设置镜像主命令）</h3><p><code>ENTRYPOINT</code> 的最佳用处是设置镜像的主命令，与 <code>CMD</code> 非常相似。当 <code>CMD</code> 和 <code>ENTRYPOINT</code> 都存在时，<code>CMD</code> 的指令变成了 <code>ENTRYPOINT</code> 指令的参数。并且此 CMD 提供的参数会被 docker run 后面的命令覆盖。</p><pre class="line-numbers language-dockerfile"><code class="language-dockerfile">FROM ubuntuCMD ["-l"]ENTRYPOINT ["/usr/bin/ls"]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>如果你使用 CMD 命令且 CMD 是一个完整的可执行的命令，那么 CMD 指令和 ENTRYPOINT 会互相覆盖只有最后一个 CMD 或者 ENTRYPOINT 有效。</p><pre class="line-numbers language-dockerfile"><code class="language-dockerfile"># CMD指令将不会被执行，只有ENTRYPOINT指令被执行CMD echo “Hello, World!”ENTRYPOINT ls -l<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><code>ENTRYPOINT</code> 指令也可以结合一个辅助脚本使用，和前面命令行风格类似，即使启动工具需要不止一个步骤。</p><p>例如，<code>Postgres</code> 官方镜像使用下面的脚本作为 <code>ENTRYPOINT</code>：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token shebang important">#!/bin/bash</span><span class="token keyword">set</span> -e<span class="token keyword">if</span> <span class="token punctuation">[</span> <span class="token string">"<span class="token variable">$1</span>"</span> <span class="token operator">=</span> <span class="token string">'postgres'</span> <span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">then</span>    <span class="token function">chown</span> -R postgres <span class="token string">"<span class="token variable">$PGDATA</span>"</span>    <span class="token keyword">if</span> <span class="token punctuation">[</span> -z <span class="token string">"$(ls -A "</span><span class="token variable">$PGDATA</span><span class="token string">")"</span> <span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">then</span>        gosu postgres initdb    <span class="token keyword">fi</span>    <span class="token function">exec</span> gosu postgres <span class="token string">"<span class="token variable">$@</span>"</span><span class="token keyword">fi</span><span class="token function">exec</span> <span class="token string">"<span class="token variable">$@</span>"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>注意：该脚本使用了 Bash 的内置命令 exec，所以最后运行的进程就是容器的 PID 为 1 的进程。这样，进程就可以接收到任何发送给容器的 Unix 信号了。</p></blockquote><p>该辅助脚本被拷贝到容器，并在容器启动时通过 <code>ENTRYPOINT</code> 执行：</p><pre class="line-numbers language-docker"><code class="language-docker"><span class="token keyword">COPY</span> ./docker<span class="token punctuation">-</span>entrypoint.sh /<span class="token keyword">ENTRYPOINT</span> <span class="token punctuation">[</span><span class="token string">"/docker-entrypoint.sh"</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>该脚本可以让用户用几种不同的方式和 <code>Postgres</code> 交互。</p><p>你可以很简单地启动 <code>Postgres</code>：</p><pre class="line-numbers language-bash"><code class="language-bash">docker run postgres<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>也可以执行 <code>Postgres</code> 并传递参数：</p><pre class="line-numbers language-bash"><code class="language-bash">docker run postgres postgres --help<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>最后，你还可以启动另外一个完全不同的工具，比如 <code>Bash</code>：</p><pre class="line-numbers language-bash"><code class="language-bash">docker run --rm -it postgres <span class="token function">bash</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="EXPOSE（暴露容器端口）"><a href="#EXPOSE（暴露容器端口）" class="headerlink" title="EXPOSE（暴露容器端口）"></a>EXPOSE（暴露容器端口）</h3><p><code>EXPOSE</code> 指令用于指将容器中的端口映射成宿主机的某个端口。当你需要访问容器的时候，可以不使用容器的 IP 地址而是使用宿主机器的 IP 地址和映射后的端口。因此，你应该为你的应用程序使用常见的端口。例如，提供 <code>Apache</code> web 服务的镜像应该使用 <code>EXPOSE 80</code>，而提供 <code>MongoDB</code> 服务的镜像使用 <code>EXPOSE 27017</code>。</p><p>对于外部访问，用户可以在执行 <code>docker run</code> 时使用 <code>-p</code> 标志来将容器的指定端口映射到宿主机所选择的端口。</p><h3 id="ENV（设置环境变量）"><a href="#ENV（设置环境变量）" class="headerlink" title="ENV（设置环境变量）"></a>ENV（设置环境变量）</h3><p>为了方便新程序运行，你可以使用 <code>ENV</code> 来为容器中安装的程序更新 <code>PATH</code> 环境变量。</p><p>例如使用 <code>ENV PATH /usr/local/nginx/bin:$PATH</code> 来确保 <code>CMD [&quot;nginx&quot;]</code> 能正确运行。</p><p><code>ENV</code> 指令也可用于为你想要容器化的服务提供必要的环境变量，比如 Postgres 需要的 <code>PGDATA</code>。</p><p>最后，<code>ENV</code> 也能用于设置常见的版本号，比如下面的示例：</p><pre class="line-numbers language-docker"><code class="language-docker"><span class="token keyword">ENV</span> PG_MAJOR 9.3<span class="token keyword">ENV</span> PG_VERSION 9.3.4<span class="token keyword">RUN</span> curl <span class="token punctuation">-</span>SL http<span class="token punctuation">:</span>//example.com/postgres<span class="token punctuation">-</span>$PG_VERSION.tar.xz <span class="token punctuation">|</span> tar <span class="token punctuation">-</span>xJC /usr/src/postgress &amp;&amp; …<span class="token keyword">ENV</span> PATH /usr/local/postgres<span class="token punctuation">-</span>$PG_MAJOR/bin<span class="token punctuation">:</span>$PATH<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>类似于程序中的常量，这种方法可以让你只需改变 <code>ENV</code> 指令来自动的改变容器中的软件版本。</p><p>在使用 ENV 设置环境变量时，有几点需要注意：</p><ul><li>1）具有传递性，也就是当前镜像被用作其它镜像的基础镜像时，新镜像会拥有当前这个基础镜像所有的环境变量</li><li>2）ENV 定义的环境变量，可以在 dockerfile 被后面的所有指令（CMD 除外）中使用，但不能被 docker run 的命令参数引用</li></ul><h3 id="ADD-和-COPY（复制文件到容器）"><a href="#ADD-和-COPY（复制文件到容器）" class="headerlink" title="ADD 和 COPY（复制文件到容器）"></a>ADD 和 COPY（复制文件到容器）</h3><p>虽然 <code>ADD</code> 和 <code>COPY</code> 功能类似，但一般优先使用 <code>COPY</code>。因为它比 <code>ADD</code> 更透明。<code>COPY</code> 只支持简单将本地文件拷贝到容器中，而 <code>ADD</code> 有一些并不明显的功能（比如本地 tar 提取和远程 URL 支持）。因此，<code>ADD</code> 的最佳用例是将本地 tar 文件自动提取到镜像中，例如 <code>ADD rootfs.tar.xz</code>。</p><p>如果你的 <code>Dockerfile</code> 有多个步骤需要使用上下文中不同的文件。单独 <code>COPY</code> 每个文件，而不是一次性的 <code>COPY</code> 所有文件，这将保证每个步骤的构建缓存只在特定的文件变化时失效。例如：</p><pre class="line-numbers language-docker"><code class="language-docker"><span class="token keyword">COPY</span> requirements.txt /tmp/<span class="token keyword">RUN</span> pip install <span class="token punctuation">-</span><span class="token punctuation">-</span>requirement /tmp/requirements.txt<span class="token keyword">COPY</span> . /tmp/<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>如果将 <code>COPY . /tmp/</code> 放置在 <code>RUN</code> 指令之前，只要 <code>.</code> 目录中任何一个文件变化，都会导致后续指令的缓存失效。</p><p>为了让镜像尽量小，最好不要使用 <code>ADD</code> 指令从远程 URL 获取包，而是使用 <code>curl</code> 和 <code>wget</code>。这样你可以在文件提取完之后删掉不再需要的文件来避免在镜像中额外添加一层。比如尽量避免下面的用法：</p><pre class="line-numbers language-docker"><code class="language-docker"><span class="token keyword">ADD</span> http<span class="token punctuation">:</span>//example.com/big.tar.xz /usr/src/things/<span class="token keyword">RUN</span> tar <span class="token punctuation">-</span>xJf /usr/src/things/big.tar.xz <span class="token punctuation">-</span>C /usr/src/things<span class="token keyword">RUN</span> make <span class="token punctuation">-</span>C /usr/src/things all<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>而是应该使用下面这种方法：</p><pre class="line-numbers language-docker"><code class="language-docker"><span class="token keyword">RUN</span> mkdir <span class="token punctuation">-</span>p /usr/src/things \    &amp;&amp; curl <span class="token punctuation">-</span>SL http<span class="token punctuation">:</span>//example.com/big.tar.xz \    <span class="token punctuation">|</span> tar <span class="token punctuation">-</span>xJC /usr/src/things \    &amp;&amp; make <span class="token punctuation">-</span>C /usr/src/things all<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>上面使用的管道操作，所以没有中间文件需要删除。</p><p>对于其他不需要 <code>ADD</code> 的自动提取功能的文件或目录，你应该使用 <code>COPY</code>。</p><h3 id="VOLUME（指定挂载点）"><a href="#VOLUME（指定挂载点）" class="headerlink" title="VOLUME（指定挂载点）"></a>VOLUME（指定挂载点）</h3><p><code>VOLUME</code> 指令用于暴露任何数据库存储文件，配置文件，或容器创建的文件和目录。强烈建议使用 <code>VOLUME</code> 来管理镜像中的可变部分和用户可以改变的部分。</p><h3 id="USER（指定运行镜像时使用的用户）"><a href="#USER（指定运行镜像时使用的用户）" class="headerlink" title="USER（指定运行镜像时使用的用户）"></a>USER（指定运行镜像时使用的用户）</h3><p>如果某个服务不需要特权执行，建议使用 <code>USER</code> 指令切换到非 root 用户。先在 <code>Dockerfile</code> 中使用类似 <code>RUN groupadd -r postgres &amp;&amp; useradd -r -g postgres postgres</code> 的指令创建用户和用户组。</p><blockquote><p>注意：在镜像中，用户和用户组每次被分配的 UID/GID 都是不确定的，下次重新构建镜像时被分配到的 UID/GID 可能会不一样。如果要依赖确定的 UID/GID，你应该显示的指定一个 UID/GID。</p></blockquote><p>你应该避免使用 <code>sudo</code>，因为它不可预期的 TTY 和信号转发行为可能造成的问题比它能解决的问题还多。如果你真的需要和 <code>sudo</code> 类似的功能（例如，以 root 权限初始化某个守护进程，以非 root 权限执行它），你可以使用 <a href="https://github.com/tianon/gosu" target="_blank" rel="noopener">gosu</a>。</p><p>最后，为了减少层数和复杂度，避免频繁地使用 <code>USER</code> 来回切换用户。</p><h3 id="WORKDIR（切换目录）"><a href="#WORKDIR（切换目录）" class="headerlink" title="WORKDIR（切换目录）"></a>WORKDIR（切换目录）</h3><p>为跟在它后面的 <code>RUN</code>、 <code>CMD</code>、 <code>ENTRYPOINT</code>、 <code>COPY</code> 和 <code>ADD</code> 指令设置工作目录。其效果类似于 Linux 命名中的<code>cd</code> 命令，用于目录的切换，但是和 <code>cd</code> 不一样的是：如果切换到的目录不存在，WORKDIR 会为此创建目录。</p><p>为了清晰性和可靠性，你应该总是在 <code>WORKDIR</code> 中使用绝对路径。另外，你应该使用 <code>WORKDIR</code> 来替代类似于 <code>RUN cd ... &amp;&amp; do-something</code> 的指令，后者难以阅读、排错和维护。</p><h3 id="ONBUILD（在子镜像中执行）"><a href="#ONBUILD（在子镜像中执行）" class="headerlink" title="ONBUILD（在子镜像中执行）"></a>ONBUILD（在子镜像中执行）</h3><p>Onbuild 指令向镜像添加一个触发器指令，以便在以后将该镜像用作另一个构建的基础镜像时执行。 意思就是：这个镜像创建时不会执行，以后，如果其它镜像以这个镜像为基础，会先执行这个镜像的 ONBUILD 命令。</p><p>任何构建指令都可以注册为触发器。如果 <code>Onbuild</code> 指令执行失败，子镜像的 FROM 指令就会中止。执行完触发器后，将从最终图像中清除触发器。换句话说，它们不会传递到“孙子代”版本镜像中。</p><h3 id="ARG（设置构建镜像时变量）"><a href="#ARG（设置构建镜像时变量）" class="headerlink" title="ARG（设置构建镜像时变量）"></a>ARG（设置构建镜像时变量）</h3><p>ARG 定义的变量只在建立 image 时有效，建立完成后变量就失效消失。用户可以在 <code>docker build</code> 时使用带有<code>--build-arg =</code> 标志的命令将变量传递给构建器。</p><p>同时使用<code>ARG</code>或<code>ENV</code>指令为 <code>RUN</code> 指令设置变量时，<code>ENV</code> 指令定义的环境变量 会始终覆盖<code>ARG</code>同名指令。例如:</p><pre class="line-numbers language-dockerfile"><code class="language-dockerfile">FROM ubuntuARG CONT_IMG_VERENV CONT_IMG_VER v1.0.0RUN echo $CONT_IMG_VER<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>然后，使用以下命令构建镜像：</p><pre class="line-numbers language-bash"><code class="language-bash">docker build --build-arg CONT_IMG_VER<span class="token operator">=</span>v2.0.1 <span class="token keyword">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在情况下，<code>RUN</code>指令将使用<code>v1.0.0</code>，而不是<code>ARG</code>用户传递的值：<code>v2.0.1</code>。</p><p>Docker 有一组预定义的 ARG 变量，您可以在 Dockerfile 中不使用相应的 ARG 指令而使用它们：</p><ul><li><code>HTTP_PROXY</code></li><li><code>http_proxy</code></li><li><code>HTTPS_PROXY</code></li><li><code>https_proxy</code></li><li><code>FTP_PROXY</code></li><li><code>ftp_proxy</code></li><li><code>NO_PROXY</code></li><li><code>no_proxy</code></li></ul><p>要使用它们，只需在命令行上使用 <code>--build-arg &lt;varname&gt;=&lt;value&gt;</code> 标志赋值。默认情况下，这些预定义的变量被排除在 docker 历史记录的输出之外。 这可以降低意外泄漏 httpproxy 变量中敏感的身份验证信息的风险。</p><p>例如，使用 <code>--build-arg HTTP_PROXY=http://user:pass@proxy.lon.example.com</code> 构建镜像时，httpproxy 变量的值在 docker 历史记录中不可用，也不会被缓存。</p><h2 id="三、一般准则和建议"><a href="#三、一般准则和建议" class="headerlink" title="三、一般准则和建议"></a>三、一般准则和建议</h2><h3 id="容器应该是短暂的"><a href="#容器应该是短暂的" class="headerlink" title="容器应该是短暂的"></a>容器应该是短暂的</h3><p>通过 <code>Dockerfile</code> 构建的镜像所启动的容器应该尽可能短暂（生命周期短）。「短暂」意味着可以停止和销毁容器，并且创建一个新容器并部署好所需的设置和配置的工作量应该是极小的。</p><h3 id="使用-dockerignore-文件"><a href="#使用-dockerignore-文件" class="headerlink" title="使用 .dockerignore 文件"></a>使用 .dockerignore 文件</h3><p>使用 <code>Dockerfile</code> 构建镜像时最好将 <code>Dockerfile</code> 放置在一个新建的空目录下。然后将构建镜像所需要的文件添加到该目录中。为了提高构建镜像的效率，你可以在目录下新建一个 <code>.dockerignore</code> 文件来指定要忽略的文件和目录。<code>.dockerignore</code> 文件的排除模式语法和 Git 的 <code>.gitignore</code> 文件相似。</p><h3 id="使用多阶段构建"><a href="#使用多阶段构建" class="headerlink" title="使用多阶段构建"></a>使用多阶段构建</h3><p>在 <code>Docker 17.05</code> 以上版本中，你可以使用多阶段构建来减少所构建镜像的大小。</p><h3 id="避免安装不必要的包"><a href="#避免安装不必要的包" class="headerlink" title="避免安装不必要的包"></a>避免安装不必要的包</h3><p>为了降低复杂性、减少依赖、减小文件大小、节约构建时间，你应该避免安装任何不必要的包。例如，不要在数据库镜像中包含一个文本编辑器。</p><h3 id="一个容器只运行一个进程"><a href="#一个容器只运行一个进程" class="headerlink" title="一个容器只运行一个进程"></a>一个容器只运行一个进程</h3><p>应该保证在一个容器中只运行一个进程。将多个应用解耦到不同容器中，保证了容器的横向扩展和复用。例如 web 应用应该包含三个容器：web 应用、数据库、缓存。</p><p>如果容器互相依赖，你可以使用 <a href="https://yeasy.gitbooks.io/docker_practice/content/network/linking.html" target="_blank" rel="noopener">Docker 自定义网络</a> 来把这些容器连接起来。</p><h3 id="镜像层数尽可能少"><a href="#镜像层数尽可能少" class="headerlink" title="镜像层数尽可能少"></a>镜像层数尽可能少</h3><p>每执行一个指令，都会有一次镜像的提交，镜像是分层的结构，需要在 <code>Dockerfile</code> 可读性（也包括长期的可维护性）和减少层数之间做一个平衡。</p><h3 id="将多行参数排序"><a href="#将多行参数排序" class="headerlink" title="将多行参数排序"></a>将多行参数排序</h3><p>将多行参数按字母顺序排序（比如要安装多个包时）。这可以帮助你避免重复包含同一个包，更新包列表时也更容易。也便于 <code>PRs</code> 阅读和审查。建议在反斜杠符号 <code>\</code> 之前添加一个空格，以增加可读性。</p><p>下面是来自 <code>buildpack-deps</code> 镜像的例子：</p><pre class="line-numbers language-docker"><code class="language-docker"><span class="token keyword">RUN</span> apt<span class="token punctuation">-</span>get update &amp;&amp; apt<span class="token punctuation">-</span>get install <span class="token punctuation">-</span>y \  bzr \  cvs \  git \  mercurial \  subversion<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="使用构建缓存"><a href="#使用构建缓存" class="headerlink" title="使用构建缓存"></a>使用构建缓存</h3><p>在镜像的构建过程中，Docker 会遍历 <code>Dockerfile</code> 文件中的指令，然后按顺序执行。在执行每条指令之前，Docker 都会在缓存中查找是否已经存在可重用的镜像，如果有就使用现存的镜像，不再重复创建。如果你不想在构建过程中使用缓存，你可以在 <code>docker build</code> 命令中使用 <code>--no-cache=true</code> 选项。</p><p>但是，如果你想在构建的过程中使用缓存，你得明白什么时候会或不会找到匹配的镜像，遵循的基本规则如下：</p><ul><li>从一个基础镜像开始（<code>FROM</code> 指令指定），下一条指令将和该基础镜像的所有子镜像进行匹配，检查这些子镜像被创建时使用的指令是否和被检查的指令完全一样。如果不是，则缓存失效。</li><li>在大多数情况下，只需要简单地对比 <code>Dockerfile</code> 中的指令和子镜像。然而，有些指令需要更多的检查和解释。</li><li>对于 <code>ADD</code> 和 <code>COPY</code> 指令，镜像中对应文件的内容也会被检查，每个文件都会计算出一个校验和。文件的最后修改时间和最后访问时间不会纳入校验。在缓存的查找过程中，会将这些校验和和已存在镜像中的文件校验和进行对比。如果文件有任何改变，比如内容和元数据，则缓存失效。</li><li>除了 <code>ADD</code> 和 <code>COPY</code> 指令，缓存匹配过程不会查看临时容器中的文件来决定缓存是否匹配。例如，当执行完 <code>RUN apt-get -y update</code> 指令后，容器中一些文件被更新，但 Docker 不会检查这些文件。这种情况下，只有指令字符串本身被用来匹配缓存。</li></ul><p>一旦缓存失效，所有后续的 <code>Dockerfile</code> 指令都将产生新的镜像，缓存不会被使用。</p><h2 id="四、官方镜像示例"><a href="#四、官方镜像示例" class="headerlink" title="四、官方镜像示例"></a>四、官方镜像示例</h2><p>这些官方镜像的 Dockerfile 都是参考典范：<a href="https://github.com/docker-library/docs" target="_blank" rel="noopener">https://github.com/docker-library/docs</a>。</p><p>所有 Markdown 文件都通过 <a href="https://github.com/tianon/markdownfmt" target="_blank" rel="noopener">markdownfmt</a> 进行运行（仅添加了一些较小的差异首选项和较小的DockerHub兼容性更改），并通过Travis CI 验证其格式正确。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>官方文档：<a href="https://docs.docker.com/engine/reference/builder/" target="_blank" rel="noopener">Dockerfile reference</a></li><li>官方文档：<a href="https://docs.docker.com/develop/develop-images/dockerfile_best-practices/" target="_blank" rel="noopener">Best practices for writing Dockerfiles</a></li></ul><h2 id="相关文章"><a href="#相关文章" class="headerlink" title="相关文章"></a>相关文章</h2><ul><li>上一篇：<a href="https://www.lixl.cn/books/Docker/appendix1-docker-command/">Docker必知必会系列（附录1）：Docker 常用命令及示例</a></li><li>下一篇：<a href="https://www.lixl.cn/books/Docker/appendix3-docker-compose-command/">Docker必知必会系列（附录3）：Docker-compose 命令使用指南</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DevOps </tag>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>附录1、Docker 常用命令及示例</title>
      <link href="/2020/030137160.html"/>
      <url>/2020/030137160.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文是《<a href="https://www.lixl.cn/books/Docker/1-Overview/">Docker必知必会系列</a>》第九篇，原文发布于个人博客：<a href="https://www.lixl.cn/">悟尘记</a>。</p><p>上一篇：<a href="https://www.lixl.cn/books/Docker/8-kubernetes/">Docker必知必会系列（八）：从 Docker 进阶到 Kubernetes</a></p></blockquote><h2 id="常用命令列表"><a href="#常用命令列表" class="headerlink" title="常用命令列表"></a>常用命令列表</h2><p>一张图总结 Docker 常用命令及状态变化：</p><p><img src="https://pic.lixl.cn/2020/image-20200325192936728.png" alt="Docker常用命令及状态变化图"></p><p>可以通过 <code>docker COMMAND --help</code> 来查看这些命令的具体用法。</p><ul><li><code>attach</code>：依附到一个正在运行的容器中；</li><li><code>build</code>：从一个 Dockerfile 创建一个镜像；</li><li><code>commit</code>：从一个容器的修改中创建一个新的镜像；</li><li><code>cp</code>：在容器和本地宿主系统之间复制文件中；</li><li><code>create</code>：创建一个新容器，但并不运行它；</li><li><code>diff</code>：检查一个容器内文件系统的修改，包括修改和增加；</li><li><code>events</code>：从服务端获取实时的事件；</li><li><code>exec</code>：在运行的容器内执行命令；</li><li><code>export</code>：导出容器内容为一个 <code>tar</code> 包；</li><li><code>history</code>：显示一个镜像的历史信息；</li><li><code>images</code>：列出存在的镜像；</li><li><code>import</code>：导入一个文件（典型为 <code>tar</code> 包）路径或目录来创建一个本地镜像；</li><li><code>info</code>：显示一些相关的系统信息；</li><li><code>inspect</code>：显示一个容器的具体配置信息；</li><li><code>kill</code>：关闭一个运行中的容器 (包括进程和所有相关资源)；</li><li><code>load</code>：从一个 tar 包中加载一个镜像；</li><li><code>login</code>：注册或登录到一个 Docker 的仓库服务器；</li><li><code>logout</code>：从 Docker 的仓库服务器登出；</li><li><code>logs</code>：获取容器的 log 信息；</li><li><code>network</code>：管理 Docker 的网络，包括查看、创建、删除、挂载、卸载等；</li><li><code>node</code>：管理 swarm 集群中的节点，包括查看、更新、删除、提升/取消管理节点等；</li><li><code>pause</code>：暂停一个容器中的所有进程；</li><li><code>port</code>：查找一个 nat 到一个私有网口的公共口；</li><li><code>ps</code>：列出主机上的容器；</li><li><code>pull</code>：从一个 Docker 的仓库服务器下拉一个镜像或仓库；</li><li><code>push</code>：将一个镜像或者仓库推送到一个 Docker 的注册服务器；</li><li><code>rename</code>：重命名一个容器；</li><li><code>restart</code>：重启一个运行中的容器；</li><li><code>rm</code>：删除给定的若干个容器；</li><li><code>rmi</code>：删除给定的若干个镜像；</li><li><code>run</code>：创建一个新容器，并在其中运行给定命令；</li><li><code>save</code>：保存一个镜像为 tar 包文件；</li><li><code>search</code>：在 Docker index 中搜索一个镜像；</li><li><code>service</code>：管理 Docker 所启动的应用服务，包括创建、更新、删除等；</li><li><code>start</code>：启动一个容器；</li><li><code>stats</code>：监控容器的 CPU 利用率、内存使用量、网络 IO 总量以及磁盘 IO 总量等信息；</li><li><code>stop</code>：终止一个运行中的容器；</li><li><code>swarm</code>：管理 Docker swarm 集群，包括创建、加入、退出、更新等；</li><li><code>tag</code>：为一个镜像打标签；</li><li><code>top</code>：查看一个容器中的正在运行的进程信息；</li><li><code>unpause</code>：将一个容器内所有的进程从暂停状态中恢复；</li><li><code>update</code>：更新指定的若干容器的配置信息；</li><li><code>version</code>：输出 Docker 的版本信息；</li><li><code>volume</code>：管理 Docker volume，包括查看、创建、删除等；</li><li><code>wait</code>：阻塞直到一个容器终止，然后输出它的退出符。</li></ul><h2 id="操作示例"><a href="#操作示例" class="headerlink" title="操作示例"></a>操作示例</h2><h3 id="查看-Docker-版本和系统信息"><a href="#查看-Docker-版本和系统信息" class="headerlink" title="查看 Docker 版本和系统信息"></a>查看 Docker 版本和系统信息</h3><p>无论是在本地还是云端，我们都需要检查 Docker 版本和系统信息，可以使用以下命令找到 Docker 版本：</p><pre class="line-numbers language-bash"><code class="language-bash">docker versionClient:Version: 18.03.0-ceAPI version: 1.37Go version: go1.9.4Git commit: 0520e24Built: Wed Mar 21 23:06:22 2018OS/Arch: darwin/amd64Experimental: <span class="token boolean">false</span>Orchestrator: swarmServer:Engine:Version: 18.03.0-ceAPI version: 1.37 <span class="token punctuation">(</span>minimum version 1.12<span class="token punctuation">)</span>Go version: go1.9.4Git commit: 0520e24Built: Wed Mar 21 23:14:32 2018OS/Arch: linux/amd64Experimental: <span class="token boolean">true</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>另一个重要命令是 docker info：</p><pre class="line-numbers language-bash"><code class="language-bash">docker infoContainers: 0Running: 0Paused: 0Stopped: 0Images: 0Server Version: 18.03.0-ceStorage Driver: overlay2Backing Filesystem: extfsSupports d_type: <span class="token boolean">true</span>Native Overlay Diff: <span class="token boolean">true</span>Logging Driver: json-fileCgroup Driver: cgroupfsPlugins:Volume: localNetwork: bridge host ipvlan macvlan null overlayLog: awslogs fluentd gcplogs gelf journald json-file logentries splunk syslog…<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>该命令将显示部分设备信息，比如服务器版本、存储驱动程序、内核版本、操作系统、总内存等。当尝试为当前 Docker 安装启动新资源或尝试找出系统级资源分配问题时，这些信息非常有用，这也是检查运行、停止容器数量及下载镜像数量的快速方法。</p><h3 id="搜索下载-Docker-镜像"><a href="#搜索下载-Docker-镜像" class="headerlink" title="搜索下载 Docker 镜像"></a>搜索下载 Docker 镜像</h3><p>可以使用 docker search 命令在 Docker Hub 搜索已有镜像：</p><pre class="line-numbers language-bash"><code class="language-bash">docker search ubuntuNAME DESCRIPTION STARS OFFICIAL AUTOMATEDubuntu Ubuntu is a Debian-based Linux operating sys… 7861 <span class="token punctuation">[</span>OK<span class="token punctuation">]</span>dorowu/ubuntu-desktop-lxde-vnc Ubuntu with openssh-server and NoVNC 190 <span class="token punctuation">[</span>OK<span class="token punctuation">]</span>rastasheep/ubuntu-sshd Dockerized SSH service, built on <span class="token function">top</span> of offi… 156 <span class="token punctuation">[</span>OK<span class="token punctuation">]</span>ansible/ubuntu14.04-ansible Ubuntu 14.04 LTS with ansible 93 <span class="token punctuation">[</span>OK<span class="token punctuation">]</span>ubuntu-upstart Upstart is an event-based replacement <span class="token keyword">for</span> th… 87 <span class="token punctuation">[</span>OK<span class="token punctuation">]</span>neurodebian NeuroDebian provides neuroscience research s… 50 <span class="token punctuation">[</span>OK<span class="token punctuation">]</span>…<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>以上对 ubuntu 的搜索显示可用镜像、描述和官方状态等信息。如果要下载 ubuntu 镜像，可以使用 docker pull 命令：</p><pre class="line-numbers language-bash"><code class="language-bash">docker pull ubuntuUsing default tag: latestlatest: Pulling from library/ubuntu6b98dfc16071: Pull complete4001a1209541: Pull complete6319fc68c576: Pull completeb24603670dc3: Pull complete97f170c87c6f: Pull completeDigest: sha256:5f4bdc3467537cbbe563e80db2c3ec95d548a9145d64453b06939c4592d67b6dStatus: Downloaded newer image <span class="token keyword">for</span> ubuntu:latest$<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Docker-镜像"><a href="#Docker-镜像" class="headerlink" title="Docker 镜像"></a>Docker 镜像</h3><p>使用 docker info 命令查找拥有镜像数量：</p><pre class="line-numbers language-bash"><code class="language-bash">docker infoContainers: 0Running: 0Paused: 0Stopped: 0Images: 1…<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>docker images 命令可详细列出拥有镜像：</p><pre class="line-numbers language-bash"><code class="language-bash">docker imagesREPOSITORY          TAG                 IMAGE ID            CREATED             SIZEubuntu              latest              113a43faa138        2 weeks ago         81.2MB<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>假设下载 NGINX 镜像，可以运行 docker pull 命令：</p><pre class="line-numbers language-bash"><code class="language-bash">docker pull nginx<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果检查 Docker 镜像，会看到如下内容：</p><pre class="line-numbers language-bash"><code class="language-bash">docker imagesREPOSITORY          TAG                 IMAGE ID            CREATED             SIZEubuntu              latest              113a43faa138        2 weeks ago         81.2MBnginx               latest              cd5239a0906a        2 weeks ago         109MB<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>如果寻找 Ubuntu 16.04 版本，可使用 16.04 标签下载特定版本：</p><pre class="line-numbers language-bash"><code class="language-bash">docker pull ubuntu:16.04<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>随后，将出现两个 Ubuntu 镜像版本：</p><pre class="line-numbers language-bash"><code class="language-bash">docker imagesREPOSITORY          TAG                 IMAGE ID            CREATED             SIZEubuntu              16.04               5e8b97a2a082        2 weeks ago         114MBubuntu              latest              113a43faa138        2 weeks ago         81.2MBnginx               latest              cd5239a0906a        2 weeks ago         109MB<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意：无需注册 Docker Hub 即可提取镜像。如果想将镜像推送到 Docker Hub，需要注册然后使用 docker login 命令登录：</p><pre class="line-numbers language-bash"><code class="language-bash">docker login --username<span class="token operator">=</span>yourhubusername --email<span class="token operator">=</span>youremail@company.com<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="运行-Docker-容器"><a href="#运行-Docker-容器" class="headerlink" title="运行 Docker 容器"></a>运行 Docker 容器</h3><p>假设想在 docker 上运行 NGINX 服务器，可运行以下命令：</p><pre class="line-numbers language-bash"><code class="language-bash">docker run -p 8080:80 nginx<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果已用 run 命令从 Docker Hub 提取 nginx 镜像创建 NGINX 容器。 -p 8080:80 会告诉 Docker 将 localhost 端口 8080 映射到 Docker 容器端口 80，应该能够从 <a href="http://localhost:8080" target="_blank" rel="noopener">http://localhost:8080</a> 访问 NGINX 服务器。</p><p>NGINX 容器已附加到命令行。如果退出命令行，容器将会停止，可使用 detach（’- d）启动 NGINX 容器，这样即使退出命令行也可继续运行。</p><pre class="line-numbers language-bash"><code class="language-bash">docker run -p 8080:80 -d nginx<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>以上命令将以分离模式启动容器并返回命令行。<code>docker run</code> 命令格式：</p><pre class="line-numbers language-bash"><code class="language-bash">Usage: docker run <span class="token punctuation">[</span>OPTIONS<span class="token punctuation">]</span> IMAGE <span class="token punctuation">[</span>COMMAND<span class="token punctuation">]</span> <span class="token punctuation">[</span>ARG<span class="token punctuation">..</span>.<span class="token punctuation">]</span>-a, --attach<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token comment" spellcheck="true">#登录容器（以docker run -d启动的容器）</span>-c, --cpu-shares<span class="token operator">=</span>0 <span class="token comment" spellcheck="true">#设置容器CPU权重，在CPU共享场景使用</span>--cap-add<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token comment" spellcheck="true">#添加权限，权限清单详见：http://linux.die.net/man/7/capabilities</span>--cap-drop<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token comment" spellcheck="true">#删除权限，权限清单详见：http://linux.die.net/man/7/capabilities</span>--cidfile<span class="token operator">=</span><span class="token string">""</span> <span class="token comment" spellcheck="true">#运行容器后，在指定文件中写入容器PID值，一种典型的监控系统用法</span>--cpuset<span class="token operator">=</span><span class="token string">""</span> <span class="token comment" spellcheck="true">#设置容器可以使用哪些CPU，此参数可以用来容器独占CPU</span>-d, --detach<span class="token operator">=</span>false <span class="token comment" spellcheck="true">#指定容器运行于前台还是后台</span>--device<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token comment" spellcheck="true">#添加主机设备给容器，相当于设备直通</span>--dns<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token comment" spellcheck="true">#指定容器的dns服务器</span>--dns-search<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token comment" spellcheck="true">#指定容器的dns搜索域名，写入到容器的/etc/resolv.conf文件</span>-e, --env<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token comment" spellcheck="true">#指定环境变量，容器中可以使用该环境变量</span>--entrypoint<span class="token operator">=</span><span class="token string">""</span> <span class="token comment" spellcheck="true">#覆盖image的入口点</span>--env-file<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token comment" spellcheck="true">#指定环境变量文件，文件格式为每行一个环境变量</span>--expose<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token comment" spellcheck="true">#指定容器暴露的端口，即修改镜像的暴露端口</span>-h, --hostname<span class="token operator">=</span><span class="token string">""</span> <span class="token comment" spellcheck="true">#指定容器的主机名</span>-i, --interactive<span class="token operator">=</span>false <span class="token comment" spellcheck="true">#打开STDIN，用于控制台交互</span>--link<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token comment" spellcheck="true">#指定容器间的关联，使用其他容器的IP、env等信息</span>--lxc-conf<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token comment" spellcheck="true">#指定容器的配置文件，只有在指定--exec-driver=lxc时使用</span>-m, --memory<span class="token operator">=</span><span class="token string">""</span> <span class="token comment" spellcheck="true">#指定容器的内存上限</span>--name<span class="token operator">=</span><span class="token string">""</span> <span class="token comment" spellcheck="true">#指定容器名字，后续可以通过名字进行容器管理，links特性需要使用名字</span>--net<span class="token operator">=</span><span class="token string">"bridge"</span> <span class="token comment" spellcheck="true">#容器网络设置，待详述</span>-P, --publish-all<span class="token operator">=</span>false <span class="token comment" spellcheck="true">#指定容器暴露的端口，待详述</span>-p, --publish<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token comment" spellcheck="true">#指定容器暴露的端口，待详述</span>--privileged<span class="token operator">=</span>false <span class="token comment" spellcheck="true">#指定容器是否为特权容器，特权容器拥有所有的capabilities</span>--restart<span class="token operator">=</span><span class="token string">""</span> <span class="token comment" spellcheck="true">#指定容器停止后的重启策略，待详述</span>--rm<span class="token operator">=</span>false <span class="token comment" spellcheck="true">#指定容器停止后自动删除容器(不支持以docker run -d启动的容器)</span>--sig-proxy<span class="token operator">=</span>true <span class="token comment" spellcheck="true">#设置由代理接受并处理信号，但是SIGCHLD、SIGSTOP和SIGKILL不能被代理</span>-t, --tty<span class="token operator">=</span>false <span class="token comment" spellcheck="true">#分配tty设备，该可以支持终端登录</span>-u, --user<span class="token operator">=</span><span class="token string">""</span> <span class="token comment" spellcheck="true">#指定容器的用户</span>-v, --volume<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token comment" spellcheck="true">#给容器挂载存储卷，挂载到容器的某个目录</span>--volumes-from<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token comment" spellcheck="true">#给容器挂载其他容器上的卷，挂载到容器的某个目录</span>-w, --workdir<span class="token operator">=</span><span class="token string">""</span> <span class="token comment" spellcheck="true">#指定容器的工作目录</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="列出-Docker-容器"><a href="#列出-Docker-容器" class="headerlink" title="列出 Docker 容器"></a>列出 Docker 容器</h3><p>docker ps 命令允许查找正在运行的所有容器：</p><pre class="line-numbers language-bash"><code class="language-bash">docker <span class="token function">ps</span>CONTAINER ID         IMAGE         COMMAND         CREATED           STATUS          PORTS             NAMES6162daed25da         nginx  <span class="token string">"nginx -g 'daemon of…"</span> 7 minutes ago   Up 7 minutes  0.0.0.0:8080-<span class="token operator">></span>80/tcp  hardcore_torvalds<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>如上显示容器的各种属性，可以看到是从 nginx 镜像创建并显示端口转发信息。CONTAINER ID 和 NAMES 属性需要特别提及，可以使用上述两大属性唯一标识容器。二者都可自动生成，但也可在容器创建过程中为容器命名。<br>创建一个名为 my_nginx 的 NGINX 容器：</p><pre class="line-numbers language-bash"><code class="language-bash">docker run --name my_nginx -p 8888:80 -d nginx<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>再次列出所有 Docker 容器：</p><pre class="line-numbers language-bash"><code class="language-bash">docker <span class="token function">ps</span>CONTAINER ID        IMAGE               COMMAND                  CREATED              STATUS              PORTS                  NAMESe7b19b6ad778        nginx               <span class="token string">"nginx -g 'daemon of…"</span>   About a minute ago   Up About a minute   0.0.0.0:8888-<span class="token operator">></span>80/tcp   my_nginx6162daed25da        nginx               <span class="token string">"nginx -g 'daemon of…"</span>   15 minutes ago       Up 16 minutes       0.0.0.0:8080-<span class="token operator">></span>80/tcp   hardcore_torvalds<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>请注意，新容器的名称为“my_nginx”。 处理大量容器时，可以使用命名约定，这可以更好得组织容器。<br>docker ps 命令仅显示正在运行的容器。如果对上述情况使用 docker info 命令：</p><pre class="line-numbers language-bash"><code class="language-bash">docker infoContainers: 2Running: 2Paused: 0Stopped: 0Images: 3<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到有两个容器正在运行，如果一个暂停或已停止，则不会仅使用 docker ps 命令查看这些容器，必须使用 all（ - a）选项：</p><pre class="line-numbers language-bash"><code class="language-bash">docker <span class="token function">ps</span> -a<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="启动，停止，重启和杀死容器"><a href="#启动，停止，重启和杀死容器" class="headerlink" title="启动，停止，重启和杀死容器"></a>启动，停止，重启和杀死容器</h3><p>假设要停止’my_nginx’容器，可使用 CONTAINER ID 或 NAME。</p><pre class="line-numbers language-bash"><code class="language-bash">docker stop my_nginxmy_nginx<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>列出 Docker 容器：</p><pre class="line-numbers language-bash"><code class="language-bash">docker <span class="token function">ps</span>CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                  NAMES6162daed25da        nginx               <span class="token string">"nginx -g 'daemon of…"</span>   27 minutes ago      Up 27 minutes       0.0.0.0:8080-<span class="token operator">></span>80/tcp   hardcore_torvaldsdocker <span class="token function">ps</span> -aCONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS                          PORTS                  NAMESe7b19b6ad778        nginx               <span class="token string">"nginx -g 'daemon of…"</span>   12 minutes ago      Exited <span class="token punctuation">(</span>0<span class="token punctuation">)</span> About a minute ago                          my_nginx6162daed25da        nginx               <span class="token string">"nginx -g 'daemon of…"</span>   27 minutes ago      Up 27 minutes                   0.0.0.0:8080-<span class="token operator">></span>80/tcp   hardcore_torvalds<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果在没有 -a 选项的情况下运行 docker ps，只显示正在运行的容器。在第二种情况下，可以看到’my_nginx’容器处于退出状态。</p><p>让我们 docker start 容器：</p><pre class="line-numbers language-bash"><code class="language-bash">docker start my_nginxmy_nginx<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>检查 Docker 容器列表：</p><pre class="line-numbers language-bash"><code class="language-bash">docker <span class="token function">ps</span>CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                  NAMESe7b19b6ad778        nginx               <span class="token string">"nginx -g 'daemon of…"</span>   16 minutes ago      Up 29 seconds       0.0.0.0:8888-<span class="token operator">></span>80/tcp   my_nginx6162daed25da        nginx               <span class="token string">"nginx -g 'daemon of…"</span>   30 minutes ago      Up 30 minutes       0.0.0.0:8080-<span class="token operator">></span>80/tcp   hardcore_torvalds<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到 STATUS 显示容器’my_nginx’再次被启动。<br>如果由于某些问题而需重启容器，则可使用 restart 命令，这比单独停止和启动容器速度更快：</p><pre class="line-numbers language-bash"><code class="language-bash">docker restart my_nginx<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>可以像进程一样终止 docker 容器，比如终止 my_nginx 容器：</p><pre class="line-numbers language-bash"><code class="language-bash">docker <span class="token function">kill</span> my_nginx<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>再次列出 Docker 容器：</p><pre class="line-numbers language-bash"><code class="language-bash">docker <span class="token function">ps</span> -aCONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS                       PORTS                  NAMESe7b19b6ad778        nginx               <span class="token string">"nginx -g 'daemon of…"</span>   22 minutes ago      Exited <span class="token punctuation">(</span>137<span class="token punctuation">)</span> 7 seconds ago                          my_nginx6162daed25da        nginx               <span class="token string">"nginx -g 'daemon of…"</span>   36 minutes ago      Up 36 minutes                0.0.0.0:8080-<span class="token operator">></span>80/tcp   hardcore_torvalds<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>容器 my_nginx 未运行。此外，可在信息中看到一个正在运行的容器和一个已停止容器：</p><pre class="line-numbers language-bash"><code class="language-bash">docker infoContainers: 2Running: 1Paused: 0Stopped: 1Images: 3…<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Docker-Exec-Bash-和-Docker-SSH"><a href="#Docker-Exec-Bash-和-Docker-SSH" class="headerlink" title="Docker Exec Bash 和 Docker SSH"></a>Docker Exec Bash 和 Docker SSH</h3><p>如果需要与 shell 进行交互以创建服务或解决问题，可以使用 docker exec 命令创建交互式 shell。比如，用 bash shell 从 ubuntu 镜像启动一个容器：</p><pre class="line-numbers language-bash"><code class="language-bash">docker run --name my_ubuntu -it ubuntu:latest <span class="token function">bash</span>root@a19c770b8621:/<span class="token comment" spellcheck="true">#</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>root @haracle＃表示位于 Docker 容器的 bash shell 中，可以运行 shell 命令：</p><pre class="line-numbers language-bash"><code class="language-bash">root@a19c770b8621:/<span class="token comment" spellcheck="true"># ls</span>bin boot dev etc home lib lib64 media mnt opt proc root run sbin srv sys tmp usr varroot@a19c770b8621:/<span class="token comment" spellcheck="true"># pwd</span>/<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>列出 Docker 容器：</p><pre class="line-numbers language-bash"><code class="language-bash">docker <span class="token function">ps</span>CONTAINER ID        IMAGE               COMMAND                  CREATED              STATUS              PORTS                  NAMESa19c770b8621        ubuntu:latest       <span class="token string">"bash"</span>                   About a minute ago   Up About a minute                          my_ubuntu6162daed25da        nginx               <span class="token string">"nginx -g 'daemon of…"</span>   About an hour ago    Up About an hour    0.0.0.0:8080-<span class="token operator">></span>80/tcp   hardcore_torvalds<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>如上，my_ubuntu 正在运行。假设想将 Docker ssh 放入’my_ubuntu’容器中，可以使用 docker exec bash：</p><pre class="line-numbers language-bash"><code class="language-bash">docker <span class="token function">exec</span> -it my_ubuntu <span class="token function">bash</span>root@a19c770b8621:/<span class="token comment" spellcheck="true">#</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>使用 docker exec 向容器发出命令。例如，可以直接用命令提示符在 my_ubuntu 容器上运行 ls 命令：</p><pre class="line-numbers language-bash"><code class="language-bash">docker <span class="token function">exec</span> -it my_ubuntu <span class="token function">ls</span>bin dev home lib64 mnt proc run srv tmp varboot etc lib media opt root sbin sys usr<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="以分离模式启动容器并-attach"><a href="#以分离模式启动容器并-attach" class="headerlink" title="以分离模式启动容器并 attach"></a>以分离模式启动容器并 attach</h3><p>以上示例用附加模式启动 ubuntu 容器，我们也可在分离模式下启动：</p><pre class="line-numbers language-bash"><code class="language-bash">docker run -it -d --name my_ubuntu_2 ubuntu:latest <span class="token function">bash</span>75b28b7208359137b3e1dc2843387918e28b4c6c4860ef0cdeac79c205f5cbc4<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>验证容器是否正在运行：</p><pre class="line-numbers language-bash"><code class="language-bash">docker <span class="token function">ps</span>CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                  NAMES75b28b720835        ubuntu:latest       <span class="token string">"bash"</span>                   3 minutes ago       Up 3 minutes                               my_ubuntu_2a19c770b8621        ubuntu:latest       <span class="token string">"bash"</span>                   15 minutes ago      Up 15 minutes                              my_ubuntu6162daed25da        nginx               <span class="token string">"nginx -g 'daemon of…"</span>   2 hours ago         Up 2 hours          0.0.0.0:8080-<span class="token operator">></span>80/tcp   hardcore_torvalds<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用 docker attach 命令获取 docker exec bash-like 效果：</p><pre class="line-numbers language-bash"><code class="language-bash">docker attach my_ubuntu_2root@75b28b720835:/<span class="token comment" spellcheck="true">#</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="检查-Docker-镜像历史"><a href="#检查-Docker-镜像历史" class="headerlink" title="检查 Docker 镜像历史"></a>检查 Docker 镜像历史</h3><p>Docker 社区镜像是分层创建的，可使用 Docker history 命令查看镜像创建方式。先看看有哪些镜像：</p><pre class="line-numbers language-bash"><code class="language-bash">docker imagesREPOSITORY          TAG                 IMAGE ID            CREATED             SIZEubuntu              16.04               5e8b97a2a082        2 weeks ago         114MBubuntu              latest              113a43faa138        2 weeks ago         81.2MBnginx               latest              cd5239a0906a        2 weeks ago         109MB<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>查看 nginx 镜像历史：</p><pre class="line-numbers language-bash"><code class="language-bash">docker <span class="token function">history</span> nginxIMAGE               CREATED             CREATED BY                                      SIZE                COMMENTcd5239a0906a        2 weeks ago         /bin/sh -c <span class="token comment" spellcheck="true">#(nop)  CMD ["nginx" "-g" "daemon…   0B</span><span class="token operator">&lt;</span>missing<span class="token operator">></span>           2 weeks ago         /bin/sh -c <span class="token comment" spellcheck="true">#(nop)  STOPSIGNAL [SIGTERM]         0B</span><span class="token operator">&lt;</span>missing<span class="token operator">></span>           2 weeks ago         /bin/sh -c <span class="token comment" spellcheck="true">#(nop)  EXPOSE 80/tcp                0B</span><span class="token operator">&lt;</span>missing<span class="token operator">></span>           2 weeks ago         /bin/sh -c <span class="token function">ln</span> -sf /dev/stdout /var/log/nginx…   22B<span class="token operator">&lt;</span>missing<span class="token operator">></span>           2 weeks ago         /bin/sh -c <span class="token keyword">set</span> -x  <span class="token operator">&amp;&amp;</span> <span class="token function">apt-get</span> update  <span class="token operator">&amp;&amp;</span> apt…   53.7MB<span class="token operator">&lt;</span>missing<span class="token operator">></span>           2 weeks ago         /bin/sh -c <span class="token comment" spellcheck="true">#(nop)  ENV NJS_VERSION=1.15.0.0.…   0B</span><span class="token operator">&lt;</span>missing<span class="token operator">></span>           2 weeks ago         /bin/sh -c <span class="token comment" spellcheck="true">#(nop)  ENV NGINX_VERSION=1.15.0-…   0B</span><span class="token operator">&lt;</span>missing<span class="token operator">></span>           7 weeks ago         /bin/sh -c <span class="token comment" spellcheck="true">#(nop)  LABEL maintainer=NGINX Do…   0B</span><span class="token operator">&lt;</span>missing<span class="token operator">></span>           8 weeks ago         /bin/sh -c <span class="token comment" spellcheck="true">#(nop)  CMD ["bash"]                 0B</span><span class="token operator">&lt;</span>missing<span class="token operator">></span>           8 weeks ago         /bin/sh -c <span class="token comment" spellcheck="true">#(nop) ADD file:ec5be7eec56a74975…   55.3MB</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用镜像历史命令查找最近更改，如果在新版本镜像中发现问题，则此命令可帮助找到原因，也可用以下命令：</p><pre class="line-numbers language-bash"><code class="language-bash">docker image <span class="token function">history</span> nginx<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="Docker-检查容器"><a href="#Docker-检查容器" class="headerlink" title="Docker 检查容器"></a>Docker 检查容器</h3><p>可以使用 docker inspect 命令查找有关系统的信息，运行 docker ps 命令列出 Docker 容器：</p><pre class="line-numbers language-bash"><code class="language-bash">docker <span class="token function">ps</span>CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                  NAMES6162daed25da        nginx               <span class="token string">"nginx -g 'daemon of…"</span>   2 hours ago         Up 2 hours          0.0.0.0:8080-<span class="token operator">></span>80/tcp   hardcore_torvalds<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>使用 CONTAINER ID 检查容器（也可使用容器名称）：</p><pre class="line-numbers language-bash"><code class="language-bash">docker inspect 6162daed25da<span class="token punctuation">[</span><span class="token punctuation">{</span><span class="token string">"Id"</span><span class="token keyword">:</span> <span class="token string">"6162daed25da50b98afca5f7ed8caca2289bf309b2547d87ae8674b899d604a4"</span>,<span class="token string">"Created"</span><span class="token keyword">:</span> <span class="token string">"2018-06-25T05:46:37.902211302Z"</span>,<span class="token string">"Path"</span><span class="token keyword">:</span> <span class="token string">"nginx"</span>,<span class="token string">"Args"</span><span class="token keyword">:</span> <span class="token punctuation">[</span>………<span class="token string">"DriverOpts"</span><span class="token keyword">:</span> null<span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>该命令将以 JSON 格式提供大量信息，以下是查找容器 IP 地址的技巧：</p><pre class="line-numbers language-bash"><code class="language-bash">docker inspect 6162daed25da <span class="token operator">|</span> <span class="token function">grep</span> <span class="token string">"IPAddress"</span>            <span class="token string">"SecondaryIPAddresses"</span><span class="token keyword">:</span> null,            <span class="token string">"IPAddress"</span><span class="token keyword">:</span> <span class="token string">"172.17.0.2"</span>,                    <span class="token string">"IPAddress"</span><span class="token keyword">:</span> <span class="token string">"172.17.0.2"</span>,<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="容器与主机间文件复制"><a href="#容器与主机间文件复制" class="headerlink" title="容器与主机间文件复制"></a>容器与主机间文件复制</h3><p>再次列出 Docker 容器：</p><pre class="line-numbers language-bash"><code class="language-bash">docker <span class="token function">ps</span>CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                  NAMES6162daed25da        nginx               <span class="token string">"nginx -g 'daemon of…"</span>   3 hours ago         Up 3 hours          0.0.0.0:8080-<span class="token operator">></span>80/tcp   hardcore_torvalds<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>NGINX 容器在端口 8080 上运行。因此，如果转到 http//localhost:8080，将看到以下内容：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token string">"Welcome to nginx!"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果看到此页面，则 nginx Web 服务器已成功安装并正常运行，需要进一步配置。<br>首先，在本地目录中创建 index.html：</p><pre class="line-numbers language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>header</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">></span></span>My Website<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>header</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span>    Hello world  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用带有 ls 的 docker exec 命令检查 NGINX 容器中具有 index.html 的文件夹：</p><pre class="line-numbers language-bash"><code class="language-bash">docker <span class="token function">exec</span> -it hardcore_torvalds <span class="token function">ls</span> /usr/share/nginx/html50x.html index.html<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>使用创建的本地文件覆盖容器 index.html 文件：</p><pre class="line-numbers language-bash"><code class="language-bash">docker <span class="token function">cp</span> index.html hardcore_torvalds:usr/share/nginx/html/<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果再次检查<a href="http://localhost/" target="_blank" rel="noopener">http://localhost:</a>8080，应该可以看到问候语“Hello world”。<br>可使用 docker cp 命令在本地计算机和创建容器间移动文件，此方法可用于覆盖配置文件。</p><h3 id="创建-Docker-镜像"><a href="#创建-Docker-镜像" class="headerlink" title="创建 Docker 镜像"></a>创建 Docker 镜像</h3><p>如果想复制更多“Hello World”容器，必须将当前容器保存为镜像。<br>首先，停止容器：</p><pre class="line-numbers language-bash"><code class="language-bash">docker stop hardcore_torvalds<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>列出所有 Docker 容器：</p><pre class="line-numbers language-bash"><code class="language-bash">docker <span class="token function">ps</span> -aCONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS                         PORTS               NAMES75b28b720835        ubuntu:latest       <span class="token string">"bash"</span>                   About an hour ago   Exited <span class="token punctuation">(</span>0<span class="token punctuation">)</span> About an hour ago                       my_ubuntu_2a19c770b8621        ubuntu:latest       <span class="token string">"bash"</span>                   2 hours ago         Exited <span class="token punctuation">(</span>0<span class="token punctuation">)</span> About an hour ago                       my_ubuntu6162daed25da        nginx               <span class="token string">"nginx -g 'daemon of…"</span>   3 hours ago         Exited <span class="token punctuation">(</span>0<span class="token punctuation">)</span> 27 seconds ago                          hardcore_torvalds<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>从 STATUS 中，可以看到 NGINX’corecore_torvalds’容器已停止。使用 docker commit 命令创建新镜像：</p><pre class="line-numbers language-bash"><code class="language-bash">docker commit 6162daed25da nginx_hello_world_templatesha256:117d060587a316035ed5a776e613d9cfbeee9fbfe202c6edc9203820c7da987b<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>如果现在检查，将看到新镜像：</p><pre class="line-numbers language-bash"><code class="language-bash">docker imagesREPOSITORY                   TAG                 IMAGE ID            CREATED             SIZEnginx_hello_world_template   latest              117d060587a3        40 seconds ago      109MBubuntu                       16.04               5e8b97a2a082        2 weeks ago         114MBubuntu                       latest              113a43faa138        2 weeks ago         81.2MBnginx                        latest              cd5239a0906a        2 weeks ago         109MB<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以使用此镜像并启动新 Docker 容器，新创建容器将具有“Hello world”页面，而不是“Welcome NGINX”页面。示例如下：</p><pre class="line-numbers language-bash"><code class="language-bash">docker run -it -d -p 8886:80 nginx_hello_world_template4e042d76c39125471951626ba42cd609a65c73f041943298f74f4fc43dc5596a$<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="删除-Docker-容器和镜像"><a href="#删除-Docker-容器和镜像" class="headerlink" title="删除 Docker 容器和镜像"></a>删除 Docker 容器和镜像</h3><p>Docker 容器和镜像会占用硬盘空间，因此最好定期清理。首先停止所有容器，然后列出所有容器，使用以下 Docker 命令执行操作：</p><pre class="line-numbers language-bash"><code class="language-bash">docker <span class="token function">ps</span> -aCONTAINER ID        IMAGE                        COMMAND                  CREATED             STATUS                         PORTS               NAMES4e042d76c391        nginx_hello_world_template   <span class="token string">"nginx -g 'daemon of…"</span>   2 minutes ago       Exited <span class="token punctuation">(</span>0<span class="token punctuation">)</span> 8 seconds ago                           boring_keldysh75b28b720835        ubuntu:latest                <span class="token string">"bash"</span>                   2 hours ago         Exited <span class="token punctuation">(</span>0<span class="token punctuation">)</span> About an hour ago                       my_ubuntu_2a19c770b8621        ubuntu:latest                <span class="token string">"bash"</span>                   2 hours ago         Exited <span class="token punctuation">(</span>0<span class="token punctuation">)</span> About an hour ago                       my_ubuntu6162daed25da        nginx                        <span class="token string">"nginx -g 'daemon of…"</span>   3 hours ago         Exited <span class="token punctuation">(</span>0<span class="token punctuation">)</span> 11 minutes ago                          hardcore_torvalds<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如上，有 4 个处于停止状态的容器，可使用 docker rm 命令删除容器：</p><pre class="line-numbers language-bash"><code class="language-bash">docker <span class="token function">rm</span> 4e042d76c391 75b28b720835 a19c770b8621 6162daed25da4e042d76c39175b28b720835a19c770b86216162daed25da<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可使用 NAMES 代替 CONTAINER ID，容器列表现在应该是干净的：</p><pre class="line-numbers language-bash"><code class="language-bash">docker <span class="token function">ps</span> -aCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>列出 Docker 镜像：</p><pre class="line-numbers language-bash"><code class="language-bash">docker imagesREPOSITORY                   TAG                 IMAGE ID            CREATED             SIZEnginx_hello_world_template   latest              117d060587a3        11 minutes ago      109MBubuntu                       16.04               5e8b97a2a082        2 weeks ago         114MBubuntu                       latest              113a43faa138        2 weeks ago         81.2MBnginx                        latest              cd5239a0906a        2 weeks ago         109MB<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可使用 docker rmi 命令和 IMAGE ID 删除 docker 镜像：</p><pre class="line-numbers language-bash"><code class="language-bash">docker rmi 117d060587a3 5e8b97a2a082 113a43faa138 cd5239a0906a<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>最后，Docker 镜像列表应该是干净的：</p><pre class="line-numbers language-bash"><code class="language-bash">docker imagesREPOSITORY TAG IMAGE ID CREATED SIZE<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://dzone.com/articles/top-docker-commands-itsyndicate" target="_blank" rel="noopener">Top Docker Commands Any Expert Should Know</a></li><li>官方文档：<a href="https://docs.docker.com/engine/reference/commandline/docker/" target="_blank" rel="noopener">Docker CLI reference</a></li></ul><h2 id="相关文章"><a href="#相关文章" class="headerlink" title="相关文章"></a>相关文章</h2><ul><li>上一篇：<a href="https://www.lixl.cn/books/Docker/8-kubernetes/">Docker必知必会系列（八）：从 Docker 进阶到 Kubernetes</a></li><li>下一篇：<a href="https://www.lixl.cn/books/Docker/appendix2-dockerfile-best-practices/">Docker必知必会系列（附录2）：Dockerfile 参考及最佳实践</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DevOps </tag>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>八、从 Docker 进阶到 Kubernetes</title>
      <link href="/2020/022827624.html"/>
      <url>/2020/022827624.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文是《<a href="https://www.lixl.cn/books/Docker/1-Overview/">Docker必知必会系列</a>》第八篇，原文发布于个人博客：<a href="https://www.lixl.cn/">悟尘记</a>。</p><p>上一篇：<a href="https://www.lixl.cn/books/Docker/7-Docker-Compose/">Docker必知必会系列（七）：Docker Compose 入门实践</a></p></blockquote><h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><h3 id="1、Kubernetes-是什么"><a href="#1、Kubernetes-是什么" class="headerlink" title="1、Kubernetes 是什么"></a>1、Kubernetes 是什么</h3><p>Kubernetes (K8s) 是 Google 基于 <a href="https://research.google.com/pubs/pub43438.html" target="_blank" rel="noopener">Borg</a> 开源的容器编排调度引擎，是<a href="https://www.lixl.cn/2020/03214710.html">云原生应用</a>的基石，已成为事实标准。基于规范描述集群架构，定义服务的最终状态，并使系统自动地达到和维持该状态。</p><p><img src="https://pic.lixl.cn/2020/container_evolution.svg" alt="部署演进"></p><p>上图揭示了从<strong>传统部署时代</strong> 到 <strong>虚拟化部署时代</strong> 再到 <strong>容器部署时代</strong> 的演进过程。</p><h3 id="2、为什么需要-Kubernetes"><a href="#2、为什么需要-Kubernetes" class="headerlink" title="2、为什么需要 Kubernetes"></a>2、为什么需要 Kubernetes</h3><p>在生产环境中，您需要管理运行应用程序的容器，并确保不会停机。例如，如果一个容器发生故障，则需要启动另一个容器。如果有个系统工具来处理这些需求，会不会更容易？这就是 Kubernetes！</p><p>Kubernetes 提供了一个可弹性运行分布式系统的框架。满足扩展、故障转移、部署模式等要求。提供：</p><ul><li><p><strong>服务发现和负载均衡</strong><br>Kubernetes 可以使用 DNS 名称或自己的 IP 地址公开容器，并提供负载均衡来分配网络流量。</p></li><li><p><strong>存储编排</strong><br>Kubernetes 允许您自动挂载您选择的存储系统，例如本地存储、公共云提供商等。</p></li><li><p><strong>自动部署和回滚</strong><br>您可以使用 Kubernetes 描述已部署容器的所需状态，它可以以受控的速率将实际状态更改为所需状态。例如，Kubernetes 可以自动化为您的部署创建新容器，删除现有容器并将它们的所有资源用于新容器。</p></li><li><p><strong>自动二进制打包</strong><br>Kubernetes 允许您指定每个容器所需 CPU 和内存（RAM）。当容器指定了资源请求时，Kubernetes 可以做出更好的决策来管理容器的资源。</p></li><li><p><strong>自我修复</strong><br>Kubernetes 重新启动失败的容器、替换容器、杀死不响应用户定义的运行状况检查的容器，并且在准备好服务之前不将其通告给客户端。</p></li><li><p><strong>密钥与配置管理</strong><br>Kubernetes 允许您存储和管理敏感信息，例如密码、OAuth 令牌和 ssh 密钥。您可以在不重建容器镜像的情况下部署和更新密钥和应用程序配置，也无需在堆栈配置中暴露密钥。</p></li></ul><blockquote><p>Kubernetes 不是传统的、包罗万象的 PaaS（平台即服务）系统。Kubernetes 提供了构建开发人员平台的基础，但是在重要的地方保留了用户的选择和灵活性。很多云服务商基于K8s来构建自己的PaaS平台。</p></blockquote><h3 id="3、Kubernetes-概述"><a href="#3、Kubernetes-概述" class="headerlink" title="3、Kubernetes 概述"></a>3、Kubernetes 概述</h3><p>要使用 Kubernetes，你需要用 <em>Kubernetes API 对象</em> 来描述集群的 <em>预期状态（desired state）</em> ：包括你需要运行的应用或者负载，它们使用的镜像、副本数，以及所需网络和磁盘资源等等。你可以使用命令行工具 <code>kubectl</code> 来调用 Kubernetes API 创建对象，通过所创建的这些对象来配置预期状态。你也可以直接调用 Kubernetes API 和集群进行交互，设置或者修改预期状态。</p><p>一旦你设置了你所需的目标状态，<code>Kubernetes Control Plane</code> 会通过 Pod 生命周期事件生成器(<a href="https://github.com/kubernetes/community/blob/master/contributors/design-proposals/node/pod-lifecycle-event-generator.md" target="_blank" rel="noopener">PLEG</a>)使集群的当前状态与预期匹配。为此，Kubernetes 会自动执行各类任务，比如运行或者重启容器、调整给定应用的副本数等等。</p><h4 id="Kubernetes-Control-Plane"><a href="#Kubernetes-Control-Plane" class="headerlink" title="Kubernetes Control Plane"></a>Kubernetes Control Plane</h4><p><code>Kubernetes Control Plane</code> 管理 Kubernetes 如何与你的集群进行通信。维护系统中所有的 Kubernetes 对象的状态记录，并且通过连续的控制循环来管理这些对象的状态。在任意的给定时间点，<code>Kubernetes Control Plane</code>的控制环都能响应集群中的变化，并且让系统中所有对象的实际状态与你提供的预期状态相匹配。</p><h5 id="Kubernetes-Master-节点"><a href="#Kubernetes-Master-节点" class="headerlink" title="Kubernetes Master 节点"></a>Kubernetes Master 节点</h5><p>Kubernetes master 节点负责维护集群的目标状态，包括多个进程。通常这些进程都运行在集群中一个单独的节点上，这个节点被称为 master 节点。当你要与 Kubernetes 通信时，使用如 <code>kubectl</code> 的命令行工具，就可以直接与 Kubernetes master 节点进行通信。Master节点包含的进程如下：</p><ul><li><a href="https://kubernetes.io/docs/admin/kube-apiserver/" target="_blank" rel="noopener">kube-apiserver</a>：所有其他组件通过与 <code>apiserver</code> 接口交互，实现集群状态管理。</li><li><a href="https://kubernetes.io/docs/admin/kube-controller-manager/" target="_blank" rel="noopener">kube-controller-manager</a>：一个用于调节系统状态的守护进程，通过 <code>apiserver</code> 监视集群状态，并保持当前状态与所需状态一致。</li><li><a href="https://kubernetes.io/docs/admin/kube-scheduler/" target="_blank" rel="noopener">kube-scheduler</a>：负责Pod调度。</li></ul><blockquote><p>master 节点也可以扩展副本数，来获取更好的可用性及冗余。</p></blockquote><h5 id="Kubernetes-Node-节点"><a href="#Kubernetes-Node-节点" class="headerlink" title="Kubernetes Node 节点"></a>Kubernetes Node 节点</h5><p>集群中的 Node 节点（虚拟机、物理机等等）都是用来运行你的应用和云工作流的机器。Master 节点控制所有 Node 节点；你很少需要和 Node 节点进行直接通信。</p><p>集群中的每个 Node 节点运行两个进程:</p><ul><li><a href="https://kubernetes.io/docs/admin/kubelet/" target="_blank" rel="noopener">kubelet</a>：和 master 节点进行通信。</li><li><a href="https://kubernetes.io/docs/admin/kube-proxy/" target="_blank" rel="noopener">kube-proxy</a>：将 Kubernetes 的网络服务代理到每个节点上。</li></ul><h3 id="4、Kubernetes-对象"><a href="#4、Kubernetes-对象" class="headerlink" title="4、Kubernetes 对象"></a>4、Kubernetes 对象</h3><p>Kubernetes 包含若干用来表示系统状态的抽象层，包括：已部署的容器化应用和负载、与它们相关的网络和磁盘资源以及有关集群正在运行的其他操作的信息。这些抽象使用 Kubernetes API 对象来表示。</p><p><em>Kubernetes 对象</em> 是持久化的实体，表示整个集群的状态。具体来说，它们描述了如下信息：</p><ul><li>哪些容器化应用在运行（以及在哪个 Node 上）</li><li>可以被应用使用的资源</li><li>关于应用运行时表现的策略，比如重启策略、升级策略，以及容错策略</li></ul><p>对象一旦创建，Kubernetes 系统将持续工作以确保对象存在。通过创建对象，本质上是在告知 Kubernetes 系统，所需要的集群工作负载看起来是什么样子的，这就是 Kubernetes 集群的 <strong>期望状态（Desired State）</strong>。</p><p>操作 Kubernetes 对象需要使用 <a href="https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md" target="_blank" rel="noopener">Kubernetes API</a>。比如，当使用 <code>kubectl</code> 命令行接口时，CLI 会执行必要的 Kubernetes API 调用，也可以在程序中使用 <a href="https://kubernetes.io/docs/reference/using-api/client-libraries/" target="_blank" rel="noopener">客户端库</a> 直接调用 Kubernetes API。</p><p>基本的 Kubernetes 对象包括：</p><ul><li><strong>Pod</strong>：Kubernetes 的原子对象，表示您的集群上一组正在运行的容器。</li><li><strong>Service</strong>：将运行在一组 Pods 上的应用程序公开为网络服务的抽象方法。</li><li><strong>Volume</strong>：包含可被 Pod 中容器访问的数据的目录。</li><li><strong>Namespace</strong>：命名空间是 Kubernetes 为了在同一物理集群上支持多个虚拟集群而使用的一种抽象。</li></ul><p>Kubernetes 也包含大量的被称作 <code>Controller</code> 的高级抽象。控制器基于基本对象构建并提供额外的功能和方便使用的特性。具体包括：</p><ul><li><strong>Deployment</strong>：管理应用副本的 API 对象。</li><li><strong>DaemonSet</strong>：确保 Pod 的副本在集群中的一组节点上运行。</li><li><strong>StatefulSet</strong>：用来管理 Deployment 和扩展一组 Pod，并且能为这些 Pod 提供序号和唯一性保证。</li><li><strong>ReplicaSet</strong>：下一代副本控制器。</li><li><strong>Job</strong>：需要运行完成的确定性的或批量的任务。</li></ul><blockquote><p>有关更多详细信息，请参阅：<a href="https://kubernetes.io/docs/concepts/overview/working-with-objects/kubernetes-objects/" target="_blank" rel="noopener">了解 Kubernetes 对象</a>。</p></blockquote><h2 id="二、Kubernetes-架构"><a href="#二、Kubernetes-架构" class="headerlink" title="二、Kubernetes 架构"></a>二、Kubernetes 架构</h2><p>当部署完 Kubernetes，即拥有了一个完整的集群。 集群由一组被称作节点的机器组成。这些节点上运行 Kubernetes 所管理的容器化应用。每个集群至少有一个工作节点。</p><p>这张图表展示了 Kubernetes 集群中所包含的所有相互关联的组件：</p><p><img src="https://pic.lixl.cn/2020/components-of-kubernetes.png" alt="Components of Kubernetes"></p><h3 id="1、控制平面组件（Control-Plane-Components）"><a href="#1、控制平面组件（Control-Plane-Components）" class="headerlink" title="1、控制平面组件（Control Plane Components）"></a>1、控制平面组件（Control Plane Components）</h3><p>控制平面组件对集群做出全局决策(比如调度)，以及检测和响应集群事件（例如，当不满足部署的 <code>replicas</code> 字段时，启动新的 Pod）。</p><blockquote><p>控制平面组件可以在集群中的任何节点上运行。然而，为了简单起见，设置脚本通常会在同一个计算机上启动所有控制平面组件，并且不会在此计算机上运行用户容器。</p></blockquote><h4 id="kube-apiserver"><a href="#kube-apiserver" class="headerlink" title="kube-apiserver"></a>kube-apiserver</h4><p>主节点上负责提供 Kubernetes API 服务的组件。它是 Kubernetes 控制平面的前端，在设计上考虑了水平扩缩的需要。 换言之，通过部署多个实例可以实现扩缩。 </p><h4 id="etcd"><a href="#etcd" class="headerlink" title="etcd"></a>etcd</h4><p>etcd 是兼具一致性和高可用性的键值数据库，作为保存 Kubernetes 所有集群数据的后台数据库。</p><h4 id="kube-scheduler"><a href="#kube-scheduler" class="headerlink" title="kube-scheduler"></a>kube-scheduler</h4><p>主节点上的组件，该组件监视那些尚未指定运行节点的新创建 Pod，并选择节点让 Pod 在上面运行。</p><p>调度决策考虑的因素包括单个 Pod 和 Pod 集合的资源需求、硬件/软件/策略约束、亲和性和反亲和性规范、数据位置、工作负载间的干扰和最后时限。</p><h4 id="kube-controller-manager"><a href="#kube-controller-manager" class="headerlink" title="kube-controller-manager"></a>kube-controller-manager</h4><p>在主节点上运行控制器的组件。从逻辑上讲，每个控制器都是一个单独的进程，但是为了降低复杂性，它们都被编译到同一个可执行文件，并在一个进程中运行。这些控制器包括:</p><ul><li>节点控制器（Node Controller）: 负责在节点出现故障时进行通知和响应。</li><li>副本控制器（Replication Controller）: 负责为系统中的每个副本控制器对象维护正确数量的 Pod。</li><li>端点控制器（Endpoints Controller）: 填充端点（Endpoints）对象（即加入 Service 与 Pod）。</li><li>服务帐户和令牌控制器（Service Account &amp; Token Controllers）: 为新的命名空间创建默认帐户和 API 访问令牌.</li></ul><h4 id="云控制器管理器-cloud-controller-manager"><a href="#云控制器管理器-cloud-controller-manager" class="headerlink" title="云控制器管理器-(cloud-controller-manager)"></a>云控制器管理器-(cloud-controller-manager)</h4><p>运行与基础云提供商交互的控制器。下面的控制器可以依赖云提供商:</p><ul><li>节点控制器（Node Controller）: 用于检查云提供商以确定节点是否在云中停止响应后被删除。</li><li>路由控制器（Route Controller）: 用于在底层云基础架构中设置路由。</li><li>服务控制器（Service Controller）: 用于创建、更新和删除云提供商负载均衡器。</li><li>数据卷控制器（Volume Controller）: 用于创建、附加和装载卷、并与云提供商进行交互以编排卷。</li></ul><h3 id="2、Node-组件"><a href="#2、Node-组件" class="headerlink" title="2、Node 组件"></a>2、Node 组件</h3><p>节点（Node）是执行工作的机器，根据您的集群环境，节点可以是一个虚拟机或者物理机器。每个节点都包含用于运行 Pods 的必要服务，包括容器运行环境、kubelet 和 kube-proxy。</p><h4 id="kubelet"><a href="#kubelet" class="headerlink" title="kubelet"></a>kubelet</h4><p>一个在集群中每个节点上运行的代理。它保证容器都运行在 Pod 中。</p><p><code>kubelet</code> 接收一组通过各类机制提供给它的 <code>PodSpecs</code>，确保这些 <code>PodSpecs</code> 中描述的容器处于运行状态且健康。<code>kubelet</code> 不会管理不是由 Kubernetes 创建的容器。</p><h4 id="kube-proxy"><a href="#kube-proxy" class="headerlink" title="kube-proxy"></a>kube-proxy</h4><p><code>kube-proxy</code> 是集群中每个节点上运行的网络代理，实现 Kubernetes Service 概念的一部分。<code>kube-proxy</code> 维护节点上的网络规则。这些网络规则允许从集群内部或外部的网络会话与 Pod 进行网络通信。</p><h4 id="容器运行环境-Container-Runtime"><a href="#容器运行环境-Container-Runtime" class="headerlink" title="容器运行环境(Container Runtime)"></a>容器运行环境(Container Runtime)</h4><p>容器运行环境是负责运行容器的软件。Kubernetes 支持 <a href="http://www.docker.com/" target="_blank" rel="noopener">Docker</a>、 <a href="https://containerd.io/" target="_blank" rel="noopener">containerd</a>、<a href="https://cri-o.io/" target="_blank" rel="noopener">cri-o</a>、 <a href="https://github.com/kubernetes-incubator/rktlet" target="_blank" rel="noopener">rktlet</a> 等多种运行环境。</p><h3 id="3、插件-Addons"><a href="#3、插件-Addons" class="headerlink" title="3、插件(Addons)"></a>3、插件(Addons)</h3><p>插件使用 Kubernetes 资源 (DaemonSet, Deployment等) 扩展了集群功能。因为其提供了集群级别的特性，所以插件的命名空间属于 <code>kube-system</code> 。有关可用插件的扩展列表，请参见：<a href="https://kubernetes.io/docs/concepts/cluster-administration/addons/" target="_blank" rel="noopener">插件 (Addons)</a></p><h2 id="三、部署-Kubernetes"><a href="#三、部署-Kubernetes" class="headerlink" title="三、部署 Kubernetes"></a>三、部署 Kubernetes</h2><p>您可以在本地机器、云、本地数据中心上部署 Kubernetes 集群，或选择一个托管的 Kubernetes 集群。还可以跨各种云提供商或裸机环境创建自定义解决方案。</p><p>为了学习 Kubernetes，建议使用基于 Docker 的解决方案：Docker 是 Kubernetes 社区支持或生态系统中用来在本地计算机上设置 Kubernetes 集群的一种工具。如果是为了生产环境，您应该认真评估适当的解决方案，具体请参照<a href="https://kubernetes.io/zh/docs/setup/" target="_blank" rel="noopener">官方文档</a>。</p><h3 id="1、Docker-Desktop-启用-Kubernetes"><a href="#1、Docker-Desktop-启用-Kubernetes" class="headerlink" title="1、Docker Desktop 启用 Kubernetes"></a>1、Docker Desktop 启用 Kubernetes</h3><p>在 Docker Desktop 的 <code>Preferences</code> 页面，点击 <code>Kubernetes</code>，选择 <code>Enable Kubernetes</code>，待左下角的 <code>Kubernetes</code> 状态变为 <code>running</code>时，Kubernetes 即已启动成功。</p><p><img src="https://pic.lixl.cn/2020/image-20200428212035887.png" alt="在 Docker Desktop 中启用 Kubernetes"></p><p>在控制台执行 <code>kubectl version</code>，能够正常输出信息，则说明Kubernetes 已经成功启动。</p><pre class="line-numbers language-bash"><code class="language-bash">$ kubectl versionClient Version: version.Info<span class="token punctuation">{</span>Major:<span class="token string">"1"</span>, Minor:<span class="token string">"16+"</span>, GitVersion:<span class="token string">"v1.16.6-beta.0"</span>, GitCommit:<span class="token string">"e7f962ba86f4ce7033828210ca3556393c377bcc"</span>, GitTreeState:<span class="token string">"clean"</span>, BuildDate:<span class="token string">"2020-01-15T08:26:26Z"</span>, GoVersion:<span class="token string">"go1.13.5"</span>, Compiler:<span class="token string">"gc"</span>, Platform:<span class="token string">"darwin/amd64"</span><span class="token punctuation">}</span>Server Version: version.Info<span class="token punctuation">{</span>Major:<span class="token string">"1"</span>, Minor:<span class="token string">"16+"</span>, GitVersion:<span class="token string">"v1.16.6-beta.0"</span>, GitCommit:<span class="token string">"e7f962ba86f4ce7033828210ca3556393c377bcc"</span>, GitTreeState:<span class="token string">"clean"</span>, BuildDate:<span class="token string">"2020-01-15T08:18:29Z"</span>, GoVersion:<span class="token string">"go1.13.5"</span>, Compiler:<span class="token string">"gc"</span>, Platform:<span class="token string">"linux/amd64"</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>如果您使用的是 <a href="http://ohmyz.sh/" target="_blank" rel="noopener">Oh-My-Zsh</a>，可通过编辑 <code>~/.zshrc</code> 文件，添加 kubectl 插件以启用 kubectl 自动补全功能。</p><pre class="line-numbers language-properties"><code class="language-properties"><span class="token attr-name">plugins</span><span class="token punctuation">=</span><span class="token attr-value">(kubectl)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="2、安装-Dashboard"><a href="#2、安装-Dashboard" class="headerlink" title="2、安装 Dashboard"></a>2、安装 Dashboard</h3><p>Dashboard 是官方提供的基于网页的 Kubernetes 用户管理界面。您可以使用 Dashboard 将容器应用部署到 Kubernetes 集群中，也可以对容器应用排错，还能管理集群资源。您可以使用 Dashboard 获取运行在集群中的应用的概览信息，也可以创建或者修改 Kubernetes 资源（如 Deployment，Job，DaemonSet 等等）。例如，您可以对 Deployment 实现弹性伸缩、发起滚动升级、重启 Pod 或者使用向导创建新的应用。</p><p>默认情况下不会部署 Dashboard。可以通过以下命令部署：</p><pre class="line-numbers language-bash"><code class="language-bash">kubectl apply -f https://raw.githubusercontent.com/kubernetes/dashboard/v2.0.0/aio/deploy/recommended.yaml<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在要访问 Dashboard 的机器上执行 <code>kubectl proxy</code> 命令，然后就可以通过 <code>http://localhost:8001/api/v1/namespaces/kubernetes-dashboard/services/https:kubernetes-dashboard:/proxy/</code> 地址访问 Dashboard了。</p><p>当前，Dashboard 仅支持使用 Bearer 令牌登录。 接下来，我们将创建一个名为 <code>admin-user</code> 的服务账号，并为其创建 ClusterRoleBinding。</p><p>将以下内容复制到 <code>dashboard-adminuser.yaml</code> 文件中。</p><pre class="line-numbers language-yml"><code class="language-yml">apiVersion: v1kind: ServiceAccountmetadata:  name: admin-user  namespace: kubernetes-dashboard---apiVersion: rbac.authorization.k8s.io/v1kind: ClusterRoleBindingmetadata:  name: admin-userroleRef:  apiGroup: rbac.authorization.k8s.io  kind: ClusterRole  name: cluster-adminsubjects:- kind: ServiceAccount  name: admin-user  namespace: kubernetes-dashboard<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后执行：</p><pre class="line-numbers language-bash"><code class="language-bash">kubectl apply -f dashboard-adminuser.yaml<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>找到可以用来登录的令牌:</p><pre class="line-numbers language-bash"><code class="language-bash">$ kubectl -n kubernetes-dashboard describe secret <span class="token punctuation">$(</span>kubectl -n kubernetes-dashboard get secret <span class="token operator">|</span> <span class="token function">grep</span> admin-user <span class="token operator">|</span> <span class="token function">awk</span> <span class="token string">'{print <span class="token variable">$1</span>}'</span><span class="token punctuation">)</span>Name:         admin-user-token-8mgwpNamespace:    kubernetes-dashboardLabels:       <span class="token operator">&lt;</span>none<span class="token operator">></span>Annotations:  kubernetes.io/service-account.name: admin-user              kubernetes.io/service-account.uid: c32b99ea-a002-4e00-afdf-58ce40fbe5ebType:  kubernetes.io/service-account-tokenData<span class="token operator">==</span><span class="token operator">==</span>ca.crt:     1025 bytesnamespace:  20 bytestoken:      eyJhbGciOiJSUzI1NiIsImtpZCI6IkJPNFJmTFJ1ajBKYm4xMGpvV01vYnRRSDdzRnFmd1ZsbUpPQ0lvdFNJWFkifQ.eyJpc3MiOiJrdWJlcm5ldGVzL3NlcnZpY2VhY2NvdW50Iiwia3<span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span>povxntPXVTJomVTN7mJ-6vBm8m-kCUF6nxA14c8s5Kis22XPGyPgiUmXNAagXJPJH3cFVO0exs5JVzdj3gtvRXQ<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>复制 <code>token</code> 并将其粘贴到登录屏幕上的 <code>Token</code> 字段中。点击登录按钮，就可以以管理员身份登录了。</p><p><img src="https://pic.lixl.cn/2020/image-20200428225417724.png" alt="登录 Kubernetes dashboard"></p><h2 id="四、Kubernetes-动手实践"><a href="#四、Kubernetes-动手实践" class="headerlink" title="四、Kubernetes 动手实践"></a>四、Kubernetes 动手实践</h2><p>一旦运行了 Kubernetes 集群，就可以在其上部署容器化应用程序。 为此，您需要创建 Kubernetes <strong>Deployment</strong> 配置。Deployment 指挥 Kubernetes 如何创建和更新应用程序的实例。创建 Deployment 后，Kubernetes master 将应用程序实例调度到集群中的各个节点上。</p><p>创建应用程序实例后，Kubernetes Deployment 控制器会持续监视这些实例。 如果托管实例的节点关闭或被删除，则 Deployment 控制器会将该实例替换为群集中另一个节点上的实例。 <strong>这提供了一种自我修复机制来解决机器故障维护问题。</strong></p><h3 id="1、环境检查"><a href="#1、环境检查" class="headerlink" title="1、环境检查"></a>1、环境检查</h3><p>通过运行 <code>kubectl version</code> 命令，检查 kubectl 是否已配置为与您的集群通信。运行 <code>kubectl get nodes</code> 命令，查看集群中的节点及pods。</p><pre class="line-numbers language-bash"><code class="language-bash">$ kubectl get nodesNAME             STATUS   ROLES    AGE    VERSIONdocker-desktop   Ready    master   112m   v1.16.6-beta.0$ kubectl get podsNo resources found <span class="token keyword">in</span> default namespace.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在这里，我们看到可用的节点（本例中为1）。 Kubernetes 将根据 Node 可用资源选择将我们的应用程序部署到何处。</p><h3 id="2、基于-kubectl-部署第一个应用"><a href="#2、基于-kubectl-部署第一个应用" class="headerlink" title="2、基于 kubectl 部署第一个应用"></a>2、基于 kubectl 部署第一个应用</h3><p>让我们使用 <code>kubectl create deploy</code> 命令在 Kubernetes 上部署我们的第一个应用程序。</p><p>创建一个名为 k8s-nginx 的 deployment（需要提供部署名称和应用程序镜像位置）：</p><pre class="line-numbers language-bash"><code class="language-bash">$ kubectl create deployment --image nginx k8s-nginxdeployment.apps/k8s-nginx created<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>查看正在运行的 pods，会看到只有一个 pods 正在运行：</p><pre class="line-numbers language-bash"><code class="language-bash">$ kubectl get podsNAME                         READY   STATUS              RESTARTS   AGEk8s-nginx-5c86f54778-92824   0/1     ContainerCreating   0          11s<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>查看创建的 deployment：</p><pre class="line-numbers language-bash"><code class="language-bash">$ kubectl get deploymentNAME        READY   UP-TO-DATE   AVAILABLE   AGEk8s-nginx   0/1     1            0           24s<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>扩展部署，让 2 个 nginx pods 同时运行：</p><pre class="line-numbers language-bash"><code class="language-bash">$ kubectl scale deployment --replicas 2 k8s-nginxdeployment.apps/k8s-nginx scaled<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>列出 pods ，会看到已经变成 2 个 pods 正在运行：</p><pre class="line-numbers language-bash"><code class="language-bash">$ kubectl get podsNAME                         READY   STATUS    RESTARTS   AGEk8s-nginx-5c86f54778-92824   0/1     Running   0          67sk8s-nginx-5c86f54778-j7dch   0/1     Running   0          6s<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>将 pods 暴露到互联网上：</p><pre class="line-numbers language-bash"><code class="language-bash">kubectl expose deployment k8s-nginx --port<span class="token operator">=</span>8086 --type<span class="token operator">=</span>LoadBalancerservice/k8s-nginx exposed<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>查看已经创建的服务，获取服务地址：</p><pre class="line-numbers language-bash"><code class="language-bash">$ kubectl get servicesNAME         TYPE           CLUSTER-IP       EXTERNAL-IP   PORT<span class="token punctuation">(</span>S<span class="token punctuation">)</span>    AGEk8s-nginx    LoadBalancer   10.100.197.113   <span class="token operator">&lt;</span>none<span class="token operator">></span>        8086/TCP   74s<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>要清理这两个自动复制的容器，需要删除 deployment：</p><pre class="line-numbers language-bash"><code class="language-bash">$ kubectl delete deployment k8s-nginxdeployment.apps <span class="token string">"k8s-nginx"</span> deleted<span class="token comment" spellcheck="true"># 再次列出 pods 会发现容器已经被清理。</span>$ kubectl get podsNo resources found <span class="token keyword">in</span> default namespace.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3、基于-Deployments-管理应用"><a href="#3、基于-Deployments-管理应用" class="headerlink" title="3、基于 Deployments 管理应用"></a>3、基于 Deployments 管理应用</h3><p>可以通过创建一个Kubernetes Deployment 对象来运行一个应用，在YAML文件中描述Deployment。</p><p>首先，创建 deployment 描述文件 <code>k8s-nginx-deployment.yaml</code>：</p><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> apps/v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> Deployment<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> k8s<span class="token punctuation">-</span>nginx<span class="token punctuation">-</span>deployment    <span class="token comment" spellcheck="true"># 创建名为 k8s-nginx-deployment 的 Deployment</span>  <span class="token key atrule">labels</span><span class="token punctuation">:</span>    <span class="token key atrule">app</span><span class="token punctuation">:</span> k8s<span class="token punctuation">-</span>nginx<span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">replicas</span><span class="token punctuation">:</span> <span class="token number">3                       </span><span class="token comment" spellcheck="true"># 创建 3 个 Pods</span>  <span class="token key atrule">selector</span><span class="token punctuation">:</span>                        <span class="token comment" spellcheck="true"># 定义 Deployment 如何查找要管理的 Pods</span>    <span class="token key atrule">matchLabels</span><span class="token punctuation">:</span>      <span class="token key atrule">app</span><span class="token punctuation">:</span> k8s<span class="token punctuation">-</span>nginx  <span class="token key atrule">template</span><span class="token punctuation">:</span>    <span class="token key atrule">metadata</span><span class="token punctuation">:</span>      <span class="token key atrule">labels</span><span class="token punctuation">:</span>                    <span class="token comment" spellcheck="true"># 将 Pod 标记为 k8s-nginx</span>        <span class="token key atrule">app</span><span class="token punctuation">:</span> k8s<span class="token punctuation">-</span>nginx    <span class="token key atrule">spec</span><span class="token punctuation">:</span>      <span class="token key atrule">containers</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> k8s<span class="token punctuation">-</span>nginx            <span class="token comment" spellcheck="true"># 指定创建的容器名字为 k8s-nginx</span>        <span class="token key atrule">image</span><span class="token punctuation">:</span> nginx            <span class="token comment" spellcheck="true"># 指定运行 Docker Hub 中 nginx 最新版本镜像</span>        <span class="token key atrule">ports</span><span class="token punctuation">:</span>                    <span class="token comment" spellcheck="true"># 暴露端口</span>        <span class="token punctuation">-</span> <span class="token key atrule">containerPort</span><span class="token punctuation">:</span> <span class="token number">8189</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>通过 <code>kubectl apply</code> 命令创建 Deployment:</p><pre class="line-numbers language-bash"><code class="language-bash">$ kubectl apply -f k8s-nginx-deployment.yamldeployment.apps/k8s-nginx-deployment created<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>运行 <code>kubectl get deployments</code> 以检查 Deployment 是否已创建：</p><pre class="line-numbers language-bash"><code class="language-bash">$ kubectl get deploymentsNAME                   READY   UP-TO-DATE   AVAILABLE   AGEk8s-nginx-deployment   3/3     3            3           47s<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>几秒钟后，Deployment 已创建所有三个副本，并且所有副本都是最新的（它们包含最新的 Pod 模板）并且可用。</p><h4 id="更新-Deployment"><a href="#更新-Deployment" class="headerlink" title="更新 Deployment"></a>更新 Deployment</h4><p>让我们更新 nginx Pods，以使用 <code>nginx:1.9.1</code> 镜像，而不是最新版本。</p><pre class="line-numbers language-bash"><code class="language-bash">$ kubectl --record deployment.apps/k8s-nginx-deployment <span class="token keyword">set</span> image deployment.v1.apps/k8s-nginx-deployment k8s-nginx<span class="token operator">=</span>nginx:1.9.1deployment.apps/k8s-nginx-deployment image updateddeployment.apps/k8s-nginx-deployment image updated<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>查看状态更新：</p><pre class="line-numbers language-bash"><code class="language-bash">$ kubectl rollout status deployment.v1.apps/k8s-nginx-deploymentWaiting <span class="token keyword">for</span> deployment <span class="token string">"k8s-nginx-deployment"</span> rollout to finish: 1 out of 3 new replicas have been updated<span class="token punctuation">..</span>.Waiting <span class="token keyword">for</span> deployment <span class="token string">"k8s-nginx-deployment"</span> rollout to finish: 1 out of 3 new replicas have been updated<span class="token punctuation">..</span>.Waiting <span class="token keyword">for</span> deployment <span class="token string">"k8s-nginx-deployment"</span> rollout to finish: 1 out of 3 new replicas have been updated<span class="token punctuation">..</span>.Waiting <span class="token keyword">for</span> deployment <span class="token string">"k8s-nginx-deployment"</span> rollout to finish: 2 out of 3 new replicas have been updated<span class="token punctuation">..</span>.Waiting <span class="token keyword">for</span> deployment <span class="token string">"k8s-nginx-deployment"</span> rollout to finish: 2 out of 3 new replicas have been updated<span class="token punctuation">..</span>.Waiting <span class="token keyword">for</span> deployment <span class="token string">"k8s-nginx-deployment"</span> rollout to finish: 2 out of 3 new replicas have been updated<span class="token punctuation">..</span>.Waiting <span class="token keyword">for</span> deployment <span class="token string">"k8s-nginx-deployment"</span> rollout to finish: 1 old replicas are pending termination<span class="token punctuation">..</span>.Waiting <span class="token keyword">for</span> deployment <span class="token string">"k8s-nginx-deployment"</span> rollout to finish: 1 old replicas are pending termination<span class="token punctuation">..</span>.deployment <span class="token string">"k8s-nginx-deployment"</span> successfully rolled out<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>更新成功后，可以通过运行 <code>kubectl get deployments</code>来查看 Deployment。</p><pre class="line-numbers language-bash"><code class="language-bash">$ kubectl get deploymentsNAME                   READY   UP-TO-DATE   AVAILABLE   AGEk8s-nginx-deployment   3/3     3            3           14m<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>运行 <code>get pods</code> 现在应仅显示新的 Pods:</p><pre class="line-numbers language-bash"><code class="language-bash">$ kubectl get podsNAME                                    READY   STATUS    RESTARTS   AGEk8s-nginx-deployment-785b758787-jsbtl   1/1     Running   0          2m31sk8s-nginx-deployment-785b758787-xdsl4   1/1     Running   0          4m12sk8s-nginx-deployment-785b758787-zxd7b   1/1     Running   0          2m28s<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>下次要更新这些 Pods 时，只需再次更新 Deployment  Pod 模板。</p><blockquote><p>Deployment 可确保在更新时仅关闭一定数量的 Pods。默认情况下，它确保至少 75%所需 Pods 运行（25%最大不可用）。Deployment 还确保仅创建一定数量的 Pods 高于期望的 Pods 数。默认情况下，它可确保最多增加 25% 期望 Pods 数（25%最大增量）。</p><p>如果仔细查看上述 Deployment ，将看到它首先创建了一个新的 Pod，然后删除了一些旧的 Pods，并创建了新的 Pods。它不会杀死老 Pods，直到有足够的数量新的 Pods 已经出现，并没有创造新的 Pods，直到足够数量的旧 Pods 被杀死。它确保至少 2 个 Pods 可用，并且总共最多 4 个 Pods 可用。</p></blockquote><p>获取 Deployment 的更多信息</p><pre class="line-numbers language-bash"><code class="language-bash">$ kubectl describe deploymentskubectl describe deploymentsName:                   k8s-nginx-deployment<span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span>Events:  Type    Reason             Age    From                   Message  ----    ------             ----   ----                   -------  Normal  ScalingReplicaSet  16m    deployment-controller  Scaled up replica <span class="token keyword">set</span> k8s-nginx-deployment-99f6477fd to 3  Normal  ScalingReplicaSet  6m39s  deployment-controller  Scaled up replica <span class="token keyword">set</span> k8s-nginx-deployment-785b758787 to 1  Normal  ScalingReplicaSet  4m57s  deployment-controller  Scaled down replica <span class="token keyword">set</span> k8s-nginx-deployment-99f6477fd to 2  Normal  ScalingReplicaSet  4m57s  deployment-controller  Scaled up replica <span class="token keyword">set</span> k8s-nginx-deployment-785b758787 to 2  Normal  ScalingReplicaSet  4m54s  deployment-controller  Scaled down replica <span class="token keyword">set</span> k8s-nginx-deployment-99f6477fd to 1  Normal  ScalingReplicaSet  4m54s  deployment-controller  Scaled up replica <span class="token keyword">set</span> k8s-nginx-deployment-785b758787 to 3  Normal  ScalingReplicaSet  4m49s  deployment-controller  Scaled down replica <span class="token keyword">set</span> k8s-nginx-deployment-99f6477fd to 0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到，当第一次创建 Deployment 时，它创建了一个 ReplicaSet  （nginx-deployment-99f6477fd）并将其直接扩展至 3 个副本。更新 Deployment 时，它创建了一个新的 ReplicaSet （nginx-deployment-785b758787），并将其扩展为 1，然后将旧 ReplicaSet 缩小到 2，以便至少有 2 个 Pod 可用，并且最多创建 4 个 Pod。然后，它继续向上和向下扩展新的和旧的 ReplicaSet ，具有相同的滚动更新策略。最后，将有 3 个可用的副本在新的 ReplicaSet 中，旧 ReplicaSet 将缩小到 0。</p><blockquote><p>有时，可能需要回滚 Deployment ；例如，当 Deployment 不稳定时，例如循环崩溃。默认情况下，所有 Deployment 历史记录都保留在系统中，以便可以随时回滚（可以通过修改修改历史记录限制来更改该限制）。</p><p>也可以通过设置自动缩放器，基于现有 Pods 的 CPU 利用率设置要运行 Pods的最小和最大值。</p><p>还可以在触发一个或多个更新之前暂停 Deployment ，然后继续它。这允许在暂停和恢复之间应用多个修补程序，而不会触发不必要的 Deployment 。</p><p>关于 Deployment 的更多信息，请查阅官方文档：<a href="https://kubernetes.io/zh/docs/concepts/workloads/controllers/deployment/" target="_blank" rel="noopener">Deployments</a></p></blockquote><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><p>官方文档：<a href="https://kubernetes.io/zh/docs/home/" target="_blank" rel="noopener">Kubernetes 文档</a></p></li><li><p>官方文档：<a href="https://github.com/kubernetes/dashboard/blob/master/docs/user/access-control/creating-sample-user.md" target="_blank" rel="noopener">Creating sample user</a></p></li><li><p><a href="https://www.huweihuang.com/kubernetes-notes/" target="_blank" rel="noopener">Kubernetes 学习笔记</a></p></li></ul><h2 id="相关文章"><a href="#相关文章" class="headerlink" title="相关文章"></a>相关文章</h2><ul><li>上一篇：<a href="https://www.lixl.cn/books/Docker/7-Docker-Compose/">Docker必知必会系列（七）：Docker Compose 入门实践</a></li><li>下一篇：<a href="https://www.lixl.cn/books/Docker/appendix1-docker-command/">Docker必知必会系列（附录1）：Docker 常用命令及示例</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DevOps </tag>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>七、Docker Compose 入门实践</title>
      <link href="/2020/022828889.html"/>
      <url>/2020/022828889.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文是《<a href="https://www.lixl.cn/books/Docker/1-Overview/">Docker必知必会系列</a>》第七篇，原文发布于个人博客：<a href="https://www.lixl.cn/">悟尘记</a>。</p><p>上一篇：<a href="https://www.lixl.cn/books/Docker/6-Multistage-build/">Docker必知必会系列（六）：基于多阶段构建减小镜像体积降低复杂度</a></p></blockquote><h2 id="一、Docker-Compose-概述"><a href="#一、Docker-Compose-概述" class="headerlink" title="一、Docker Compose 概述"></a>一、Docker Compose 概述</h2><h3 id="1、Docker-Compose-是什么"><a href="#1、Docker-Compose-是什么" class="headerlink" title="1、Docker Compose 是什么"></a>1、Docker Compose 是什么</h3><p> <code>Compose</code> 项目是 <code>Docker</code> 官方支持的开源项目，基于 Python 编写，用于定义和运行多容器Docker应用程序。Compose 使用 YAML 文件来配置应用程序的服务。然后，使用一个命令，就可以从配置中创建并启动所有服务。</p><div class="admonition note"><p>使用 <code>Dockerfile</code> 模板文件，可以让用户很方便的定义一个单独的应用容器。然而，在日常工作中，经常会碰到需要多个容器相互配合来完成某项任务的情况。例如要实现一个 Web 项目，除了 Web 服务容器本身，往往还需要再加上后端的数据库服务容器，甚至还包括负载均衡容器等。<code>Compose</code> 刚好可以满足这样的需求。</p></div><p>Compose 有着用于管理应用程序整个生命周期的各种命令:</p><ul><li>启动、停止和重建服务</li><li>查看正在运行的服务的状态</li><li>实时查看运行服务的日志输出</li><li>仅执行一次命令即可运行整个服务</li></ul><h3 id="2、Compose-使用步骤"><a href="#2、Compose-使用步骤" class="headerlink" title="2、Compose 使用步骤"></a>2、Compose 使用步骤</h3><p>使用 Compose 基本上有三个步骤:</p><ol><li>使用 <code>Dockerfile</code> 定义应用程序的环境，这样它就可以在任何地方复制。</li><li>用 <code>docker-compose. yml</code> 定义组成应用程序的服务，使其可以在一个独立的环境中一起运行。</li><li>运行 <code>docker-Compose up</code> ，Compose 启动并运行您的整个应用程序。</li></ol><h3 id="3、典型-docker-compose-文件示例"><a href="#3、典型-docker-compose-文件示例" class="headerlink" title="3、典型 docker-compose 文件示例"></a>3、典型 docker-compose 文件示例</h3><p>使用 <code>docker-compose</code> 您主要的任务是编写 <code>docker-compose.yml</code> 文件。以下是一个 <code>WordPress</code> 的 yaml 文件模板：</p><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token key atrule">version</span><span class="token punctuation">:</span> <span class="token string">'3'</span>        <span class="token comment" spellcheck="true"># 定义版本，不指定默认为版本 1</span><span class="token key atrule">services</span><span class="token punctuation">:</span>           <span class="token comment" spellcheck="true"># 定义容器，就像 docker run</span>   <span class="token key atrule">db</span><span class="token punctuation">:</span>              <span class="token comment" spellcheck="true"># 容器名称，也是 network 中 DNS 名称</span>     <span class="token key atrule">image</span><span class="token punctuation">:</span> mysql<span class="token punctuation">:</span><span class="token number">5.7   </span><span class="token comment" spellcheck="true"># 镜像，如果自定义镜像可以不指定这个参数，而用 build</span>     <span class="token key atrule">volumes</span><span class="token punctuation">:</span>       <span class="token comment" spellcheck="true"># 定义数据卷，类似 -v</span>       <span class="token punctuation">-</span> db_data<span class="token punctuation">:</span>/var/lib/mysql       <span class="token punctuation">-</span> .<span class="token punctuation">:</span>/lxl80   <span class="token comment" spellcheck="true"># 挂载当前目录到容器中的 /lxl80 目录</span>     <span class="token key atrule">restart</span><span class="token punctuation">:</span> always  <span class="token comment" spellcheck="true"># 类似 --restart。'no' 默认，不自动重启；always 总是自动重启； on-failure 当失败时自动重启；unless-stopped 除非手动停止，否者一直重启</span>     <span class="token key atrule">environment</span><span class="token punctuation">:</span>   <span class="token comment" spellcheck="true"># 定义环境变量，类似 -e</span>       <span class="token key atrule">MYSQL_ROOT_PASSWORD</span><span class="token punctuation">:</span> somewordpress       <span class="token key atrule">MYSQL_DATABASE</span><span class="token punctuation">:</span> wordpress       <span class="token key atrule">MYSQL_USER</span><span class="token punctuation">:</span> wordpress       <span class="token key atrule">MYSQL_PASSWORD</span><span class="token punctuation">:</span> wordpress   <span class="token key atrule">wordpress</span><span class="token punctuation">:</span>      <span class="token comment" spellcheck="true"># 第二个容器</span>     <span class="token key atrule">labels</span><span class="token punctuation">:</span>       <span class="token comment" spellcheck="true"># 为容器添加 Docker 元数据（metadata）信息。</span>       <span class="token key atrule">cn.lixl.title</span><span class="token punctuation">:</span> <span class="token string">"This label will appear on all containers for the web service"</span>     <span class="token key atrule">depends_on</span><span class="token punctuation">:</span>   <span class="token comment" spellcheck="true"># 定义容器之间的关系。启动 wordpress 时会先启动 db</span>       <span class="token punctuation">-</span> db     <span class="token key atrule">image</span><span class="token punctuation">:</span> wordpress<span class="token punctuation">:</span>latest     <span class="token key atrule">ports</span><span class="token punctuation">:</span>        <span class="token comment" spellcheck="true"># 端口，类似 -p</span>       <span class="token punctuation">-</span> <span class="token string">"8000:80"</span>     <span class="token key atrule">restart</span><span class="token punctuation">:</span> always     <span class="token key atrule">environment</span><span class="token punctuation">:</span>       <span class="token key atrule">WORDPRESS_DB_HOST</span><span class="token punctuation">:</span> db<span class="token punctuation">:</span><span class="token number">3306</span>       <span class="token key atrule">WORDPRESS_DB_USER</span><span class="token punctuation">:</span> wordpress       <span class="token key atrule">WORDPRESS_DB_PASSWORD</span><span class="token punctuation">:</span> wordpress<span class="token key atrule">volumes</span><span class="token punctuation">:</span>          <span class="token comment" spellcheck="true"># 可选，需要创建的数据卷，类似 docker volume create</span>  <span class="token key atrule">db_data</span><span class="token punctuation">:</span><span class="token key atrule">networks</span><span class="token punctuation">:</span>         <span class="token comment" spellcheck="true"># 可选，需要创建的网络，类似 docker network create</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="二、Compose安装及卸载"><a href="#二、Compose安装及卸载" class="headerlink" title="二、Compose安装及卸载"></a>二、Compose安装及卸载</h2><h3 id="1、安装-Compose"><a href="#1、安装-Compose" class="headerlink" title="1、安装 Compose"></a>1、安装 Compose</h3><p><code>Docker Desktop</code> for Mac/Windows 自带 <code>docker-compose</code> 二进制文件，安装 Docker 之后可以直接使用。</p><pre class="line-numbers language-bash"><code class="language-bash">$ docker-compose --versiondocker-compose version 1.24.1, build 4667896b<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>在 Linux 上的也安装十分简单，从 <a href="https://github.com/docker/compose/releases" target="_blank" rel="noopener">官方 GitHub Release</a> 处直接下载编译好的二进制文件即可。</p><p>例如，在 Linux 64 位系统上直接下载对应的二进制包。</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">sudo</span> curl -L https://github.com/docker/compose/releases/download/1.24.1/docker-compose-<span class="token variable"><span class="token variable">`</span><span class="token function">uname</span> -s<span class="token variable">`</span></span>-<span class="token variable"><span class="token variable">`</span><span class="token function">uname</span> -m<span class="token variable">`</span></span> <span class="token operator">></span> /usr/local/bin/docker-compose<span class="token function">sudo</span> <span class="token function">chmod</span> +x /usr/local/bin/docker-compose<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="2、卸载-Compose"><a href="#2、卸载-Compose" class="headerlink" title="2、卸载 Compose"></a>2、卸载 Compose</h3><p>如果基于 <code>curl</code> 安装，通过以下命令卸载Docker Compose ：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">rm</span> /usr/local/bin/docker-compose<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果基于 <code>pip</code> 安装，通过以下命令卸载Docker Compose ：</p><pre class="line-numbers language-bash"><code class="language-bash">pip uninstall docker-compose<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="三、Docker-Compose-入门"><a href="#三、Docker-Compose-入门" class="headerlink" title="三、Docker Compose 入门"></a>三、Docker Compose 入门</h2><h3 id="关键术语"><a href="#关键术语" class="headerlink" title="关键术语"></a>关键术语</h3><p>   <code>Compose</code> 中有两个重要的概念：</p><ul><li><p>服务 (<code>service</code>)：一个应用的容器，实际上可以包括若干运行相同镜像的容器实例。</p></li><li><p>项目 (<code>project</code>)：由一组关联的应用容器组成的一个完整业务单元，在 <code>docker-compose.yml</code> 文件中定义。</p></li></ul><p>可见，一个项目可以由多个服务（容器）关联而成，<code>Compose</code> 面向项目进行管理。</p><h3 id="示例应用介绍"><a href="#示例应用介绍" class="headerlink" title="示例应用介绍"></a>示例应用介绍</h3><p>接下来，将构建一个运行在 Docker Compose 上的简单 Python web 应用程序。 该应用程序使用了 Flask 框架，并在 Redis 维护了一个点击计数器。</p><p>首选，需要确保已经安装了 Docker 引擎和 Docker Compose。 不需要安装 Python 或 Redis，因为它们都是由 Docker 镜像提供的。</p><h3 id="第一步：设置"><a href="#第一步：设置" class="headerlink" title="第一步：设置"></a>第一步：设置</h3><p>定义应用程序的依赖关系：</p><p>1、为项目创建一个目录：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">mkdir</span> composetest<span class="token function">cd</span> composetest<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>2、在项目目录中创建一个名为 app.py 的文件，内容如下：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> time<span class="token keyword">import</span> redis<span class="token keyword">from</span> flask <span class="token keyword">import</span> Flaskapp <span class="token operator">=</span> Flask<span class="token punctuation">(</span>__name__<span class="token punctuation">)</span>cache <span class="token operator">=</span> redis<span class="token punctuation">.</span>Redis<span class="token punctuation">(</span>host<span class="token operator">=</span><span class="token string">'redis'</span><span class="token punctuation">,</span> port<span class="token operator">=</span><span class="token number">6379</span><span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">get_hit_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    retries <span class="token operator">=</span> <span class="token number">5</span>    <span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>        <span class="token keyword">try</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> cache<span class="token punctuation">.</span>incr<span class="token punctuation">(</span><span class="token string">'hits'</span><span class="token punctuation">)</span>        <span class="token keyword">except</span> redis<span class="token punctuation">.</span>exceptions<span class="token punctuation">.</span>ConnectionError <span class="token keyword">as</span> exc<span class="token punctuation">:</span>            <span class="token keyword">if</span> retries <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>                <span class="token keyword">raise</span> exc            retries <span class="token operator">-=</span> <span class="token number">1</span>            time<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span><span class="token number">0.5</span><span class="token punctuation">)</span>@app<span class="token punctuation">.</span>route<span class="token punctuation">(</span><span class="token string">'/'</span><span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">hello</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    count <span class="token operator">=</span> get_hit_count<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> <span class="token string">'Hello World! I have been seen {} times.\n'</span><span class="token punctuation">.</span>format<span class="token punctuation">(</span>count<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在本例中，redis 是应用程序网络上 redis 容器的主机名。 这里使用 Redis 的默认端口，6379。</p><p>3、在项目目录中创建另一个叫 <code>requirements.txt</code> 的文件，内容如下：</p><pre class="line-numbers language-python"><code class="language-python">flaskredis<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="第二步：创建一个Dockerfile"><a href="#第二步：创建一个Dockerfile" class="headerlink" title="第二步：创建一个Dockerfile"></a>第二步：创建一个Dockerfile</h3><p>在这个步骤中，将编写一个 <code>Dockerfile</code> 来构建一个 Docker 镜像。镜像包含 Python 应用程序所需的所有依赖项，包括 Python 本身。</p><p>在项目目录中，创建一个名为 Dockerfile 的文件，内容如下：</p><pre class="line-numbers language-dockerfile"><code class="language-dockerfile">FROM python:3.7-alpineWORKDIR /codeENV FLASK_APP app.pyENV FLASK_RUN_HOST 0.0.0.0RUN apk add --no-cache gcc musl-dev linux-headersCOPY requirements.txt requirements.txtRUN pip install -r requirements.txtCOPY . .CMD ["flask", "run"]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这告诉 Docker：</p><ul><li>基于 Python 3.7 镜像构建</li><li>将工作目录设置为 <code>/code</code></li><li>设置 <code>flask</code> 命令使用的环境变量</li><li>安装 gcc，以便诸如 MarkupSafe 和 SQLAlchemy 之类的 Python 包可以加速编译</li><li>复制 <code>requirements.txt</code> 并安装 Python 依赖项</li><li>将主机上的项目目录（当前目录）复制到镜像中的 <code>.</code> 工作目录</li><li>将容器的默认命令设置为 <code>flask run</code></li></ul><h3 id="第三步：用-Compose-文件定义服务"><a href="#第三步：用-Compose-文件定义服务" class="headerlink" title="第三步：用 Compose 文件定义服务"></a>第三步：用 Compose 文件定义服务</h3><p>在项目目录中创建一个名为 <code>docker-compose.yml</code> 的文件，内容如下：</p><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token key atrule">version</span><span class="token punctuation">:</span> <span class="token string">'3'</span><span class="token key atrule">services</span><span class="token punctuation">:</span>  <span class="token key atrule">web</span><span class="token punctuation">:</span>    <span class="token key atrule">build</span><span class="token punctuation">:</span> .   <span class="token comment" spellcheck="true"># 相当于 docker build .</span>    <span class="token key atrule">ports</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> <span class="token string">"5000:5000"</span>  <span class="token key atrule">redis</span><span class="token punctuation">:</span>    <span class="token key atrule">image</span><span class="token punctuation">:</span> <span class="token string">"redis:alpine"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>此 Compose 文件定义了两个服务：<code>web</code> 和 <code>redis</code>。</p><p><code>web</code>服务使用从当前目录中的 <code>Dockerfile</code> 构建的镜像。然后将容器和主机绑定到公开端口 5000。 此示例服务使用 Flask web 服务器的默认端口5000。</p><p>Redis 服务使用从 dockerhub 注册表中提取的公共 Redis 镜像。</p><h3 id="第四步：用-Compose-构建和运行应用"><a href="#第四步：用-Compose-构建和运行应用" class="headerlink" title="第四步：用 Compose 构建和运行应用"></a>第四步：用 Compose 构建和运行应用</h3><p>1、在项目目录中，通过运行 <code>docker-compose up</code> 启动应用程序。</p><pre class="line-numbers language-bash"><code class="language-bash">$ docker-compose upCreating network <span class="token string">"composetest_default"</span> with the default driverCreating composetest_web_1 <span class="token punctuation">..</span>.Creating composetest_redis_1 <span class="token punctuation">..</span>.Creating composetest_web_1Creating composetest_redis_1 <span class="token punctuation">..</span>. <span class="token keyword">done</span>Attaching to composetest_web_1, composetest_redis_1web_1    <span class="token operator">|</span>  * Running on http://0.0.0.0:5000/ <span class="token punctuation">(</span>Press CTRL+C to quit<span class="token punctuation">)</span>redis_1  <span class="token operator">|</span> 1:C 17 Aug 22:11:10.480 <span class="token comment" spellcheck="true"># oO0OoO0OoO0Oo Redis is starting oO0OoO0OoO0Oo</span>redis_1  <span class="token operator">|</span> 1:C 17 Aug 22:11:10.480 <span class="token comment" spellcheck="true"># Redis version=4.0.1, bits=64, commit=00000000, modified=0, pid=1, just started</span>redis_1  <span class="token operator">|</span> 1:C 17 Aug 22:11:10.480 <span class="token comment" spellcheck="true"># Warning: no config file specified, using the default config. In order to specify a config file use redis-server /path/to/redis.conf</span>web_1    <span class="token operator">|</span>  * Restarting with <span class="token function">stat</span>redis_1  <span class="token operator">|</span> 1:M 17 Aug 22:11:10.483 * Running mode<span class="token operator">=</span>standalone, port<span class="token operator">=</span>6379.redis_1  <span class="token operator">|</span> 1:M 17 Aug 22:11:10.483 <span class="token comment" spellcheck="true"># WARNING: The TCP backlog setting of 511 cannot be enforced because /proc/sys/net/core/somaxconn is set to the lower value of 128.</span>web_1    <span class="token operator">|</span>  * Debugger is active<span class="token operator">!</span>redis_1  <span class="token operator">|</span> 1:M 17 Aug 22:11:10.483 <span class="token comment" spellcheck="true"># Server initialized</span>redis_1  <span class="token operator">|</span> 1:M 17 Aug 22:11:10.483 <span class="token comment" spellcheck="true"># WARNING you have Transparent Huge Pages (THP) support enabled in your kernel. This will create latency and memory usage issues with Redis. To fix this issue run the command 'echo never > /sys/kernel/mm/transparent_hugepage/enabled' as root, and add it to your /etc/rc.local in order to retain the setting after a reboot. Redis must be restarted after THP is disabled.</span>web_1    <span class="token operator">|</span>  * Debugger PIN: 330-787-903redis_1  <span class="token operator">|</span> 1:M 17 Aug 22:11:10.483 * Ready to accept connections<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Compose 会拉取一个 Redis 镜像，为您的代码构建一个镜像，并启动您定义的服务。 在这种情况下，代码会在构建时静态复制到镜像中。</p><p>2、在浏览器中输入 <a href="http://localhost:5000/" target="_blank" rel="noopener">http://localhost:5000/</a> ，查看该应用程序的运行情况。</p><p>您应该在浏览器中看到一条消息，内容为：</p><pre class="line-numbers language-html"><code class="language-html">Hello World! I have been seen 1 times.<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>3、刷新页面，数字应该会递增。</p><pre class="line-numbers language-html"><code class="language-html">Hello World! I have been seen 2 times.<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>4、切换到另一个终端窗口，键入 <code>docker image ls</code> 查看本地镜像。此时列出的镜像应返回 <code>redis</code> 和 <code>composetest_web</code> 。</p><p>5、要停止应用程序，可以在另一个终端中进入项目目录运行 <code>docker-compose stop</code>，或者在启动应用程序的原始终端中按 <code>ctrl + c</code>。如果要停止并清除数据，以便再次启动后重新计数，可以执行 ``docker-compose down`。</p><h3 id="第五步：编辑-Compose-文件添加挂载"><a href="#第五步：编辑-Compose-文件添加挂载" class="headerlink" title="第五步：编辑 Compose 文件添加挂载"></a>第五步：编辑 Compose 文件添加挂载</h3><p>在项目目录中编辑 <code>docker-compose. yml</code>，为 web 服务添加一个 <code>bind mount</code>：</p><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token key atrule">version</span><span class="token punctuation">:</span> <span class="token string">'3'</span><span class="token key atrule">services</span><span class="token punctuation">:</span>  <span class="token key atrule">web</span><span class="token punctuation">:</span>    <span class="token key atrule">build</span><span class="token punctuation">:</span> .    <span class="token key atrule">ports</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> <span class="token string">"5000:5000"</span>    <span class="token key atrule">volumes</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> .<span class="token punctuation">:</span>/code    <span class="token key atrule">environment</span><span class="token punctuation">:</span>      <span class="token key atrule">FLASK_ENV</span><span class="token punctuation">:</span> development  <span class="token key atrule">redis</span><span class="token punctuation">:</span>    <span class="token key atrule">image</span><span class="token punctuation">:</span> <span class="token string">"redis:alpine"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>新增加 <code>volumes</code> 配置，将主机上的项目目录（当前目录）安装到容器内部的 <code>/code</code> 目录，使您可以即时修改代码，而不必重建镜像。新增 <code>environment</code> 键设置了 <code>FLASK_ENV</code> 环境变量，指示 <code>flask run</code> 要在开发模式下运行并在更改时重新加载代码。此模式仅应在开发中使用。</p><h3 id="第六步：重新构建并运行"><a href="#第六步：重新构建并运行" class="headerlink" title="第六步：重新构建并运行"></a>第六步：重新构建并运行</h3><p>从项目目录中，先输入 <code>docker-compose stop</code> 停止营业，然后输入 <code>docker-Compose up</code> 以构建带有更新的 Compose 文件的应用程序，并运行它。</p><pre class="line-numbers language-bash"><code class="language-bash">$ docker-compose stopStopping composetest_web_1   <span class="token punctuation">..</span>. <span class="token keyword">done</span>Stopping composetest_redis_1 <span class="token punctuation">..</span>. <span class="token keyword">done</span>$ docker-compose upRecreating composetest_web_1 <span class="token punctuation">..</span>. <span class="token keyword">done</span>Starting composetest_redis_1 <span class="token punctuation">..</span>. <span class="token keyword">done</span>Attaching to composetest_redis_1, composetest_web_1redis_1  <span class="token operator">|</span> 1:C 17 Apr 2020 02:25:49.466 <span class="token comment" spellcheck="true"># oO0OoO0OoO0Oo Redis is starting oO0OoO0OoO0Oo</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span>web_1    <span class="token operator">|</span>  * Serving Flask app <span class="token string">"app.py"</span> <span class="token punctuation">(</span>lazy loading<span class="token punctuation">)</span>web_1    <span class="token operator">|</span>  * Environment: developmentweb_1    <span class="token operator">|</span>  * Debug mode: onweb_1    <span class="token operator">|</span>  * Running on http://0.0.0.0:5000/ <span class="token punctuation">(</span>Press CTRL+C to quit<span class="token punctuation">)</span>web_1    <span class="token operator">|</span>  * Restarting with <span class="token function">stat</span>web_1    <span class="token operator">|</span>  * Debugger is active<span class="token operator">!</span>web_1    <span class="token operator">|</span>  * Debugger PIN: 143-909-154<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>再次检查浏览器中的 Hello World 提示消息，并刷新以查看计数增量。</p><blockquote><p>如果出现运行时错误指示找不到应用程序文件，拒绝卷安装或服务无法启动，请尝试启用文件或驱动器共享。有关更多信息，请参阅 Docker for Mac 上的 <a href="https://docs.docker.com/docker-for-mac/#file-sharing" target="_blank" rel="noopener">文件共享</a> 章节。</p></blockquote><h3 id="第七步：更新应用程序"><a href="#第七步：更新应用程序" class="headerlink" title="第七步：更新应用程序"></a>第七步：更新应用程序</h3><p>因为现在应用程序代码是使用卷安装到容器中的，所以可以对代码进行更改并立即生效，而无需重建镜像。</p><ol><li><p>更改 <code>app.py</code> 中的提示语并保存。例如，将 <code>Hello World!</code> 更改为 <code>Hello from Docker!</code> ：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">return</span> <span class="token string">'Hello from Docker! I have been seen {} times.\n'</span><span class="token punctuation">.</span>format<span class="token punctuation">(</span>count<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>在浏览器中刷新应用。会发现提示语已更新，并且计数器仍在增加。</p></li></ol><h3 id="第八步：尝试其它命令"><a href="#第八步：尝试其它命令" class="headerlink" title="第八步：尝试其它命令"></a>第八步：尝试其它命令</h3><p>如果要让服务在后台运行，可以将 <code>-d</code> 参数（用于“分离”模式）传递给 <code>docker-compose up</code> ，并用 <code>docker-compose ps</code> 查看当前正在运行的内容：</p><pre class="line-numbers language-bash"><code class="language-bash">$ docker-compose up  -dStarting composetest_web_1   <span class="token punctuation">..</span>. <span class="token keyword">done</span>Starting composetest_redis_1 <span class="token punctuation">..</span>. <span class="token keyword">done</span>$ docker-compose <span class="token function">ps</span>       Name                      Command               State           Ports-------------------------------------------------------------------------------------composetest_redis_1   docker-entrypoint.sh redis <span class="token punctuation">..</span>.   Up      6379/tcpcomposetest_web_1     flask run                        Up      0.0.0.0:5000-<span class="token operator">></span>5000/tcp<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>docker-compose run</code> 命令允许为服务运行一次性命令。 例如，查看 <code>web</code> 服务可用的环境变量：</p><pre class="line-numbers language-bash"><code class="language-bash">$ docker-compose run web <span class="token function">env</span>PATH<span class="token operator">=</span>/usr/local/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/binHOSTNAME<span class="token operator">=</span>4b3f1e39dc5d<span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span>FLASK_APP<span class="token operator">=</span>app.pyFLASK_RUN_HOST<span class="token operator">=</span>0.0.0.0HOME<span class="token operator">=</span>/root<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>请参阅 <code>docker-compose --help</code> 以查看其他可用命令。您还可以为 bash 和 zsh shell 安装 <a href="https://docs.docker.com/compose/completion/" target="_blank" rel="noopener">命令补全</a> 功能，这将自动提示可用的命令。</p><h2 id="相关文章"><a href="#相关文章" class="headerlink" title="相关文章"></a>相关文章</h2><ul><li>上一篇：<a href="https://www.lixl.cn/books/Docker/6-Multistage-build/">Docker必知必会系列（六）：基于多阶段构建减小镜像体积降低复杂度</a></li><li>下一篇：<a href="https://www.lixl.cn/books/Docker/8-kubernetes/">Docker必知必会系列（八）：从 Docker 进阶到 Kubernetes</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DevOps </tag>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>六、基于多阶段构建减小镜像体积降低复杂度</title>
      <link href="/2020/022722120.html"/>
      <url>/2020/022722120.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文是《<a href="https://www.lixl.cn/books/Docker/1-Overview/">Docker必知必会系列</a>》第六篇，原文发布于个人博客：<a href="https://www.lixl.cn/">悟尘记</a>。</p><p>上一篇：<a href="https://www.lixl.cn/books/Docker/5-Data/">Docker必知必会系列（五）：Docker 数据持久化存储与性能调优</a></p></blockquote><h2 id="一、引言"><a href="#一、引言" class="headerlink" title="一、引言"></a>一、引言</h2><p>如何减小所构建镜像的体积最非常具有挑战性的事情。Docker 17.05版本以后，新增了Dockerfile多阶段构建。所谓多阶段构建，实际上是允许一个Dockerfile 中出现多个 <code>FROM</code> 指令。</p><h2 id="二、单-Dockerfile-构建镜像"><a href="#二、单-Dockerfile-构建镜像" class="headerlink" title="二、单 Dockerfile 构建镜像"></a>二、单 Dockerfile 构建镜像</h2><p>如果将所有的构建过程都包含在一个 <code>Dockerfile</code> 中，包括项目及其依赖库的编译、测试、打包等流程，这样会带来的一些问题：</p><ul><li>镜像层次多，镜像体积较大，部署时间变长</li><li>源代码存在泄露的风险</li></ul><p>下面是一个简单示例：</p><pre class="line-numbers language-dockerfile"><code class="language-dockerfile">FROM golang:1.14-alpineRUN apk --no-cache add git ca-certificatesWORKDIR /go/src/github.com/go/lixl.cn/helloworld/COPY app.go .RUN go get -d -v github.com/go-sql-driver/mysql \  && CGO_ENABLED=0 GOOS=linux go build -a -installsuffix cgo -o app . \  && cp /go/src/github.com/go/lixl.cn/helloworld/app /rootWORKDIR /root/CMD ["./app"]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>构建镜像：<code>docker build -t go/helloworld:1 -f Dockerfile1 .</code></p><h2 id="三、Builder-模式构建"><a href="#三、Builder-模式构建" class="headerlink" title="三、Builder 模式构建"></a>三、Builder 模式构建</h2><p>为了解决上面提到的问题，可以采用 <a href="http://blog.alexellis.io/mutli-stage-docker-builds/" target="_blank" rel="noopener">Builder 模式</a>：创建两个 Dockerfile，一个用于开发（包含构建应用程序所需的一切），另一个用于生产（仅包含您的应用程序以及运行该应用程序所需的内容），然后用编译脚本将其整合：</p><ul><li><p><code>Dockerfile.build</code> 文件:</p><pre class="line-numbers language-dockerfile"><code class="language-dockerfile">FROM golang:1.14-alpineRUN apk --no-cache add git ca-certificatesWORKDIR /go/src/github.com/go/lixl.cn/helloworld/COPY app.go .RUN go get -d -v github.com/go-sql-driver/mysql \    && CGO_ENABLED=0 GOOS=linux go build -a -installsuffix cgo -o app . <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><code>Dockerfile2</code> 文件：</p><pre class="line-numbers language-dockerfile"><code class="language-dockerfile">FROM alpine:latestRUN apk --no-cache add ca-certificatesWORKDIR /root/COPY app .CMD ["./app"]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><code>build.sh</code> 文件:</p><pre class="line-numbers language-powershell"><code class="language-powershell"><span class="token comment" spellcheck="true">#!/bin/sh</span><span class="token function">echo</span> Building go<span class="token operator">/</span>helloworld:builddocker build <span class="token operator">-</span>t go<span class="token operator">/</span>helloworld:build <span class="token punctuation">.</span> <span class="token operator">-</span>f Dockerfile<span class="token punctuation">.</span>builddocker create <span class="token operator">--</span>name extract go<span class="token operator">/</span>helloworld:builddocker <span class="token function">cp</span> extract:<span class="token operator">/</span>go<span class="token operator">/</span>src<span class="token operator">/</span>github<span class="token punctuation">.</span>com<span class="token operator">/</span>go<span class="token operator">/</span>lixl<span class="token punctuation">.</span>cn<span class="token operator">/</span>helloworld<span class="token operator">/</span>app <span class="token punctuation">.</span><span class="token operator">/</span>appdocker <span class="token function">rm</span> <span class="token operator">-</span>f extract<span class="token function">echo</span> Building go<span class="token operator">/</span>helloworld:2docker build <span class="token operator">--</span>no<span class="token operator">-</span>cache <span class="token operator">-</span>t go<span class="token operator">/</span>helloworld:2 <span class="token punctuation">.</span> <span class="token operator">-</span>f Dockerfile2<span class="token function">rm</span> <span class="token punctuation">.</span><span class="token operator">/</span>app<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><p>构建镜像：<code>chmod u+x build.sh &amp;&amp; sh ./build.sh</code></p><p>这种方式生成的镜像会很小，不过过程比较复杂，而且生成的多个镜像都会占用系统空间。</p><h2 id="四、多阶段构建方式"><a href="#四、多阶段构建方式" class="headerlink" title="四、多阶段构建方式"></a>四、多阶段构建方式</h2><p>为了解决这些问题，自 Docker v17.05 开始支持<a href="https://docs.docker.com/develop/develop-images/multistage-build/" target="_blank" rel="noopener">多阶段构建</a>。每一条 <code>FROM</code> 指令都是一个构建阶段，多条 <code>FROM</code> 就是多阶段构建，虽然最后生成的镜像只能是最后一个阶段的结果，但是，能够将前置阶段中的文件拷贝到后边的阶段中，这就是多阶段构建的最大意义。示例如下：</p><pre class="line-numbers language-dockerfile"><code class="language-dockerfile">FROM golang:1.14-alpine as builderRUN apk --no-cache add gitWORKDIR /go/src/github.com/go/lixl.cn/helloworld/RUN go get -d -v github.com/go-sql-driver/mysqlCOPY app.go .RUN CGO_ENABLED=0 GOOS=linux go build -a -installsuffix cgo -o app .FROM alpine:latest as prodRUN apk --no-cache add ca-certificatesWORKDIR /root/COPY --from=0 /go/src/github.com/go/lixl.cn/helloworld/app .CMD ["./app"]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>第二<code>FROM</code>条指令以<code>alpine:latest</code>为基础开始新的构建阶段。<code>COPY --from=0</code> 行仅将先前阶段中构建的工件复制到新阶段（第一个<code>FROM</code>条指令的起始编号为 0），Go SDK 和任何中间工件都不会保存在最终镜像中。</p><p>接下来，使用 <code>docker build -t go/helloworld:3 .</code> 构建镜像，然后对比三种方式生成的镜像大小。</p><pre class="line-numbers language-bash"><code class="language-bash">docker imagesREPOSITORY             TAG           IMAGE ID            CREATED             SIZEgo/helloworld          3             5fb7cd98ef33        2 minutes ago       8.22MBgo/helloworld          2             7c30b66f73f9        2 minutes ago       8.22MBgo/helloworld          1             28fb4443a052        2 hours ago         401MB<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看出，单 Dockerfile 方式构建的镜像非常大。后两种方式构建的镜像大小一致，但多阶段构建大大降低了复杂性。</p><blockquote><p>使用多阶段构建：</p><ul><li><p>可以在 <code>Dockerfile</code> 中使用多个 <code>FROM</code> 语句，每个 <code>FROM</code> 指令可以使用不同的基础镜像。</p></li><li><p>每个 <code>FORM</code> 都会开始新的构建阶段，可以有选择地将工件从一个阶段复制到另一个阶段。</p></li><li><p>通过在 <code>FROM</code> 指令中添加 <code>AS name</code> 来可以命名阶段，然后使用 <code>COPY --from=name</code> 而非数字来引用。</p></li><li><p>可以指定目标阶段来构建镜像（使用 <code>--target name</code> 指令），而不是必须构建整个 Dockerfile。</p></li><li><p>可以直接引用外部的镜像，如：<code>COPY --from=nginx:latest /etc/nginx/nginx.conf /nginx.conf</code>。</p></li><li><p>可以在使用 <code>FROM</code> 指令时引用前一个阶段，从上一个阶段结束。例如：</p><pre class="line-numbers language-dockerfile"><code class="language-dockerfile">FROM alpine:latest as builderRUN apk --no-cache add build-baseFROM builder as build1COPY source1.cpp source.cppRUN g++ -o /binary source.cppFROM builder as build2COPY source2.cpp source.cppRUN g++ -o /binary source.cpp<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><p>更详细的介绍，可以参考：<a href="https://docs.docker.com/develop/develop-images/multistage-build/" target="_blank" rel="noopener">https://docs.docker.com/develop/develop-images/multistage-build/</a></p></blockquote><h2 id="相关文章"><a href="#相关文章" class="headerlink" title="相关文章"></a>相关文章</h2><ul><li>上一篇：<a href="https://www.lixl.cn/books/Docker/5-Data/">Docker必知必会系列（五）：Docker 数据持久化存储与性能调优</a></li><li>下一篇：<a href="https://www.lixl.cn/books/Docker/7-Docker-Compose/">Docker必知必会系列（七）：Docker Compose 入门实践</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DevOps </tag>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>五、Docker 数据持久化存储与性能调优</title>
      <link href="/2020/022615220.html"/>
      <url>/2020/022615220.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文是《<a href="https://www.lixl.cn/books/Docker/1-Overview/">Docker必知必会系列</a>》第五篇，原文发布于个人博客：<a href="https://www.lixl.cn/">悟尘记</a>。</p><p>上一篇：<a href="https://www.lixl.cn/books/Docker/4-Network/">Docker必知必会系列（四）：Docker 网络原理、分类及容器互联配置</a></p></blockquote><h2 id="数据持久化存储与性能调优"><a href="#数据持久化存储与性能调优" class="headerlink" title="数据持久化存储与性能调优"></a>数据持久化存储与性能调优</h2><h3 id="数据持久保存"><a href="#数据持久保存" class="headerlink" title="数据持久保存"></a>数据持久保存</h3><p>默认情况下，在容器内创建的所有文件都存储在可写容器层上。这意味着当该容器不再存在时，数据也将丢失。</p><p>为了让数据脱离容器持久保存，Docker 提供了两个选项来将文件持久存储在主机中： <code>volume</code> 和 <code>bind mount</code> 。如果您在 Linux 上运行 Docker，则还可以使用 _tmpfs 挂载_。如果您在 Windows 上运行 Docker，则还可以使用<em>命名管道</em>。</p><p><img src="https://pic.lixl.cn/2020/types-of-mounts.png" alt="挂载的类型以及它们在Docker主机上的位置"></p><ul><li><strong>volume（卷）</strong>存储在主机文件系统的一部分中，该文件系统<em>由 Docker 管理</em>（<code>/var/lib/docker/volumes/</code>在 Linux 上）。非 Docker 进程不应修改文件系统的这一部分。卷是在 Docker 中持久保存数据的最佳方法。</li><li><strong>bind mount（绑定挂载）</strong>可以存储在主机系统上的<em>任何位置</em>。它们甚至可能是重要的系统文件或目录。Docker 主机或 Docker 容器上的非 Docker 进程可以随时对其进行修改。</li><li><strong><code>tmpfs</code>挂载</strong> 仅存储在主机系统的内存中，并且永远不会写入主机系统的文件系统中。</li></ul><p><code>volume</code> 和 <code>bind mount</code> 都可以使用 <code>-v</code> 或 <code>--volume</code> 标志安装到容器中，但是两者的语法略有不同。</p><blockquote><p>关于挂载类型的更多详细信息：<a href="https://docs.docker.com/storage/#more-details-about-mount-types" target="_blank" rel="noopener">Manage data in Docker</a></p></blockquote><h3 id="挂载卷性能调优"><a href="#挂载卷性能调优" class="headerlink" title="挂载卷性能调优"></a>挂载卷性能调优</h3><p>在 macOS（和其他非 Linux 平台）上，保证容器内和主机文件一致性的开销很大。然而，在许多情况下，容器与主机之间不需要完美的一致性。区分不同情况可以显着提高性能。</p><p>通过在 <code>docker run -v</code>， <code>--volume</code> 的 option 中指定 <code>cached</code> 或 <code>delegated</code>，可以显着提高 Docker Desktop for Mac 上已装载卷访问的性能。您可以根据情况调整所需的一致性级别：</p><ul><li><code>consistent</code>：默认值，完美的一致性，即主机和容器实时一致。</li><li><code>cached</code>：主机具有权威性。容器执行的写操作对主机是立即可见的，但是在主机上执行的写操作可能不会立即反应在容器内。</li><li><code>delegated</code>：容器的内容具有权威性。提供最弱保证，由容器执行的写操作可能不会立即反映在主机文件系统上，提供的性能要比其他配置好得多。</li></ul><p>为每个挂载卷独立设置缓存策略，例如：</p><pre class="line-numbers language-bash"><code class="language-bash">docker run \    -v /Users/lixl.cn/project:/project:cached \    -v /host/another-path:/mount/another-point:consistent \    alpine <span class="token function">command</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="相关文章"><a href="#相关文章" class="headerlink" title="相关文章"></a>相关文章</h2><ul><li>上一篇：<a href="https://www.lixl.cn/books/Docker/4-Network/">Docker必知必会系列（四）：Docker 网络原理、分类及容器互联配置</a></li><li>下一篇：<a href="https://www.lixl.cn/books/Docker/6-Multistage-build/">Docker必知必会系列（六）：基于多阶段构建减小镜像体积降低复杂度</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DevOps </tag>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>四、Docker 网络原理、分类及容器互联配置</title>
      <link href="/2020/022535558.html"/>
      <url>/2020/022535558.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文是《<a href="https://www.lixl.cn/books/Docker/1-Overview/">Docker必知必会系列</a>》第四篇，原文发布于个人博客：<a href="https://www.lixl.cn/">悟尘记</a>。</p><p>上一篇：<a href="https://www.lixl.cn/books/Docker/3-Repository/">Docker必知必会系列（三）：基于 Docker-registry/Nexus3 搭建本地仓库</a></p></blockquote><h2 id="Docker-网络配置"><a href="#Docker-网络配置" class="headerlink" title="Docker 网络配置"></a>Docker 网络配置</h2><h3 id="Docker-网络基本原理"><a href="#Docker-网络基本原理" class="headerlink" title="Docker 网络基本原理"></a>Docker 网络基本原理</h3><p>要实现网络通信，机器需要至少一个网络接口（物理接口或虚拟接口）来收发数据包。如果不同子网之间要进行通信，需要路由机制。</p><p>Docker 中的网络接口默认都是虚拟接口，虚拟接口的优势之一是转发效率较高。 Linux 通过在内核中进行数据复制来实现虚拟接口之间的数据转发，发送接口的发送缓存中的数据包被直接复制到接收接口的接收缓存中。</p><p>当 Docker 启动时，会自动在主机上创建一个 <code>docker0</code> 虚拟网桥（ Linux 的一个 bridge），它会在挂载到它的网口之间进行转发。同时，Docker 随机分配一个本地未占用的私有网段中的一个地址给 <code>docker0</code> 接口，此后启动的容器内的网口也会自动分配一个同一网段（<code>172.17.0.0/16</code>）的地址。</p><p>当创建一个 Docker 容器的时候，同时会创建了一对 <code>veth pair</code> 接口（当数据包发送到一个接口时，另外一个接口也可以收到相同的数据包）。这对接口一端在容器内，即 <code>eth0</code>；另一端在本地并被挂载到 <code>docker0</code> 网桥，名称以 <code>veth</code> 开头（例如 <code>vethAQI2QT</code>）。通过这种方式，主机可以跟容器通信，容器之间也可以相互通信。</p><p><img src="https://pic.lixl.cn/2020/network.png" alt="Docker 网络"></p><p>关于 Docker 网络的更多内容，可以访问：<a href="https://docs.docker.com/network/" target="_blank" rel="noopener">https://docs.docker.com/network/</a>&gt;</p><h3 id="Docker-网络类型"><a href="#Docker-网络类型" class="headerlink" title="Docker 网络类型"></a>Docker 网络类型</h3><p>Docker 创建一个容器的时候，会执行如下操作：</p><ul><li>创建一对虚拟接口，分别放到本地主机和新容器中；</li><li>本地主机一端桥接到默认的 docker0 或指定网桥上，并具有一个唯一的名字，如 veth65f9；</li><li>容器一端放到新容器中，并修改名字作为 eth0，这个接口只在容器的命名空间可见；</li><li>从网桥可用地址段中获取一个空闲地址分配给容器的 eth0，并配置默认路由到桥接网卡 veth65f9。</li></ul><p>完成这些之后，容器就可以使用 eth0 虚拟网卡来连接其他容器和其他网络。</p><p>可以在 <code>docker run</code> 的时候通过 <code>--net</code> 参数来指定容器的网络配置，有 4 个可选值：</p><ul><li><code>--net=bridge</code> 这个是默认值，连接到默认的网桥。</li><li><code>--net=host</code> 告诉 Docker 不要将容器网络放到隔离的命名空间中，即不要容器化容器内的网络。此时容器使用本地主机的网络，它拥有完全的本地主机接口访问权限。容器进程可以跟主机其它 root 进程一样可以打开低范围的端口，可以访问本地网络服务比如 D-bus，还可以让容器做一些影响整个主机系统的事情，比如重启主机。因此使用这个选项的时候要非常小心。如果进一步的使用 <code>--privileged=true</code>，容器会被允许直接配置主机的网络堆栈。</li><li><code>--net=container:NAME_or_ID</code> 让 Docker 将新建容器的进程放到一个已存在容器的网络栈中，新容器进程有自己的文件系统、进程列表和资源限制，但会和已存在的容器共享 IP 地址和端口等网络资源，两者进程可以直接通过 <code>lo</code> 环回接口通信。</li><li><code>--net=none</code> 让 Docker 将新容器放到隔离的网络栈中，但是不进行网络配置。之后，用户可以自己进行配置。</li></ul><h3 id="外部访问容器"><a href="#外部访问容器" class="headerlink" title="外部访问容器"></a>外部访问容器</h3><p>默认情况下，容器可以主动访问到外部网络的连接，但是外部网络无法访问到容器。想要允许外部访问容器，可以在 <code>docker run</code> 时候通过 <code>-p</code> 或 <code>-P</code> 参数来启用（可以多次使用 <code>-p</code> 标记来绑定多个端口）。</p><p>使用 <code>docker ps</code> 可以看到，本地主机的 80 被映射到了容器的 <code>80</code> 端口。此时访问本机的 <code>80</code> 端口即可访问容器内 <code>nginx</code> 应用提供的界面。</p><pre class="line-numbers language-bash"><code class="language-bash">docker <span class="token function">ps</span>CONTAINER ID  IMAGE   COMMAND        CREATED        STATUS        PORTS               NAMESbc533791f3f5  nginx   <span class="token string">"nginx -g '…"</span>  5 days ago     Up 4 days     0.0.0.0:80-<span class="token operator">></span>80/tcp  nginx<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="容器间互联"><a href="#容器间互联" class="headerlink" title="容器间互联"></a>容器间互联</h3><p>先创建一个新的 Docker 网络：</p><pre class="line-numbers language-bash"><code class="language-bash">docker network create -d bridge lixl-net<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><code>-d</code> 参数指定 Docker 网络类型，有 <code>bridge</code>，<code>overlay</code>。其中 <code>overlay</code> 网络类型用于 Swarm mode。</li></ul><p>运行一个容器并连接到新建的 <code>lixl-net</code> 网络</p><pre class="line-numbers language-bash"><code class="language-bash">docker run -it --rm --name busybox1 --network lixl-net busybox sh<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>打开新的终端，再运行一个容器并加入到 <code>lixl-net</code> 网络</p><pre class="line-numbers language-bash"><code class="language-bash">docker run -it --rm --name busybox2 --network lixl-net busybox sh<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>再打开一个新的终端查看容器信息</p><pre class="line-numbers language-bash"><code class="language-bash">docker <span class="token function">ps</span>CONTAINER ID     IMAGE      COMMAND    CREATED            STATUS         PORTS     NAMESb47060aca56b     busybox    <span class="token string">"sh"</span>       1 minutes ago      Up 1 minutes             busybox28720575823ec     busybox    <span class="token string">"sh"</span>       1 minutes ago      Up 1 minutes             busybox1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>下面通过 <code>ping</code> 来证明 <code>busybox1</code> 容器和 <code>busybox2</code> 容器建立了互联关系。</p><p>在 <code>busybox1</code> 容器输入以下命令</p><pre class="line-numbers language-bash"><code class="language-bash">/ <span class="token comment" spellcheck="true"># ping busybox2</span>PING busybox2 <span class="token punctuation">(</span>172.19.0.3<span class="token punctuation">)</span>: 56 data bytes64 bytes from 172.19.0.3: seq<span class="token operator">=</span>0 ttl<span class="token operator">=</span>64 time<span class="token operator">=</span>0.072 ms64 bytes from 172.19.0.3: seq<span class="token operator">=</span>1 ttl<span class="token operator">=</span>64 time<span class="token operator">=</span>0.118 ms<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>用 ping 来测试连接 <code>busybox2</code> 容器，它会解析成 <code>172.19.0.3</code>。</p><p>同理在 <code>busybox2</code> 容器执行 <code>ping busybox1</code>，也会成功连接到。</p><pre class="line-numbers language-bash"><code class="language-bash">/ <span class="token comment" spellcheck="true"># ping busybox1</span>PING busybox1 <span class="token punctuation">(</span>172.19.0.2<span class="token punctuation">)</span>: 56 data bytes64 bytes from 172.19.0.2: seq<span class="token operator">=</span>0 ttl<span class="token operator">=</span>64 time<span class="token operator">=</span>0.064 ms64 bytes from 172.19.0.2: seq<span class="token operator">=</span>1 ttl<span class="token operator">=</span>64 time<span class="token operator">=</span>0.143 ms<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>这样，<code>busybox1</code> 容器和 <code>busybox2</code> 容器建立了互联关系。</p><blockquote><p>如果有多个容器之间需要互相连接，推荐使用 <a href="#docker-compose">Docker Compose</a>。</p></blockquote><h2 id="相关文章"><a href="#相关文章" class="headerlink" title="相关文章"></a>相关文章</h2><ul><li>上一篇：<a href="https://www.lixl.cn/books/Docker/3-Repository/">Docker必知必会系列（三）：基于 Docker-registry/Nexus3 搭建本地仓库</a></li><li>下一篇：<a href="https://www.lixl.cn/books/Docker/5-Data/">Docker必知必会系列（五）：Docker 数据持久化存储与性能调优</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DevOps </tag>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>三、基于 Docker-registry/Nexus3 搭建本地仓库</title>
      <link href="/2020/022440628.html"/>
      <url>/2020/022440628.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文是《<a href="https://www.lixl.cn/books/Docker/1-Overview/">Docker必知必会系列</a>》第三篇，原文发布于个人博客：<a href="https://www.lixl.cn/">悟尘记</a>。</p><p>上一篇：<a href="https://www.lixl.cn/books/Docker/2-Image/">Docker必知必会系列（二）：基于 Dockerfile 构建并运行镜像</a></p></blockquote><h2 id="Docker-镜像仓库"><a href="#Docker-镜像仓库" class="headerlink" title="Docker 镜像仓库"></a>Docker 镜像仓库</h2><p>Repository（仓库）是集中存放镜像的地方。一个 Docker Registry 中可以包含多个 Repository（仓库），每个仓库可以包含多个 Tag（标签），每个标签对应一个 Image（镜像）。</p><p>最常使用的 Registry 公开服务是官方的 <a href="https://hub.docker.com/" target="_blank" rel="noopener">Docker Hub</a>，这也是默认的 Registry。用户也可以创建本地仓库方便内部使用。</p><h3 id="1、官方公共仓库-Docker-Hub"><a href="#1、官方公共仓库-Docker-Hub" class="headerlink" title="1、官方公共仓库 Docker Hub"></a>1、官方公共仓库 Docker Hub</h3><p>目前 Docker 官方维护了一个公共仓库 <a href="https://hub.docker.com/" target="_blank" rel="noopener">Docker Hub</a>，其中已经包括了数量超过 <a href="https://hub.docker.com/search/?type=image" target="_blank" rel="noopener">2,650,000</a> 的镜像。大部分需求都可以通过在 Docker Hub 中直接下载镜像来实现。</p><p>你可以在 <a href="https://hub.docker.com/" target="_blank" rel="noopener">https://hub.docker.com</a> 免费注册一个 Docker 账号。通过执行 <code>docker login</code> 命令交互式的输入用户名及密码来完成在命令行界面登录 Docker Hub。</p><h4 id="推送镜像"><a href="#推送镜像" class="headerlink" title="推送镜像"></a>推送镜像</h4><p>用户可以在登录后通过 <code>docker push</code> 命令来将自己的镜像推送到 Docker Hub。</p><p>以下命令中的 <code>lxl823</code> 请替换为你的 Docker 账号用户名。</p><pre class="line-numbers language-bash"><code class="language-bash">docker tag nginx lxl823/nginx:1.17.9docker image <span class="token function">ls</span>REPOSITORY       TAG            IMAGE ID            CREATED             SIZEnginx            latest          6678c7c2e56c        6 days ago          127MBlxl823/nginx     1.17.9          6678c7c2e56c        6 days ago          127MBdocker push lxl823/nginx:1.17.9<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>登录 <a href="https://hub.docker.com/repositories" target="_blank" rel="noopener">hub.docker.com</a> ，可以看到镜像已经发布到仓库中。</p><p><img src="https://pic.lixl.cn/2020/image-20200326185134980.png" alt="Docker hub 镜像仓库"></p><h4 id="自动构建"><a href="#自动构建" class="headerlink" title="自动构建"></a>自动构建</h4><p>Docker Hub 可以自动从外部存储库中的源代码构建镜像，并将生成的镜像自动推送到您的 Docker 存储库。</p><p>设置自动构建允许用户通过 Docker Hub 指定跟踪一个目标网站（支持 <a href="https://github.com/" target="_blank" rel="noopener">GitHub</a>）上的项目，一旦项目发生新的提交 （commit）或者创建了新的标签（tag），Docker Hub 会自动构建镜像并推送到 Docker Hub 中。</p><p>要配置自动构建，包括如下的步骤：</p><ul><li>登录 Docker Hub；</li><li>在 Docker Hub 点击右上角头像，在账号设置（Account Settings）中关联（Linked Accounts）目标网站；</li><li>在 Docker Hub 中新建或选择已有的仓库，在 <code>Builds</code> 选项卡中选择 <code>Configure Automated Builds</code>；</li><li>选取一个目标网站中的项目（需要含 <code>Dockerfile</code>）和分支；</li><li>指定 <code>Dockerfile</code> 的位置，并保存。</li></ul><p>之后，可以在 Docker Hub 的仓库页面的 <code>Timeline</code> 选项卡中查看每次构建的状态。</p><p>进一步了解：<a href="https://docs.docker.com/docker-hub/builds/" target="_blank" rel="noopener">Set up automated builds</a></p><h3 id="2、基于-docker-registry-搭建本地仓库"><a href="#2、基于-docker-registry-搭建本地仓库" class="headerlink" title="2、基于 docker-registry 搭建本地仓库"></a>2、基于 docker-registry 搭建本地仓库</h3><p><a href="https://docs.docker.com/registry/" target="_blank" rel="noopener"><code>docker-registry</code></a> 是官方提供的工具，可以用于构建私有的镜像仓库。本文内容基于 <a href="https://github.com/docker/distribution" target="_blank" rel="noopener"><code>docker-registry</code></a> v2.x 版本。</p><h4 id="安装运行-docker-registry"><a href="#安装运行-docker-registry" class="headerlink" title="安装运行 docker-registry"></a>安装运行 docker-registry</h4><p>你可以通过获取官方 <code>registry</code> 镜像来运行。</p><pre class="line-numbers language-bash"><code class="language-bash">docker run -d -p 5000:5000 --restart<span class="token operator">=</span>always --name registry registry<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这将使用官方的 <code>registry</code> 镜像来启动私有仓库。默认情况下，仓库会被创建在容器的 <code>/var/lib/registry</code> 目录下。你可以通过 <code>-v</code> 参数来将镜像文件存放在本地的指定路径。</p><p>创建好私有仓库之后，就可以使用 <code>docker tag</code> 来标记一个镜像，然后使用 <code>docker push</code> 推送它到仓库。</p><h3 id="3、基于-Nexus3-搭建本地仓库"><a href="#3、基于-Nexus3-搭建本地仓库" class="headerlink" title="3、基于 Nexus3 搭建本地仓库"></a>3、基于 Nexus3 搭建本地仓库</h3><p>在企业中把内部的一些工具包放入 Nexus 中是比较常见的做法。 Nexus 不仅能够用于创建 Maven 私服，还可以用来创建 yum、pypi、npm、nuget、rubygems 等各种私有仓库。而且，Nexus 从 3.0 版本也开始支持创建 Docker 镜像仓库了！</p><h4 id="拉取并启动-nexus-容器"><a href="#拉取并启动-nexus-容器" class="headerlink" title="拉取并启动 nexus 容器"></a>拉取并启动 nexus 容器</h4><pre class="line-numbers language-bash"><code class="language-bash">docker run -d \    --name nexus \    -p 8085:8081 \    -p 8086:8086 \    -v nexus_data:/nexus-data \    sonatype/nexus3:latest<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>等待 3-5 分钟，如果 <code>nexus</code> 容器没有异常退出，就可以使用浏览器打开 <code>http://localhost:8085</code> 访问 Nexus 了。</p><h4 id="创建本地仓库"><a href="#创建本地仓库" class="headerlink" title="创建本地仓库"></a>创建本地仓库</h4><p>创建一个私有仓库的方法： <code>Repository -&gt; Repositories</code> 点击右边菜单 <code>Create repository</code> 选择 <code>docker (hosted)</code></p><ul><li>Name：仓库的名称</li><li>HTTP：仓库单独的访问端口，如 <code>8086</code></li><li>Hosted -&gt; Deployment pollcy：请选择 Allow redeploy 否则无法上传 Docker 镜像。</li></ul><p>还可以创建一个 docker (proxy) 类型的仓库连接到 DockerHub 上。再创建一个 docker (group) 类型的仓库把刚才的 hosted 与 proxy 添加在一起。主机在访问的时候默认下载私有仓库中的镜像，如果没有将连接到 DockerHub 中下载并缓存到 Nexus 中。</p><h4 id="添加访问权限"><a href="#添加访问权限" class="headerlink" title="添加访问权限"></a>添加访问权限</h4><p>菜单 <code>Security -&gt; Realms</code> 把 Docker Bearer Token Realm 移到右边的框中保存。</p><p>添加用户规则：菜单 <code>Security-&gt;Roles</code>-&gt;<code>Create role</code> 在 <code>Privlleges</code> 选项搜索 docker 把相应的规则移动到右边的框中然后保存。</p><h4 id="Nginx-加密代理"><a href="#Nginx-加密代理" class="headerlink" title="Nginx 加密代理"></a>Nginx 加密代理</h4><p>部署 Nginx 时，我们先需要获得 SSL 证书。目前提供免费证书的云服务商很多，也可以使用 <code>openssl</code> 自行签发证书。我们还还需要 2 个域名，一个用来展示 nexus 前台，另一个用做 docker 仓库。Nginx 配置如下:</p><pre class="line-numbers language-properties"><code class="language-properties"><span class="token attr-name">server</span> <span class="token attr-value">{</span><span class="token attr-name">    listen</span> <span class="token attr-value">80;</span><span class="token attr-name">    server_name</span> <span class="token attr-value">nexus3.lixl.cn;  # nexus 前台</span><span class="token attr-name">    location</span> <span class="token attr-value">/ {</span><span class="token attr-name">        proxy_pass</span> <span class="token attr-value">http://local.lixl.cn:8085;</span><span class="token attr-name">        proxy_set_header</span> <span class="token attr-value">Host $host;</span><span class="token attr-name">        proxy_set_header</span> <span class="token attr-value">X-Real-IP $remote_addr;</span><span class="token attr-name">        proxy_set_header</span> <span class="token attr-value">X-Forwarded-For $proxy_add_x_forwarded_for;</span><span class="token attr-name">        proxy_set_header</span> <span class="token attr-value">Via "nginx";</span>    }<span class="token attr-name">    error_page</span> <span class="token attr-value">  500 502 503 504  /50x.html;</span><span class="token attr-name">    location</span> <span class="token punctuation">=</span> <span class="token attr-value">/50x.html {</span><span class="token attr-name">        root</span> <span class="token attr-value">  /usr/share/nginx/html;</span>    }}<span class="token attr-name">server</span> <span class="token attr-value">{</span><span class="token attr-name">    listen</span> <span class="token attr-value">443 ssl;</span><span class="token attr-name">    server_name</span> <span class="token attr-value">nexus.lixl.cn;  # docker 仓库</span><span class="token attr-name">    ssl_certificate</span> <span class="token attr-value">/etc/nginx/certs/nexus.lixl.cn.crt;</span><span class="token attr-name">    ssl_certificate_key</span> <span class="token attr-value">/etc/nginx/certs/nexus.lixl.cn.key;</span><span class="token attr-name">    ssl_session_timeout</span> <span class="token attr-value"> 5m;</span><span class="token attr-name">    ssl_ciphers</span> <span class="token attr-value">HIGH:!aNULL:!MD5;</span><span class="token attr-name">    ssl_protocols</span> <span class="token attr-value">SSLv3 TLSv1 TLSv1.1 TLSv1.2;</span><span class="token attr-name">    ssl_prefer_server_ciphers</span> <span class="token attr-value">  on;</span><span class="token attr-name">    location</span> <span class="token attr-value">/ {</span><span class="token attr-name">        proxy_pass</span> <span class="token attr-value">http://local.lixl.cn:8086;</span><span class="token attr-name">        proxy_set_header</span> <span class="token attr-value">Host $host;</span><span class="token attr-name">        proxy_set_header</span> <span class="token attr-value">X-Real-IP $remote_addr;</span><span class="token attr-name">        proxy_set_header</span> <span class="token attr-value">X-Forwarded-For $proxy_add_x_forwarded_for;</span><span class="token attr-name">        proxy_set_header</span> <span class="token attr-value">Via "nginx";</span><span class="token attr-name">        client_max_body_size</span> <span class="token attr-value">1024M;</span>    }<span class="token attr-name">    error_page</span> <span class="token attr-value">  500 502 503 504  /50x.html;</span><span class="token attr-name">    location</span> <span class="token punctuation">=</span> <span class="token attr-value">/50x.html {</span><span class="token attr-name">        root</span> <span class="token attr-value">  /usr/share/nginx/html;</span>    }}<span class="token attr-name">server</span> <span class="token attr-value">{</span><span class="token attr-name">    listen</span> <span class="token attr-value">80;</span><span class="token attr-name">    server_name</span> <span class="token attr-value">nexus.lixl.cn;  # docker 仓库</span><span class="token attr-name">    return</span> <span class="token attr-value">301 https://$server_name$request_uri;</span>}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="登录本地仓库并推送镜像"><a href="#登录本地仓库并推送镜像" class="headerlink" title="登录本地仓库并推送镜像"></a>登录本地仓库并推送镜像</h4><p>使用 <code>docker login</code> 进行测试，用户名密码与 Nexus 账号一致。</p><pre class="line-numbers language-bash"><code class="language-bash">docker login https://nexus.lixl.cnUsername: adminPassword:Login Succeeded<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>通过 <code>docker push</code> 命令将自己的镜像推送到 Nexus：</p><pre class="line-numbers language-bash"><code class="language-bash">docker tag nginx nexus.lixl.cn/nginx:20200326docker image <span class="token function">ls</span>REPOSITORY             TAG             IMAGE ID            CREATED             SIZEnginx                  latest          6678c7c2e56c        6 days ago          127MBnexus.lixl.cn/nginx    20200326        6678c7c2e56c        6 days ago          127MBdocker push nexus.lixl.cn/nginx:20200326<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>推送成功。在本地仓库即可看到新推送的镜像：</p><p><img src="https://pic.lixl.cn/2020/image-20200326201622029.png" alt="本地仓库新推送的镜像"></p><h2 id="相关文章"><a href="#相关文章" class="headerlink" title="相关文章"></a>相关文章</h2><ul><li>上一篇：<a href="https://www.lixl.cn/books/Docker/2-Image/">Docker必知必会系列（二）：基于 Dockerfile 构建并运行镜像</a></li><li>下一篇：<a href="https://www.lixl.cn/books/Docker/4-Network/">Docker必知必会系列（四）：Docker 网络原理、分类及容器互联配置</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DevOps </tag>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二、基于 Dockerfile 构建并运行镜像</title>
      <link href="/2020/02231623.html"/>
      <url>/2020/02231623.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文是《<a href="https://www.lixl.cn/books/Docker/1-Overview/">Docker必知必会系列</a>》第二篇，原文发布于个人博客：<a href="https://www.lixl.cn/">悟尘记</a>。</p><p>上一篇：<a href="https://www.lixl.cn/books/Docker/1-Overview/">Docker必知必会系列（一）：Docker 基础入门及架构介绍</a></p></blockquote><h2 id="构建并运行镜像"><a href="#构建并运行镜像" class="headerlink" title="构建并运行镜像"></a>构建并运行镜像</h2><p>要构建一个容器，需要做很多的工作，设置很多的配置，如果我们可以把每一层修改、安装、构建、操作的命令都写入一个脚本，用这个脚本来构建、定制镜像，那么经常被提及的无法重复、镜像构建透明性、体积等问题就都会解决。 这个脚本就是 Dockerfile。</p><h3 id="准备-Dockerfile-文件"><a href="#准备-Dockerfile-文件" class="headerlink" title="准备 Dockerfile 文件"></a>准备 Dockerfile 文件</h3><p>下载示例项目，请在终端中运行以下命令：</p><pre class="line-numbers language-bash"><code class="language-bash">curl -LO https://github.com/dockersamples/node-bulletin-board/archive/master.zipunzip master.zip<span class="token function">cd</span> node-bulletin-board-master/bulletin-board-app<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><blockquote><p>该<code>node-bulletin-board</code>项目是一个简单的公告板应用程序，使用 Node.js 编写。在此示例中，假设您编写了此应用程序，现在正尝试对其进行容器化。</p></blockquote><p><code>Dockerfile</code> 描述如何为容器组装专用文件系统，并且还可以包含一些元数据，这些元数据描述了如何基于该镜像运行容器。公告板应用程序 <code>Dockerfile</code> 内容如下：</p><pre class="line-numbers language-dockerfile"><code class="language-dockerfile"># Use the official image as a parent image.FROM node:current-slim# Set the working directory.WORKDIR /usr/src/app# Copy the file from your host to your current location.COPY package.json .# Run the command inside your image filesystem.RUN npm install# Inform Docker that the container is listening on the specified port at runtime.EXPOSE 8080# Run the specified command within the container.CMD [ "npm", "start" ]# Copy the rest of your app's source code from your host to your image filesystem.COPY . .<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>编写 Dockerfile 是容器化应用程序的第一步，这些 Dockerfile 命令是构建镜像的步骤。 这个步骤如下:</p><ul><li>使用 <code>FORM</code> 指定基于已经存在的 <code>node:current-slim</code> 基础镜像构建。这是一个由 nodejs 官方构建的镜像。</li><li>使用 <code>WORKDIR</code> 指定所有后续操作均从镜像文件系统中的 <code>/usr/src/app</code> 目录中执行（而不是主机的文件系统中）。</li><li>将文件 <code>package.json</code> 从主机复制到镜像中的当前位置（.）（复制到 ``/usr/src/app/package.json`）</li><li>在镜像文件系统中运行命令 <code>npm install</code>（读取 <code>package.json</code> 以确定并安装应用程序依赖）</li><li>将应用的其余源代码从主机复制到镜像文件系统。</li></ul><blockquote><p>这些步骤与在主机上设置和安装应用程序所采取的步骤几乎相同。但是，将它们保存为 <code>Dockerfile</code> 可以使您在可移植的隔离 Docker 镜像中执行相同的操作。</p></blockquote><p>上面的步骤构建了我们镜像的文件系统，但是 Dockerfile 中还有其他几行。</p><ul><li><p><code>CMD</code> 指令在镜像中指定一些元数据，该元数据描述了如何基于该镜像运行容器。在本示例中该图像的容器化过程是 <code>npm start</code>。</p></li><li><p><code>EXPOSE 8080</code> 通知 Docker 该容器在运行时监听 8080 端口。</p></li></ul><p>上面是组织一个简单的 Dockerfile 的方法。始终以 <code>FROM</code> 命令开头，然后按照步骤构建您的私有文件系统，并以任何元数据规范作为结束。 Dockerfile 指令比上面看到的要多。有关完整列表，请参阅 <a href="https://docs.docker.com/engine/reference/builder/" target="_blank" rel="noopener">Dockerfile 参考</a>。</p><h3 id="构建并测试镜像"><a href="#构建并测试镜像" class="headerlink" title="构建并测试镜像"></a>构建并测试镜像</h3><p>现在您已经有了一些源代码和一个 Dockerfile，现在该构建您的第一个镜像，并确保从其启动的容器能够按预期工作。让我们构建您的公告板图像：</p><pre class="line-numbers language-bash"><code class="language-bash">docker build --tag bulletinboard:1.0 <span class="token keyword">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>您将看到 Docker 逐步完成 Dockerfile 中的每条指令，并逐步构建镜像：</p><pre class="line-numbers language-bash"><code class="language-bash">Sending build context to Docker daemon  45.57kBStep 1/7 <span class="token keyword">:</span> FROM node:current-slimcurrent-slim: Pulling from library/node48839397421a: Pull completecbb6511d79bf: Pull complete04ec6202052a: Pull complete29c5eab4674c: Pull complete8df5bb5f8d2e: Pull completeDigest: sha256:c92fad90875a6ce7251c72701f9c88e1e3f3efc2eb1d7d1ffb2184204e4f7d98Status: Downloaded newer image <span class="token keyword">for</span> node:current-slim ---<span class="token operator">></span> 6d9a17519d40Step 2/7 <span class="token keyword">:</span> WORKDIR /usr/src/app ---<span class="token operator">></span> Running <span class="token keyword">in</span> 9dfd5c099558Removing intermediate container 9dfd5c099558 ---<span class="token operator">></span> 6062c6d2e488Step 3/7 <span class="token keyword">:</span> COPY package.json <span class="token keyword">.</span> ---<span class="token operator">></span> 2ddc37525da9Step 4/7 <span class="token keyword">:</span> RUN <span class="token function">npm</span> <span class="token function">install</span> ---<span class="token operator">></span> Running <span class="token keyword">in</span> 6ce3fed8ecd7<span class="token operator">></span> ejs@2.7.4 postinstall /usr/src/app/node_modules/ejs<span class="token operator">></span> node ./postinstall.jsThank you <span class="token keyword">for</span> installing EJS: built with the Jake JavaScript build tool <span class="token punctuation">(</span>https://jakejs.com/<span class="token punctuation">)</span><span class="token function">npm</span> notice created a lockfile as package-lock.json. You should commit this file.<span class="token function">npm</span> WARN vue-event-bulletin@1.0.0 No repository field.<span class="token function">npm</span> WARN The package morgan is included as both a dev and production dependency.added 91 packages from 168 contributors and audited 221 packages <span class="token keyword">in</span> 16.854sfound 0 vulnerabilitiesRemoving intermediate container 6ce3fed8ecd7 ---<span class="token operator">></span> 38a27fea6567Step 5/7 <span class="token keyword">:</span> EXPOSE 8080 ---<span class="token operator">></span> Running <span class="token keyword">in</span> c7528a178327Removing intermediate container c7528a178327 ---<span class="token operator">></span> 97f454f32f95Step 6/7 <span class="token keyword">:</span> CMD <span class="token punctuation">[</span> <span class="token string">"npm"</span>, <span class="token string">"start"</span> <span class="token punctuation">]</span> ---<span class="token operator">></span> Running <span class="token keyword">in</span> 72a6340e3d58Removing intermediate container 72a6340e3d58 ---<span class="token operator">></span> 0a90efca7ea9Step 7/7 <span class="token keyword">:</span> COPY <span class="token keyword">.</span> <span class="token keyword">.</span> ---<span class="token operator">></span> 84c4f69e2893Successfully built 84c4f69e2893Successfully tagged bulletinboard:1.0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="将镜像作为容器运行"><a href="#将镜像作为容器运行" class="headerlink" title="将镜像作为容器运行"></a>将镜像作为容器运行</h3><ol><li><p>根据您的新镜像启动一个容器：</p><pre class="line-numbers language-bash"><code class="language-bash">docker run --publish 8000:8080 --detach --name board bulletinboard:1.0<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这里有几个常见的标志：</p><ul><li><code>--publish</code>要求 Docker 将主机端口 8000 上传入的流量转发到容器的端口 8080。容器具有自己的专用端口集，因此，如果要从网络访问某个端口，则必须以这种方式将流量转发到该端口。否则，作为默认的安全状态，防火墙规则将阻止所有网络流量到达您的容器。</li><li><code>--detach</code> 要求 Docker 在后台运行此容器。</li><li><code>--name</code>指定一个名称，您可以使用该名称在后续命令中引用您的容器，在这种情况下为<code>board</code>。</li></ul><p>还要注意，您没有指定容器要运行的程序。您不必这样做，因为在构建 Dockerfile 时使用了<code>CMD</code>指令。Docker 知道在容器启动时会自动运行<code>npm start</code> 程序。</p></li><li><p>在的浏览器中访问您的应用程序<code>localhost:8000</code>，您应该看到公告板应用程序已启动并正在运行。</p><p><img src="https://pic.lixl.cn/2020/image-20200406000641171.png" alt="公告板应用程序运行中"></p></li><li><p>对公告板容器正常工作感到满意后，可以将其删除：</p><pre class="line-numbers language-script"><code class="language-script">docker rm --force board<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>该<code>--force</code>选项将删除正在运行的容器。如果停止容器运行，<code>docker stop board</code>则无需使用<code>--force</code>。</p></li></ol><h2 id="相关文章"><a href="#相关文章" class="headerlink" title="相关文章"></a>相关文章</h2><ul><li>上一篇：<a href="https://www.lixl.cn/books/Docker/1-Overview/">Docker必知必会系列（一）：Docker 基础入门及架构介绍</a></li><li>下一篇：<a href="https://www.lixl.cn/books/Docker/3-Repository/">Docker必知必会系列（三）：基于 Docker-registry/Nexus3 搭建本地仓库</a></li><li><a href="https://www.lixl.cn/books/Docker/appendix2-dockerfile-best-practices/">附录2、Dockerfile 参考及最佳实践</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DevOps </tag>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一、Docker基础入门及架构介绍</title>
      <link href="/2020/02208729.html"/>
      <url>/2020/02208729.html</url>
      
        <content type="html"><![CDATA[<h2 id="系列文章介绍"><a href="#系列文章介绍" class="headerlink" title="系列文章介绍"></a>系列文章介绍</h2><p>本文是《<a href="https://www.lixl.cn/books/Docker/1-Overview/">Docker必知必会系列</a>》第一篇，原文发布于个人博客：<a href="https://www.lixl.cn/">悟尘记</a>。</p><p>此系列文章共包括如下章节：</p><ul><li><a href="https://www.lixl.cn/books/Docker/1-Overview/">一、Docker基础入门及架构介绍</a></li><li><a href="https://www.lixl.cn/books/Docker/2-Image/">二、基于 Dockerfile 构建并运行镜像</a></li><li><a href="https://www.lixl.cn/books/Docker/3-Repository/">三、基于 Docker-registry/Nexus3 搭建本地仓库</a></li><li><a href="https://www.lixl.cn/books/Docker/4-Network/">四、Docker 网络原理、分类及容器互联配置</a></li><li><a href="https://www.lixl.cn/books/Docker/5-Data/">五、Docker 数据持久化存储与性能调优</a></li><li><a href="https://www.lixl.cn/books/Docker/6-Multistage-build/">六、基于多阶段构建减小镜像体积降低复杂度</a></li><li><a href="https://www.lixl.cn/books/Docker/7-Docker-Compose/">七、Docker Compose 入门实践</a></li><li><a href="https://www.lixl.cn/books/Docker/8-kubernetes/">八、从 Docker 进阶到 Kubernetes</a></li><li><a href="https://www.lixl.cn/books/Docker/appendix1-docker-command/">附录1、Docker 常用命令及示例</a></li><li><a href="https://www.lixl.cn/books/Docker/appendix2-dockerfile-best-practices/">附录2、Dockerfile 参考及最佳实践</a></li><li><a href="https://www.lixl.cn/books/Docker/appendix3-docker-compose-command/">附录3、Docker-compose 命令使用指南</a></li><li><a href="https://www.lixl.cn/books/Docker/appendix4-docker-compose-file/">附录4、Docker-compose 配置文件编写</a></li><li><a href="https://www.lixl.cn/books/Docker/appendix5-kubectl/">附录5、Kubectl 命令行界面</a></li></ul><p>部分内容翻译自 <a href="https://docs.docker.com/" target="_blank" rel="noopener">Docker官方文档</a> 或参考 《<a href="https://github.com/yeasy/docker_practice" target="_blank" rel="noopener">Docker — 从入门到实践</a>》，非常感谢原作者。</p><h2 id="一、Docker-概述"><a href="#一、Docker-概述" class="headerlink" title="一、Docker 概述"></a>一、Docker 概述</h2><p>Docker是供开发人员和系统管理员 使用容器构建，运行和共享应用程序的平台。使用容器来部署应用程序称为容器化。</p><p>Docker 使您能够将应用程序与基础架构分开，从而可以快速交付软件。借助 Docker，您可以以与管理应用程序相同的方式来管理基础架构。通过利用 Docker 的快速交付，测试和部署代码的方法，您可以大大减少编写代码和在生产环境中运行代码之间的延迟。</p><p>容器化越来越受欢迎，是因为容器：</p><ul><li><strong>灵活</strong>：即使最复杂的应用程序也可以容器化。</li><li><strong>轻量级</strong>：容器利用并共享主机内核，在系统资源方面比虚拟机更加有效。</li><li><strong>可移植性</strong>：可以在本地构建，部署到云并在任何地方运行。</li><li><strong>松散耦合</strong>：容器高度封装并自给自足，可以在不破坏其他容器的情况下更换或升级它们。</li><li><strong>可扩展</strong>：可以方便的在数据中心内增加并自动分发容器副本。</li><li><strong>安全</strong>：容器将积极的约束和隔离应用于流程，而无需用户方面的任何配置。</li></ul><h3 id="1、镜像（Image）和容器（Container）"><a href="#1、镜像（Image）和容器（Container）" class="headerlink" title="1、镜像（Image）和容器（Container）"></a>1、镜像（Image）和容器（Container）</h3><p>从根本上讲，一个容器不过是一个正在运行的进程，并对其应用了一些附加的封装功能，以使其与主机和其他容器隔离。容器隔离的最重要方面之一是每个容器都与自己的专用文件系统进行交互。该文件系统由Docker 镜像提供。镜像包括运行应用程序所需的一切：代码或二进制文件、运行时、依赖项以及所需的任何其他文件系统对象。</p><h3 id="2、容器与虚拟机"><a href="#2、容器与虚拟机" class="headerlink" title="2、容器与虚拟机"></a>2、容器与虚拟机</h3><p>容器在 Linux 本机上运行，并与其他容器共享主机的内核。它运行一个离散的进程，占用的内存不比任何其他可执行文件多，从而使其轻巧。</p><p>相比之下，虚拟机（VM）运行一个完整的 ”Guest操作系统“，通过虚拟机监控程序对主机资源进行虚拟访问。一般来说，VM 除了应用程序逻辑所消耗的开销之外，还会产生很多开销。</p><p><img src="https://pic.lixl.cn/2020/image-20200421180607851.png" alt="Docker VS 虚拟机"></p><h3 id="3、我可以将-Docker-用于什么"><a href="#3、我可以将-Docker-用于什么" class="headerlink" title="3、我可以将 Docker 用于什么"></a>3、我可以将 Docker 用于什么</h3><h4 id="快速，一致地交付您的应用程序"><a href="#快速，一致地交付您的应用程序" class="headerlink" title="快速，一致地交付您的应用程序"></a>快速，一致地交付您的应用程序</h4><p>Docker 通过允许开发人员使用容器让应用程序和服务在本地标准化环境中工作，从而简化了开发生命周期。容器非常适合持续集成和持续交付（CI / CD）工作流程。</p><h4 id="响应式部署和扩展"><a href="#响应式部署和扩展" class="headerlink" title="响应式部署和扩展"></a>响应式部署和扩展</h4><p>Docker 容器可以在开发人员的本地笔记本电脑上，数据中心中的物理或虚拟机上，云提供商上或混合环境中运行。其可移植和轻量级的特性还使您可以轻松地动态管理工作负载，并根据业务需求指示实时扩展或关闭应用程序和服务。</p><h4 id="在同一硬件上运行更多工作负载"><a href="#在同一硬件上运行更多工作负载" class="headerlink" title="在同一硬件上运行更多工作负载"></a>在同一硬件上运行更多工作负载</h4><p>Docker 轻巧快速。它相对于虚拟机提供了可行且经济高效的替代方案，因此您可以利用更多的计算能力来实现业务目标。Docker 非常适合高密度环境和中小型部署，让您可以用更少的资源做更多的事情。</p><h2 id="二、Docker-安装及运行"><a href="#二、Docker-安装及运行" class="headerlink" title="二、Docker 安装及运行"></a>二、Docker 安装及运行</h2><h3 id="1、获取-Docker"><a href="#1、获取-Docker" class="headerlink" title="1、获取 Docker"></a>1、获取 Docker</h3><p>Docker 分为 CE 和 EE 两大版本。Docker CE 分为 <code>stable</code>、 <code>test</code> 和 <code>nightly</code> 三个更新频道。官方网站上有各种环境下的 <a href="https://docs.docker.com/get-docker/" target="_blank" rel="noopener">安装指南</a>，可以根据自己的情况进行安装。</p><h3 id="2、镜像加速"><a href="#2、镜像加速" class="headerlink" title="2、镜像加速"></a>2、镜像加速</h3><p>一般国内在使用过程中拉取 Docker 镜像十分缓慢，可以配置 Docker 国内镜像加速。各个免费镜像站测试结果可到 <a href="https://github.com/docker-practice/docker-registry-cn-mirror-test/actions" target="_blank" rel="noopener">docker-practice/docker-registry-cn-mirror-test</a> 查看。推荐使用<a href="https://cr.console.aliyun.com/cn-beijing/instances/mirrors" target="_blank" rel="noopener">阿里云免费镜像加速器</a>（需登录），稳定可靠。</p><p>对于使用 macOS 的用户，在任务栏点击 Docker Desktop 应用图标 -&gt; <code>Perferences</code>，在左侧导航菜单选择 <code>Docker Engine</code>，在右侧参考如下内容编辑 json 文件（记得修改成您选择的加速地址）：</p><pre class="line-numbers language-json"><code class="language-json"><span class="token punctuation">{</span>  <span class="token property">"registry-mirrors"</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">"https://xxxxxx.mirror.aliyuncs.com"</span><span class="token punctuation">]</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>修改完成之后，点击 <code>Apply &amp; Restart</code> 按钮，Docker 就会重启并应用配置的镜像。执行 <code>$ docker info</code>，如果从结果中看到了如下内容，说明配置成功。</p><pre class="line-numbers language-bash"><code class="language-bash">Registry Mirrors: https://xxxxxx.mirror.aliyuncs.com<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="3、小试牛刀"><a href="#3、小试牛刀" class="headerlink" title="3、小试牛刀"></a>3、小试牛刀</h3><p>以下命令运行一个<code>ubuntu</code>容器，以交互方式附加到本地命令行会话，然后运行<code>/bin/bash</code>。</p><pre class="line-numbers language-bash"><code class="language-bash">docker run -i -t ubuntu /bin/bash<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>当您运行此命令时，会发生以下情况（假设您使用的是默认仓库配置）：</p><ol><li>如果您在<code>ubuntu</code>本地没有该镜像，则 Docker 会将其从已配置的仓库中拉出，就像您已<code>docker pull ubuntu</code>手动运行一样。</li><li>Docker 会创建一个新容器，就像您通过 <code>docker container create</code> 命令手动运行一样。</li><li>Docker 将一个可读写的文件系统分配给容器，作为其最后一层。这允许运行中的容器在其本地文件系统中创建或修改文件和目录。</li><li>Docker 创建了一个网络接口以将容器连接到默认网络，因为您未指定任何网络选项。默认情况下，容器可以使用主机的网络连接到外部网络。</li><li>Docker 启动容器并执行<code>/bin/bash</code>。因为容器是交互式运行的，并且已附加到您的终端（由于<code>-i</code>和<code>-t</code> 标志），所以您可以在终端进行交互操作并查看日志。</li><li>当您键入<code>exit</code>以终止<code>/bin/bash</code>命令时，容器将停止但不会被删除。您可以重新启动或删除它。</li></ol><h2 id="三、Docker-架构介绍"><a href="#三、Docker-架构介绍" class="headerlink" title="三、Docker 架构介绍"></a>三、Docker 架构介绍</h2><p>Docker 使用客户端-服务器架构。Docker <em>客户端（<code>client</code>）</em> 与 <em>守护进程（<code>Docker daemon</code>）</em> 进行对话，该<em>守护进程</em> 完成了构建、运行和分发 Docker 容器的繁重工作。Docker 客户端和守护进程可以在同一系统上运行，或者您可以将 Docker 客户端连接到远程 Docker 守护进程。Docker 客户端和守护进程在 UNIX 套接字或网络接口上使用 REST API 进行通信。</p><p><img src="https://pic.lixl.cn/2020/image-20200325194141346.png" alt="Docker架构图" title="Docker架构图"></p><h3 id="Docker-守护进程"><a href="#Docker-守护进程" class="headerlink" title="Docker 守护进程"></a>Docker 守护进程</h3><p>Docker 守护进程（<code>dockerd</code>）侦听 Docker API 请求并管理 Docker 对象，例如 images（镜像），containers（容器），networks（网络）和 volume（卷）。守护进程还可以与其他守护进程通信以管理 Docker 服务。</p><h3 id="Docker-客户端"><a href="#Docker-客户端" class="headerlink" title="Docker 客户端"></a>Docker 客户端</h3><p>Docker 客户端（<code>docker</code>）是许多 Docker 用户与 Docker 交互的主要方式。当您使用诸如<code>docker run</code> 之类的命令时，客户端会将这些命令发送到 <code>dockerd</code>，以执行这些命令。该<code>docker</code>命令使用 Docker API。Docker 客户端可以与多个守护进程通信。</p><h3 id="Docker-仓库"><a href="#Docker-仓库" class="headerlink" title="Docker 仓库"></a>Docker 仓库</h3><p>Docker 仓库存储 Docker 镜像。Docker Hub 是任何人都可以使用的官方公共仓库，并且 Docker 配置为默认在 Docker Hub 上查找镜像。您甚至可以运行自己的私人仓库。如果使用 Docker 数据中心（DDC），则其中包括 Docker 可信仓库（DTR）。</p><p>使用 <code>docker pull</code> 或 <code>docker run</code> 命令时，所需的镜像将从配置的仓库中提取。使用 <code>docker push</code> 命令时，会将镜像推送到配置的仓库。</p><h3 id="Docker-对象"><a href="#Docker-对象" class="headerlink" title="Docker 对象"></a>Docker 对象</h3><p>使用 Docker 时，您正在创建和使用镜像（Image），容器（Container），网络（Network），卷（Volume），插件（Plugin）和其他对象。本节是其中一些对象的简要概述。</p><h4 id="Images（镜像）"><a href="#Images（镜像）" class="headerlink" title="Images（镜像）"></a>Images（镜像）</h4><p>镜像是一个只读模板（不包含任何动态数据，其内容在构建之后也不会被改变 ），其中包含创建 Docker 容器的说明。通常，一个镜像基于另一个镜像，并带有一些额外的配置。 例如，你可以建立一个基于 ubuntu 镜像的镜像，安装 ubuntu Apache HTTP Server 和你的应用程序，以及运行你的应用程序所需的配置细节。</p><p>您可以创建自己的镜像，也可以仅使用其他人创建并在仓库中发布的镜像。要构建自己的镜像，您可以使用简单的语法创建一个 <code>Dockerfile</code>，以定义创建镜像并运行它所需的步骤。<code>Dockerfile</code> 中的每条指令都会在镜像中创建一个层。更改 <code>Dockerfile</code> 并重建镜像时，仅重建那些已更改的层。与其他虚拟化技术相比，这是使镜像如此轻巧，小型和快速的部分原因。</p><h4 id="Containers-（容器）"><a href="#Containers-（容器）" class="headerlink" title="Containers （容器）"></a>Containers （容器）</h4><p>容器是镜像的可运行实例。您可以使用 Docker API 或 CLI 创建、启动、停止、移动或删除容器。您可以将容器连接到一个或多个网络，将存储附加到该网络，甚至根据其当前状态创建新镜像。</p><p>默认情况下，容器与其他容器及其主机之间的隔离程度相对较高。您可以控制容器的网络、存储或其他基础子系统与其他容器或与主机的隔离程度。</p><p>容器由其镜像以及在创建或启动时为其提供的任何配置选项定义。删除容器后，未存储在持久性存储中的状态更改将消失。</p><blockquote><p>按照 Docker 最佳实践的要求，容器不应该向其存储层内写入任何数据，容器存储层要保持无状态化。所有的文件写入操作，都应该使用 Volume（数据卷）、或者挂载宿主目录，在这些位置的读写会跳过容器存储层，直接对宿主（或网络存储）进行读写，其性能和稳定性更高。</p></blockquote><h4 id="Service-（服务）"><a href="#Service-（服务）" class="headerlink" title="Service （服务）"></a>Service （服务）</h4><p>服务允许跨多个 Docker 守护进程调度容器，这些守护进程以多个管理者和工作者的集群模式协同工作。集群的每个成员都是一个 Docker 守护进程，并且所有守护进程都使用 Docker API 进行通信。</p><p>服务允许您定义所需的状态，例如在任何给定时间必须可用的服务副本数。默认情况下，该服务在所有工作节点之间实现负载平衡。对于使用者而言，Docker 服务似乎是一个单独的应用程序。Docker Engine 在 Docker 1.12 及更高版本中支持集群模式。</p><h2 id="四、Docker-底层技术"><a href="#四、Docker-底层技术" class="headerlink" title="四、Docker 底层技术"></a>四、Docker 底层技术</h2><p>Docker用<a href="https://golang.org/" target="_blank" rel="noopener">Go</a>编写，并利用Linux内核的多个功能来交付其功能。底层核心技术包括命名空间（Namespaces）、控制组（Control groups）、Union 文件系统（Union file systems）和容器格式（Container format）。</p><h3 id="1、命名空间（namespaces）"><a href="#1、命名空间（namespaces）" class="headerlink" title="1、命名空间（namespaces）"></a>1、命名空间（namespaces）</h3><p>Docker使用一种称为 <code>namespaces</code> 的技术来提供称之为容器的隔离工作区。运行容器时，Docker会为该容器创建一组命名空间。通过命名空间隔离容器之间彼此不受影响，且其访问权限也仅限于该命名空间。</p><p>Docker Engine 在Linux 上使用以下命名空间：</p><ul><li><strong><code>pid</code>命名空间：</strong>进程隔离（PID：Process ID）。</li><li><strong><code>net</code>命名空间：</strong>管理网络接口（NET：Networking）。</li><li><strong><code>ipc</code>命名空间：</strong>管理对IPC资源的访问（IPC：InterProcess Communication）。</li><li><strong><code>mnt</code>命名空间：</strong>管理文件系统挂载点（MNT：Mount）。</li><li><strong><code>uts</code>命名空间：</strong>隔离内核和版本标识符。（UTS：Unix Timesharing System）。</li></ul><h3 id="2、控制组（cgroups）"><a href="#2、控制组（cgroups）" class="headerlink" title="2、控制组（cgroups）"></a>2、控制组（cgroups）</h3><p>Linux上的 Docker 引擎依赖一种称为<em>控制组</em> （<code>cgroups</code>）的技术。控制组为应用程序限制一组特定的资源。控制组允许Docker Engine将可用的硬件资源共享给容器，并有选择地实施限制和约束。例如，可以限制特定容器可用的内存。</p><blockquote><p>CGroups 全称control group，用来限定一个进程的资源使用，由Linux 内核支持，可以限制和隔离Linux进程组 (process groups) 所使用的物理资源 ，比如cpu，内存，磁盘和网络IO，是Linux container技术的物理基础。</p></blockquote><h3 id="3、联合文件系统（UnionFS）"><a href="#3、联合文件系统（UnionFS）" class="headerlink" title="3、联合文件系统（UnionFS）"></a>3、联合文件系统（UnionFS）</h3><p> UnionFS文件系统，是通过创建层来操作的文件系统，这使得它们非常轻量级和快速。 Docker Engine 使用 <code>UnionFS</code> 为容器提供分层构建块。 Docker Engine 可以使用多个 <code>UnionFS</code> 变体，包括 <code>AUFS</code>、 <code>btrfs</code>、 <code>vfs</code> 和 <code>DeviceMapper</code>。</p><blockquote><p>Union File System，简称UnionFS，他是一种为Linux 、FreeBSD 和NetBSD 操作系统设计的，把其他文件系统联合到一个联合挂载点的文件系统服务。</p></blockquote><h3 id="4、容器格式（Container-format）"><a href="#4、容器格式（Container-format）" class="headerlink" title="4、容器格式（Container format）"></a>4、容器格式（Container format）</h3><p>Docker Engine 将<code>namespaces</code>、<code>cgroups</code>和 <code>UnionFS</code> 组合成一个称为容器格式的包装器。 默认的容器格式是 <code>libcontainer</code>。</p><h2 id="相关文章"><a href="#相关文章" class="headerlink" title="相关文章"></a>相关文章</h2><ul><li>下一篇：<a href="https://www.lixl.cn/books/Docker/2-Image/">Docker必知必会系列（二）：基于 Dockerfile 构建并运行镜像</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DevOps </tag>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VSCode-aliyun-oss-paste-image 插件安装使用指南</title>
      <link href="/2020/021659830.html"/>
      <url>/2020/021659830.html</url>
      
        <content type="html"><![CDATA[<p>VSCode扩展插件，在 Markdown 类型文件编辑过程中，支持一键上传截图到阿里云OSS并将图片粘贴到博文中。</p><p>详见博文：<a href="https://www.lixl.cn/2020/021737756.html">aliyun-oss-paste-image 插件安装使用指南</a>。</p><h2 id="理想的-Markdown-博文写作及发布体验"><a href="#理想的-Markdown-博文写作及发布体验" class="headerlink" title="理想的 Markdown 博文写作及发布体验"></a>理想的 Markdown 博文写作及发布体验</h2><ol><li>截图后一键粘贴（ <code>Shift + p</code> ）并实时预览，内容编辑所见即所得。</li><li><code>hexo g -d</code> 一键发布到多个托管平台（ 如Github + COS ）。</li><li>自建的博客平台拥有超快的访问速度且几乎零成本。</li><li>直接粘贴/导入 Markdown 博文到第三方平台（如知乎、简书、CSDN）。</li></ol><p>推荐使用 <a href="https://www.typora.io/" target="_blank" rel="noopener">Typora</a> + <a href="https://www.lixl.cn/2020/020936412.html">hexo-deployer-cos-cdn</a>插件 实现如上体验。</p><p>喜欢使用 VSCode 的话，可以通过本插件来提高博文撰写体验。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>在插件应用商店搜索 <code>aliyun-oss-paste-image</code> ，点击 <code>install</code> 安装。如图:</p><p><img src="https://pic.lixl.cn/2020/15da665cf0d5309abc2b054508b61d76.png" alt="插件检索及安装"></p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>先截图/复制图片内容，然后在 markdown 文件编辑过程中，使用 <code>Shift + p</code> 一键上传。</p><h2 id="参数设置"><a href="#参数设置" class="headerlink" title="参数设置"></a>参数设置</h2><ul><li><code>region</code>: 地域。在阿里云对象存储的bucket概览中有EndPoint（地域节点），如 <code>oss-cn-beijing.aliyuncs.com</code> 中的 <code>oss-cn-beijing</code> 就是地域。</li><li><code>accessKeyId</code>: accessKeyId（RAM中生成的accessKeyId）</li><li><code>accessKeySecret</code>: accessKeySecret（RAM中生成的accessKeySecret）</li><li><code>bucket</code>: 输入bucket名称</li><li><code>remotePath</code>: 图片存储目录。例如希望的图片地址为 <code>http://${你的域名}/static/${filename}.png</code>，则填写 <code>static</code> ）</li><li><code>domain</code>: 阿里云oss域名，建议绑定自定义域名并开启CDN加速</li><li><code>localTempPath</code>: 本地临时文件路径（默认: /tmp/.aliyun-oss-paste-image）</li></ul><h2 id="License"><a href="#License" class="headerlink" title="License"></a>License</h2><p>MIT</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://marketplace.visualstudio.com/items?itemName=vvkee.aliyun-oss-upload-image" target="_blank" rel="noopener">vscode-aliyun-upload-image</a></li><li><a href="http://blog.haoji.me/vscode-plugin-overview.html" target="_blank" rel="noopener">VSCode插件开发全攻略</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> VSCode </tag>
            
            <tag> PasteImage </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo-deployer-cos-cdn 插件安装使用指南</title>
      <link href="/2020/020936412.html"/>
      <url>/2020/020936412.html</url>
      
        <content type="html"><![CDATA[<h2 id="一、摘要"><a href="#一、摘要" class="headerlink" title="一、摘要"></a>一、摘要</h2><p>Hexo部署插件，支持将静态博客发布到腾讯云、阿里云对象存储中，并同步刷新被更新文件的CDN缓存。</p><p>详见博文：<a href="https://www.lixl.cn/2020/020936412.html">hexo-deployer-cos-cdn 插件安装使用指南</a>。按量付费，一般访问量不高的话，体验期过后一个月也花不了几块钱。</p><p><img src="https://pic.lixl.cn/2020/20200212145243.png/w1280" alt="hexo-deployer-cos-cdn 插件运行流程"></p><h2 id="二、特点"><a href="#二、特点" class="headerlink" title="二、特点"></a>二、特点</h2><ol><li>全站 CDN 加速，速度超快，成本几乎为零。</li><li>支持同时使用阿里云和腾讯云对象存储服务。</li><li>支持将网站和图片发布到各自的 bucket 中。</li><li>每次上传时会对比本地与云端文件MD5值，只发布变更内容。</li><li>支持同步部署到到多个博客托管服务，如 <code>COS</code> + <code>Github Pages</code></li><li>支持将 Markdown 源文件中图片路径替换为 CDN 地址，便于直接粘贴/导入到第三方平台。</li><li>支持自动清理远程 bucket 中的多余文件，默认不启用。</li></ol><h2 id="三、理想的博文写作及发布体验"><a href="#三、理想的博文写作及发布体验" class="headerlink" title="三、理想的博文写作及发布体验"></a>三、理想的博文写作及发布体验</h2><ol><li><code>Ctrl + v</code> 一键粘贴包括多张图片和文本组成的混合内容并实时预览，内容编辑所见即所得。</li><li><code>hexo g -d</code> 一键发布到多个托管平台（如Github+COS）。</li><li>自建的博客平台拥有超快的访问速度且几乎零成本。</li><li>直接粘贴/导入 Markdown 博文到第三方平台（如知乎、简书、CSDN）。</li></ol><p>推荐使用 <a href="https://www.typora.io/" target="_blank" rel="noopener">Typora</a> + 本插件 实现如上体验。<code>Typora</code> 配置参照下图：</p><p><img src="https://pic.lixl.cn/2020/20200209161415.png/w1440" alt="Typora图像配置"></p><p>经过以上配置以后，在 <code>Typora</code> 中编辑 MarkDown 文档时，截图后直接 <code>Ctrl + v</code> 即可粘贴并实时预览。尤其是一键粘贴包括多张图片及文本的混合内容，并保留原格式非常方便。<code>hexo d</code> 部署以后，网站及图片会自动上传到云对象存储中。</p><h2 id="四、安装配置"><a href="#四、安装配置" class="headerlink" title="四、安装配置"></a>四、安装配置</h2><h3 id="1、安装"><a href="#1、安装" class="headerlink" title="1、安装"></a>1、安装</h3><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">npm</span> <span class="token function">install</span> hexo-deployer-cos-cdn --save<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="2、最简单配置示例"><a href="#2、最简单配置示例" class="headerlink" title="2、最简单配置示例"></a>2、最简单配置示例</h3><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token key atrule">deploy</span><span class="token punctuation">:</span>  <span class="token key atrule">type</span><span class="token punctuation">:</span> cos<span class="token punctuation">-</span>cdn  <span class="token key atrule">cloud</span><span class="token punctuation">:</span> tencent  <span class="token key atrule">bucket</span><span class="token punctuation">:</span> blog<span class="token punctuation">-</span><span class="token number">1234567890</span>  <span class="token key atrule">region</span><span class="token punctuation">:</span> ap<span class="token punctuation">-</span>shanghai  <span class="token key atrule">secretId</span><span class="token punctuation">:</span> AKIDIgxxxxxxxxxxxxxxxxxxxx0SepjX  <span class="token key atrule">secretKey</span><span class="token punctuation">:</span> qXPCbxxxxxxxxxxxxxxxxxxxxsJZfdR<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如上配置，图片和文件将发布到 腾讯云的 同一个 bucket 中，默认开启CDN加速，CDN加速域名为 <code>_config.yml</code> 中配置的 <code>url</code>，图片上传后，Markdown 源文件中图片依然是相对路径。</p><h3 id="3、网站与图片放在不同的bucket中"><a href="#3、网站与图片放在不同的bucket中" class="headerlink" title="3、网站与图片放在不同的bucket中"></a>3、网站与图片放在不同的bucket中</h3><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token key atrule">deploy</span><span class="token punctuation">:</span>  <span class="token key atrule">type</span><span class="token punctuation">:</span> cos<span class="token punctuation">-</span>cdn  <span class="token key atrule">cloud</span><span class="token punctuation">:</span> tencent  <span class="token key atrule">bucket</span><span class="token punctuation">:</span> blog<span class="token punctuation">-</span><span class="token number">1234567890</span>  <span class="token key atrule">region</span><span class="token punctuation">:</span> ap<span class="token punctuation">-</span>shanghai  <span class="token key atrule">secretId</span><span class="token punctuation">:</span> AKIDIgxxxxxxxxxxxxxxxxxxxx0SepjX  <span class="token key atrule">secretKey</span><span class="token punctuation">:</span> qXPCbxxxxxxxxxxxxxxxxxxxxsJZfdR  <span class="token key atrule">imageConfig</span><span class="token punctuation">:</span>    <span class="token key atrule">cloud</span><span class="token punctuation">:</span> aliyun    <span class="token key atrule">cdnUrl</span><span class="token punctuation">:</span> https<span class="token punctuation">:</span>//pic.lixl.cn    <span class="token key atrule">bucket</span><span class="token punctuation">:</span> lxl80    <span class="token key atrule">region</span><span class="token punctuation">:</span> oss<span class="token punctuation">-</span>cn<span class="token punctuation">-</span>beijing    <span class="token key atrule">folder</span><span class="token punctuation">:</span> static    <span class="token key atrule">cdnEnable</span><span class="token punctuation">:</span> <span class="token boolean important">false</span>    <span class="token key atrule">deleteExtraFiles</span><span class="token punctuation">:</span> <span class="token boolean important">false </span><span class="token comment" spellcheck="true">#谨慎开启</span>    <span class="token key atrule">secretId</span><span class="token punctuation">:</span> AKIDIgxxxxxxxxxxxxxxxxxxxx0SepjX    <span class="token key atrule">secretKey</span><span class="token punctuation">:</span> qXPCbxxxxxxxxxxxxxxxxxxxxsJZfdR<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如上配置，文件将发布到 腾讯云 的 bucket 中，图片发布到阿里云的 bucket 中。图片使用单独的 CDN 加速域名。图片cdn没有开启CDN换新及删除多余文件功能。</p><h3 id="4、免备案部署配置示例"><a href="#4、免备案部署配置示例" class="headerlink" title="4、免备案部署配置示例"></a>4、免备案部署配置示例</h3><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token key atrule">deploy</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token key atrule">type</span><span class="token punctuation">:</span> git    <span class="token key atrule">repo</span><span class="token punctuation">:</span> https<span class="token punctuation">:</span>//github.com/lxl80/blog.git    <span class="token key atrule">branch</span><span class="token punctuation">:</span> gh<span class="token punctuation">-</span>pages    <span class="token key atrule">ignore_hidden</span><span class="token punctuation">:</span> <span class="token boolean important">false</span>  <span class="token punctuation">-</span> <span class="token key atrule">type</span><span class="token punctuation">:</span> cos<span class="token punctuation">-</span>cdn    <span class="token key atrule">cloud</span><span class="token punctuation">:</span> tencent    <span class="token key atrule">bucket</span><span class="token punctuation">:</span> blog<span class="token punctuation">-</span><span class="token number">1234567890</span>    <span class="token key atrule">region</span><span class="token punctuation">:</span> ap<span class="token punctuation">-</span>shanghai    <span class="token key atrule">cdnEnable</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>    <span class="token key atrule">deleteExtraFiles</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>    <span class="token key atrule">updatePosts</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>    <span class="token key atrule">secretId</span><span class="token punctuation">:</span> AKIDIgxxxxxxxxxxxxxxxxxxxx0SepjX    <span class="token key atrule">secretKey</span><span class="token punctuation">:</span> qXPCbxxxxxxxxxxxxxxxxxxxxsJZfdR    <span class="token key atrule">imageConfig</span><span class="token punctuation">:</span>      <span class="token key atrule">cloud</span><span class="token punctuation">:</span> aliyun      <span class="token key atrule">cdnUrl</span><span class="token punctuation">:</span> https<span class="token punctuation">:</span>//cdn.jsdelivr.net/gh/lxl80/blog@gh<span class="token punctuation">-</span>pages/static      <span class="token key atrule">bucket</span><span class="token punctuation">:</span> lxl80      <span class="token key atrule">region</span><span class="token punctuation">:</span> oss<span class="token punctuation">-</span>cn<span class="token punctuation">-</span>beijing      <span class="token key atrule">folder</span><span class="token punctuation">:</span> static      <span class="token key atrule">cdnEnable</span><span class="token punctuation">:</span> <span class="token boolean important">false</span>      <span class="token key atrule">deleteExtraFiles</span><span class="token punctuation">:</span> <span class="token boolean important">true </span><span class="token comment" spellcheck="true">#谨慎开启</span>      <span class="token key atrule">secretId</span><span class="token punctuation">:</span> AKIDIgxxxxxxxxxxxxxxxxxxxx0SepjX      <span class="token key atrule">secretKey</span><span class="token punctuation">:</span> qXPCbxxxxxxxxxxxxxxxxxxxxsJZfdR<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如上配置，需要安装 <a href="https://www.npmjs.com/package/hexo-deployer-git" target="_blank" rel="noopener">hexo-deployer-git</a> 插件。会同步将网站发布到 Github Pages 及 云对象存储 中；如果 bucket 中有多余文件会删除；图片上传成功后，会将 Markdown 源文件中图片路径替换为 CDN 地址。</p><p>也可以使用免费的 <a href="https://www.jsdelivr.com/" target="_blank" rel="noopener">jsDelivr CDN</a> 来加速，如上面示例的 <code>cdnUrl</code> 配置成了 jsDelivr CDN 加速地址，这样配置的话，图片在阿里云OSS中只保存备份，用户访问的是基于免费的 jsDelivr CDN 来加速 Github 图床的效果，全球访问速度都很快，还省去了占网站流量大头的图片流量 CDN 加速成本。 详情可参见博文：<a href="https://www.lixl.cn/2019/120114500.html#toc-heading-6">使用Typora + PicGo 图床 + jsDelivr CDN实现高效 Markdown 创作</a>。</p><blockquote><p>补充： jsDelivr 是唯一具有中国政府颁发的有效ICP许可证的全球公共CDN，其直接在中国大陆设有数百个节点。</p></blockquote><h3 id="5、通过-Netlify-来加速"><a href="#5、通过-Netlify-来加速" class="headerlink" title="5、通过 Netlify 来加速"></a>5、通过 Netlify 来加速</h3><p>如果嫌 <code>Github Pages</code> 国内访问导致html页面加载太慢，可以通过 <a href="https://app.netlify.com/" target="_blank" rel="noopener">netlify</a> 来提速。在 netlify 中基于 git 创建站点，关联 github 仓库，以后通过 <code>hexo g -d</code>一键部署时，netlify 中的内容也会自动更新。示例站点: <a href="https://netlify.lixl.cn/" target="_blank" rel="noopener">https://netlify.lixl.cn/</a></p><p><img src="https://pic.lixl.cn/2020/image-20200309142734992.png" alt="基于Github仓库创建netlify站点"></p><h2 id="五、参数说明"><a href="#五、参数说明" class="headerlink" title="五、参数说明"></a>五、参数说明</h2><ul><li><p><code>type</code>： 固定填: cos-cdn</p></li><li><p><code>cloud</code>： 指定云服务商，目前支持阿里云 <code>aliyun</code> 和腾讯云 <code>tencent</code></p></li><li><p><code>bucket</code> 和 <code>region</code>： 以腾讯云为例，进入控制台 - 对象存储 - 存储桶列表 页面，存储桶名称即: <code>bucket</code> ，所属地域代号即: region，参照下图红框圈住的部分:</p></li></ul><p><img src="https://pic.lixl.cn/2020/20200208200709.png/w1280" alt="腾讯云存储桶列表"></p><ul><li><code>secretId</code> 和 <code>secretKey</code>：以腾讯云为例，进入控制台 - 访问管理 - 访问秘钥 - API秘钥管理，参照下图红框圈住的部分:</li></ul><p><img src="https://pic.lixl.cn/2020/20200208201510.png/w1280" alt="腾讯云API秘钥管理"></p><ul><li><p><code>cdnEnable</code>: 是否启用CDN加速，默认为 <code>true</code>，如果为 <code>false</code> ，将不会刷新 CDN 缓存。</p></li><li><p><code>deleteExtraFiles</code>: 是否删除云端多余文件(本地不包含的文件)，默认为 <code>false</code>，请谨慎选择。</p></li><li><p><code>updatePosts</code>：是否更新 Markdown 源文中的图片地址为CDN路径。默认为 <code>false</code> ，如果设置为 <code>true</code> ，之后再次修改 <code>imageConfig.cdnUrl</code>时，需要手动将 Markdown 源文中的图片地址批量替换为相对路径，否则不生效。</p></li><li><p><code>imageConfig.cdnUrl</code>： 用于存储图片的 bucket 绑定的 CDN 加速域名。对费用敏感的话，可以参考与其它部署插件共存的配置示例，采用 jsDelivr CDN 节省流量成本。</p></li><li><p><code>imageConfig.folder</code>：本地博客 <code>hexo/source/</code> 目录内，用户存放本地图片文件的目录。</p></li></ul><h2 id="六、注意事项"><a href="#六、注意事项" class="headerlink" title="六、注意事项"></a>六、注意事项</h2><ol><li>使用云对象存储及 CDN 服务，网站需要先备案。</li><li>超出免费额度要付费，记得开启防盗链。</li><li>更新 CDN 缓存需要授权，如果使用子账号，请同时赋予该账号此权限。</li><li>如果想将 markdown 源文直接导入/粘贴到第三方平台，记得在图片 CDN 防盗链配置中增加白名单。</li></ol><h2 id="License"><a href="#License" class="headerlink" title="License"></a>License</h2><p>MIT</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://github.com/75k/hexo-deployer-cos-enhanced" target="_blank" rel="noopener">hexo-deployer-cos-enhanced</a></li><li><a href="https://github.com/aliyun/openapi-core-nodejs-sdk" target="_blank" rel="noopener">openapi-core-nodejs-sdk</a></li><li><a href="https://www.npmjs.com/package/ali-oss" target="_blank" rel="noopener">oss-js-sdk</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Electron 构建跨平台应用</title>
      <link href="/2020/020957109.html"/>
      <url>/2020/020957109.html</url>
      
        <content type="html"><![CDATA[<h2 id="一、Electron-简介"><a href="#一、Electron-简介" class="headerlink" title="一、Electron 简介"></a>一、Electron 简介</h2><p><a href="https://electronjs.org" target="_blank" rel="noopener">Electron</a> 是由Github开发，用HTML，CSS和JavaScript来构建跨平台桌面应用程序的一个开源库。 Electron通过将 <a href="https://www.chromium.org/Home" target="_blank" rel="noopener">Chromium</a> 和 <a href="https://nodejs.org/" target="_blank" rel="noopener">Node.js</a> 合并到同一个运行时环境中，并将其打包为Mac，Windows和Linux系统下的应用来实现这一目的。</p><p><img src="https://pic.lixl.cn/2020/components.png" alt="Electron components"></p><p>最初为 GitHub 开发 Atom 编辑器, 目前已成为开源开发者、初创企业和老牌公司常用的开发工具。 <a href="https://electronjs.org/apps" target="_blank" rel="noopener">看看谁在使用Electron</a>。</p><h3 id="Electron-发展历程"><a href="#Electron-发展历程" class="headerlink" title="Electron 发展历程"></a>Electron 发展历程</h3><table><thead><tr><th align="left"><strong>2013年4月</strong></th><th align="left"><a href="https://github.com/electron/electron/commit/6ef8875b1e93787fa9759f602e7880f28e8e6b45" target="_blank" rel="noopener">Atom Shell 项目启动</a> 。</th></tr></thead><tbody><tr><td align="left"><strong>2014年5月</strong></td><td align="left"><a href="https://blog.atom.io/2014/05/06/atom-is-now-open-source.html" target="_blank" rel="noopener">Atom Shell 被开源</a> 。</td></tr><tr><td align="left"><strong>2015年4月</strong></td><td align="left"><a href="https://github.com/electron/electron/pull/1389" target="_blank" rel="noopener">Atom Shell 被重命名为 Electron</a> 。</td></tr><tr><td align="left"><strong>2016年5月</strong></td><td align="left"><a href="https://electronjs.org/blog/electron-1-0" target="_blank" rel="noopener">Electron 发布了 <code>v1.0.0</code> 版本</a> 。</td></tr><tr><td align="left"><strong>2016年5月</strong></td><td align="left"><a href="https://www.electronjs.org/docs/tutorial/mac-app-store-submission-guide" target="_blank" rel="noopener">Electron 构建的应用程序可上架 Mac App Store</a> 。</td></tr><tr><td align="left"><strong>2016年8月</strong></td><td align="left"><a href="https://www.electronjs.org/docs/tutorial/windows-store-guide" target="_blank" rel="noopener">Windows Store 支持 Electron 构建的应用程序</a> 。</td></tr></tbody></table><h2 id="二、环境搭建"><a href="#二、环境搭建" class="headerlink" title="二、环境搭建"></a>二、环境搭建</h2><p><strong>1. 安装 electron</strong></p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">npm</span> <span class="token function">install</span> -g electron<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>2. 克隆一个仓库、快速启动一个项目</strong></p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 克隆示例项目的仓库</span><span class="token function">git</span> clone https://github.com/electron/electron-quick-start<span class="token comment" spellcheck="true"># 进入这个仓库</span><span class="token function">cd</span> electron-quick-start<span class="token comment" spellcheck="true"># 安装依赖并运行</span><span class="token function">npm</span> <span class="token function">install</span> <span class="token operator">&amp;&amp;</span> <span class="token function">npm</span> start<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>3. 手动搭建一个 electron 项目</strong></p><ol><li>新建一个项目目录 例如: <code>electrondemo01</code></li><li>在 <code>electrondemo01</code> 目录下面新建三个文件: <code>index.html</code>、<code>main.js</code> 、<code>package.json</code></li><li><code>index.html</code> 里面用 <code>css</code> 进行布局（以前怎么写现在还是怎么写）</li><li>在 <code>main.js</code> 中写如下代码：</li></ol><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">var</span> electron <span class="token operator">=</span><span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'electron'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//electron 对象的引用</span><span class="token keyword">const</span> app<span class="token operator">=</span>electron<span class="token punctuation">.</span>app<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//BrowserWindow 类的引用</span><span class="token keyword">const</span> BrowserWindow<span class="token operator">=</span>electron<span class="token punctuation">.</span>BrowserWindow<span class="token punctuation">;</span><span class="token keyword">let</span> mainWindow<span class="token operator">=</span><span class="token keyword">null</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//监听应用准备完成的事件 app.on('ready',function(){</span><span class="token comment" spellcheck="true">//监听应用准备完成的事件</span>app<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">'ready'</span><span class="token punctuation">,</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//创建窗口</span>    mainWindow<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">BrowserWindow</span><span class="token punctuation">(</span><span class="token punctuation">{</span>width<span class="token punctuation">:</span> <span class="token number">800</span><span class="token punctuation">,</span> height<span class="token punctuation">:</span> <span class="token number">600</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span> mainWindow<span class="token punctuation">.</span><span class="token function">loadFile</span><span class="token punctuation">(</span><span class="token string">'index.html'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    mainWindow<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">'closed'</span><span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        mainWindow <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//监听所有窗口关闭的事件$</span>app<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">'window-all-closed'</span><span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// On OS X it is common for applications and their menu bar // to stay active until the user quits explicitly with Cmd + Q$</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>process<span class="token punctuation">.</span>platform <span class="token operator">!==</span> <span class="token string">'darwin'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        app<span class="token punctuation">.</span><span class="token function">quit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>$    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol><li>运行</li></ol><pre class="line-numbers language-bash"><code class="language-bash">electron <span class="token keyword">.</span> <span class="token comment" spellcheck="true">#注意:命令后面有个点</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>4. electron-forge 搭建一个 electron 项目</strong></p><blockquote><p><code>electron-forge</code> 相当于 <code>electron</code> 的一个脚手架，可以让我们更方便的创建、运行、打包 <code>electron</code> 项目</p></blockquote><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">npm</span> <span class="token function">install</span> -g electron-forge$electron-forge init my-new-app$<span class="token function">cd</span> my-new-app<span class="token function">npm</span> start<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="三、Electron-运行流程"><a href="#三、Electron-运行流程" class="headerlink" title="三、Electron 运行流程"></a>三、Electron 运行流程</h2><h3 id="1-Electron-运行的流程"><a href="#1-Electron-运行的流程" class="headerlink" title="1 Electron 运行的流程"></a>1 Electron 运行的流程</h3><p><img src="https://pic.lixl.cn/2020/app-files.png" alt="Electron app components diagram"></p><h3 id="2-Electron-主进程和渲染进程"><a href="#2-Electron-主进程和渲染进程" class="headerlink" title="2 Electron 主进程和渲染进程"></a>2 Electron 主进程和渲染进程</h3><ul><li><p><code>Electron</code> 运行 <code>package.json</code> 的 <code>main</code> 脚本的进程被称为主进程。</p></li><li><p>在主进程中运行的脚本通过创建 <code>web</code> 页面来展示用户界面。 一个 <code>Electron</code> 应用总是有且只有一个主进程。</p></li><li><p>由于 <code>Electron</code> 使用了 <code>Chromium</code>(谷歌浏览器)来展示 <code>web</code> 页面，所以 <code>Chromium</code> 的 多进程架构也被使用到。 每个 <code>Electron</code> 中的 <code>web</code> 页面运行在它自己的渲染进程中。</p></li><li><p>主进程使用 <code>BrowserWindow</code> 实例创建页面。每个 <code>BrowserWindow</code> 实例都在自己的渲 染进程里运行页面。 当一个 <code>BrowserWindow</code>实例被销毁后，相应的渲染进程也会被终止。</p></li></ul><h3 id="3-Electron-渲染进程中通过-Nodejs-读取本地文件"><a href="#3-Electron-渲染进程中通过-Nodejs-读取本地文件" class="headerlink" title="3 Electron 渲染进程中通过 Nodejs 读取本地文件"></a>3 Electron 渲染进程中通过 Nodejs 读取本地文件</h3><blockquote><p>在普通的浏览器中，<code>web</code>页面通常在一个沙盒环境中运行，不被允许去接触原生的资源。 然而 <code>Electron</code> 的用户在 <code>Node.js</code> 的 <code>API</code>支持下可以在页面中和操作系统进行一些底层交互。<br><code>Nodejs</code> 在主进程和渲染进程中都可以使用。渲染进程因为安全限制，不能直接操作生 <code>GUI</code>。虽然如此，因为集成了 Nodejs，渲染进程也有了操作系统底层 <code>API</code>的能力，<code>Nodejs</code> 中常用的 <code>Path</code>、<code>fs</code>、<code>Crypto</code> 等模块在 <code>Electron</code> 可以直接使用，方便我们处理链接、路径、 文件 <code>MD5</code> 等，同时 <code>npm</code> 还有成千上万的模块供我们选择。</p></blockquote><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">var</span> fs <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'fs'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">var</span> content <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'content'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">var</span> button <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'button'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>button<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'click'</span><span class="token punctuation">,</span><span class="token keyword">function</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">{</span>    fs<span class="token punctuation">.</span><span class="token function">readFile</span><span class="token punctuation">(</span><span class="token string">'package.json'</span><span class="token punctuation">,</span><span class="token string">'utf8'</span><span class="token punctuation">,</span><span class="token keyword">function</span><span class="token punctuation">(</span>err<span class="token punctuation">,</span>data<span class="token punctuation">)</span><span class="token punctuation">{</span>        content<span class="token punctuation">.</span>textContent <span class="token operator">=</span> data<span class="token punctuation">;</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4-Electron-开启调试模式"><a href="#4-Electron-开启调试模式" class="headerlink" title="4 Electron 开启调试模式"></a>4 Electron 开启调试模式</h3><pre class="line-numbers language-js"><code class="language-js">mainWindow<span class="token punctuation">.</span>webContents<span class="token punctuation">.</span><span class="token function">openDevTools</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="四、Electron-模块介绍"><a href="#四、Electron-模块介绍" class="headerlink" title="四、Electron 模块介绍"></a>四、Electron 模块介绍</h2><blockquote><p><code>Electron</code> 模块介绍、<code>remote</code> 模块、通 过 <code>BrowserWindow</code> 打开新窗口</p></blockquote><h3 id="1-Electron-主进程和渲染进程中的模块"><a href="#1-Electron-主进程和渲染进程中的模块" class="headerlink" title="1 Electron 主进程和渲染进程中的模块"></a>1 Electron 主进程和渲染进程中的模块</h3><p><img src="https://pic.lixl.cn/2020/image-20200220150228297.png" alt="image-20200220150228297"></p><p><img src="https://pic.lixl.cn/2020/52.png" alt="img"></p><h3 id="2-Electron-remote-模块"><a href="#2-Electron-remote-模块" class="headerlink" title="2 Electron remote 模块"></a>2 Electron remote 模块</h3><blockquote><p><code>remote</code> 模块提供了一种在渲染进程(网页)和主进程之间进行进程间通讯(<code>IPC</code>)的简便途径。在 <code>Electron</code> 中, 与 <code>GUI</code> 相关的模块(如 <code>dialog</code>, <code>menu</code> 等)只存在于主进程，而不在渲染进程中 。为了能从渲染进程中使用它们，需要用<code>ipc</code>模块来给主进程发送进程间消息。使用 <code>remote</code> 模块，可以调用主进程对象的方法，而无需显式地发送进程间消息，这类似于 <code>Java</code> 的 <code>RMI</code>。</p></blockquote><h3 id="3-通过BrowserWindow-打开新窗口"><a href="#3-通过BrowserWindow-打开新窗口" class="headerlink" title="3 通过BrowserWindow 打开新窗口"></a>3 通过BrowserWindow 打开新窗口</h3><blockquote><p><code>Electron</code> 渲染进程中通过 <strong><code>remote</code> 模块调用主进程中的 <code>BrowserWindow</code></strong> 打开新窗口，详情可参考：<br><a href="https://electronjs.org/docs/api/browser-window" target="_blank" rel="noopener">https://electronjs.org/docs/api/browser-window</a></p></blockquote><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">// 主进程代码</span><span class="token keyword">const</span> electron <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'electron'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 控制应用生命周期的模块</span><span class="token keyword">const</span> <span class="token punctuation">{</span>app<span class="token punctuation">}</span> <span class="token operator">=</span> electron<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 创建本地浏览器窗口的模块</span><span class="token keyword">const</span> <span class="token punctuation">{</span>BrowserWindow<span class="token punctuation">}</span> <span class="token operator">=</span> electron<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 指向窗口对象的一个全局引用，如果没有这个引用，那么当该 javascript 对象被垃圾回收 的</span><span class="token comment" spellcheck="true">// 时候该窗口将会自动关闭</span><span class="token keyword">let</span> win<span class="token punctuation">;</span><span class="token keyword">function</span> <span class="token function">createWindow</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 创建一个新的浏览器窗口</span>    win <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BrowserWindow</span><span class="token punctuation">(</span><span class="token punctuation">{</span>width<span class="token punctuation">:</span> <span class="token number">1104</span><span class="token punctuation">,</span> height<span class="token punctuation">:</span> <span class="token number">620</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//570+50</span>   $    <span class="token comment" spellcheck="true">// 并且装载应用的 index.html 页面</span>    win<span class="token punctuation">.</span><span class="token function">loadURL</span><span class="token punctuation">(</span><span class="token template-string"><span class="token string">`file://</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>__dirname<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">/html/index.html`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>   $    <span class="token comment" spellcheck="true">// 打开开发工具页面</span>    win<span class="token punctuation">.</span>webContents<span class="token punctuation">.</span><span class="token function">openDevTools</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   $    <span class="token comment" spellcheck="true">//当窗口关闭时调用的方法</span>    win<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">'closed'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 解除窗口对象的引用，通常而言如果应用支持多个窗口的话，你会在一个数组里 // 存放窗口对象，在窗口关闭的时候应当删除相应的元素。</span>        win <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 当 Electron 完成初始化并且已经创建了浏览器窗口，则该方法将会被调用。</span><span class="token comment" spellcheck="true">// 有些 API 只能在该事件发生后才能被使用</span>app<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">'ready'</span><span class="token punctuation">,</span> createWindow<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 当所有的窗口被关闭后退出应用</span>app<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">'window-all-closed'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 对于 OS X 系统，应用和相应的菜单栏会一直激活直到用户通过 Cmd + Q 显式退出$</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>process<span class="token punctuation">.</span>platform <span class="token operator">!==</span> <span class="token string">'darwin'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        app<span class="token punctuation">.</span><span class="token function">quit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>app<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">'activate'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 对于 OS X 系统，当 dock 图标被点击后会重新创建一个 app 窗口，并且不会有其他</span>    <span class="token comment" spellcheck="true">// 窗口打开</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>win <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">createWindow</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>$    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 在这个文件后面你可以直接包含你应用特定的由主进程运行的代码。$</span><span class="token comment" spellcheck="true">// 也可以把这些代码放在另一个文件中然后在这里导入</span><span class="token comment" spellcheck="true">// 渲染进程代码 /src/render/index.js</span><span class="token comment" spellcheck="true">// 打开新窗口属性用法有点类似vscode打开新的窗口</span><span class="token keyword">const</span> btn <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">querySelector</span><span class="token punctuation">(</span><span class="token string">'#btn'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">const</span> path <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'path'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">const</span> BrowerWindow <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'electron'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>remote<span class="token punctuation">.</span>BrowserWindow<span class="token punctuation">;</span>btn<span class="token punctuation">.</span>onclick <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>    win <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BrowerWindow</span><span class="token punctuation">(</span><span class="token punctuation">{</span>$        width<span class="token punctuation">:</span> <span class="token number">300</span><span class="token punctuation">,</span>        height<span class="token punctuation">:</span> <span class="token number">200</span><span class="token punctuation">,</span>$        frame<span class="token punctuation">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// false隐藏关闭按钮、菜单选项 true显示</span>        fullscreen<span class="token punctuation">:</span><span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// 全屏展示</span>        transparent<span class="token punctuation">:</span> <span class="token boolean">true</span>$    <span class="token punctuation">}</span><span class="token punctuation">)</span>$    win<span class="token punctuation">.</span><span class="token function">loadURL</span><span class="token punctuation">(</span>path<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token string">'file:'</span><span class="token punctuation">,</span>__dirname<span class="token punctuation">,</span><span class="token string">'news.html'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    win<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">'close'</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span>win <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://pic.lixl.cn/2020/53.png" alt="img"></p><h2 id="五、自定义顶部菜单-右键菜单"><a href="#五、自定义顶部菜单-右键菜单" class="headerlink" title="五、自定义顶部菜单/右键菜单"></a>五、自定义顶部菜单/右键菜单</h2><p><img src="https://pic.lixl.cn/2020/54.png" alt="img"></p><h3 id="1-主进程中调用Menu模块-自定义软件顶部菜单"><a href="#1-主进程中调用Menu模块-自定义软件顶部菜单" class="headerlink" title="1 主进程中调用Menu模块-自定义软件顶部菜单"></a>1 主进程中调用Menu模块-自定义软件顶部菜单</h3><blockquote><p><a href="https://electronjs.org/docs/api/menu-item" target="_blank" rel="noopener">https://electronjs.org/docs/api/menu-item</a><br><code>Electron</code> 中 <code>Menu</code> 模块可以用来创建原生菜单，它可用作应用菜单和 <code>context</code> 菜单<br>这个模块是一个主进程的模块，并且可以通过 <code>remote</code> 模块给渲染进程调用</p></blockquote><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">// main/menu.js</span><span class="token keyword">const</span> <span class="token punctuation">{</span> Menu <span class="token punctuation">}</span>  <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'electron'</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">// 文档 https://electronjs.org/docs/api/menu-item</span><span class="token comment" spellcheck="true">// 菜单项目</span><span class="token keyword">let</span> menus <span class="token operator">=</span> <span class="token punctuation">[</span>    <span class="token punctuation">{</span>        label<span class="token punctuation">:</span> <span class="token string">'文件'</span><span class="token punctuation">,</span>        submenu<span class="token punctuation">:</span> <span class="token punctuation">[</span>            <span class="token punctuation">{</span>                label<span class="token punctuation">:</span> <span class="token string">'新建文件'</span><span class="token punctuation">,</span>                accelerator<span class="token punctuation">:</span> <span class="token string">'ctrl+n'</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// 绑定快捷键</span>                click<span class="token punctuation">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 绑定事件</span>                    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'新建文件'</span><span class="token punctuation">)</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span><span class="token punctuation">,</span>            <span class="token punctuation">{</span>                label<span class="token punctuation">:</span> <span class="token string">'新建窗口'</span><span class="token punctuation">,</span>                click<span class="token punctuation">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'新建窗口'</span><span class="token punctuation">)</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">]</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>        label<span class="token punctuation">:</span> <span class="token string">'编辑'</span><span class="token punctuation">,</span>        submenu<span class="token punctuation">:</span> <span class="token punctuation">[</span>            <span class="token punctuation">{</span>                label<span class="token punctuation">:</span> <span class="token string">'复制'</span><span class="token punctuation">,</span>                role<span class="token punctuation">:</span> <span class="token string">'copy'</span> <span class="token comment" spellcheck="true">// 调用内置角色实现对应功能</span>            <span class="token punctuation">}</span><span class="token punctuation">,</span>            <span class="token punctuation">{</span>                label<span class="token punctuation">:</span> <span class="token string">'剪切'</span><span class="token punctuation">,</span>                role<span class="token punctuation">:</span> <span class="token string">'cut'</span>  <span class="token comment" spellcheck="true">// 调用内置角色实现对应功能</span>            <span class="token punctuation">}</span>        <span class="token punctuation">]</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>        label<span class="token punctuation">:</span> <span class="token string">'视图'</span><span class="token punctuation">,</span>        submenu<span class="token punctuation">:</span> <span class="token punctuation">[</span>            <span class="token punctuation">{</span>                label<span class="token punctuation">:</span> <span class="token string">'浏览'</span>            <span class="token punctuation">}</span><span class="token punctuation">,</span>            <span class="token punctuation">{</span>                label<span class="token punctuation">:</span> <span class="token string">'搜索'</span>            <span class="token punctuation">}</span>        <span class="token punctuation">]</span>    <span class="token punctuation">}</span><span class="token punctuation">]</span><span class="token keyword">let</span> m <span class="token operator">=</span> Menu<span class="token punctuation">.</span><span class="token function">buildFromTemplate</span><span class="token punctuation">(</span>menus<span class="token punctuation">)</span>Menu<span class="token punctuation">.</span><span class="token function">setApplicationMenu</span><span class="token punctuation">(</span>m<span class="token punctuation">)</span><span class="token comment" spellcheck="true">// 在主进程src/index.js中引入</span><span class="token keyword">const</span> createWindow <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// 创建菜单 $</span>  <span class="token comment" spellcheck="true">// 引入菜单模块</span>  <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'./main/menu.js'</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://pic.lixl.cn/2020/55.png" alt="img"></p><blockquote><p>我们给菜单绑定事件，在命令行控制台可以看到</p></blockquote><p><img src="https://pic.lixl.cn/2020/56.png" alt="img"></p><h3 id="2-渲染进程中调用Menu模块"><a href="#2-渲染进程中调用Menu模块" class="headerlink" title="2 渲染进程中调用Menu模块"></a>2 渲染进程中调用Menu模块</h3><blockquote><p>不推荐使用这种方式，建议在主进程中使用</p></blockquote><p><strong>1. remote</strong></p><blockquote><p>通过<code>remote</code>调用主进程的方法</p></blockquote><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">// 菜单引入的方式发生变化</span><span class="token keyword">const</span> <span class="token punctuation">{</span> Menu <span class="token punctuation">}</span>  <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'electron'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>remote<span class="token comment" spellcheck="true">// 其他代码和上面菜单一样</span><span class="token comment" spellcheck="true">// ...</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>2. 加入index.html</strong></p><pre class="line-numbers language-js"><code class="language-js"><span class="token operator">&lt;</span>script src<span class="token operator">=</span><span class="token string">"render/menu.js"</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="3-渲染进程中自定义右键菜单"><a href="#3-渲染进程中自定义右键菜单" class="headerlink" title="3 渲染进程中自定义右键菜单"></a>3 渲染进程中自定义右键菜单</h3><p><strong>1. 定义菜单</strong></p><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">// render/menu.js</span><span class="token comment" spellcheck="true">// 在渲染进程中通过remote模块调用主进程中的模块</span><span class="token keyword">const</span> <span class="token punctuation">{</span> Menu <span class="token punctuation">}</span>  <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'electron'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>remote<span class="token keyword">const</span> <span class="token punctuation">{</span> remote <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'electron'</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">// 文档 https://electronjs.org/docs/api/menu-item</span><span class="token comment" spellcheck="true">// 菜单项目</span><span class="token keyword">let</span> menus <span class="token operator">=</span> <span class="token punctuation">[</span>    <span class="token punctuation">{</span>        label<span class="token punctuation">:</span> <span class="token string">'文件'</span><span class="token punctuation">,</span>        submenu<span class="token punctuation">:</span> <span class="token punctuation">[</span>            <span class="token punctuation">{</span>                label<span class="token punctuation">:</span> <span class="token string">'新建文件'</span><span class="token punctuation">,</span>                accelerator<span class="token punctuation">:</span> <span class="token string">'ctrl+n'</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// 绑定快捷键</span>                click<span class="token punctuation">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 绑定事件</span>                    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'新建文件'</span><span class="token punctuation">)</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span><span class="token punctuation">,</span>            <span class="token punctuation">{</span>                label<span class="token punctuation">:</span> <span class="token string">'新建窗口'</span><span class="token punctuation">,</span>                click<span class="token punctuation">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'新建窗口'</span><span class="token punctuation">)</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">]</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>        label<span class="token punctuation">:</span> <span class="token string">'编辑'</span><span class="token punctuation">,</span>        submenu<span class="token punctuation">:</span> <span class="token punctuation">[</span>            <span class="token punctuation">{</span>                label<span class="token punctuation">:</span> <span class="token string">'复制'</span><span class="token punctuation">,</span>                role<span class="token punctuation">:</span> <span class="token string">'copy'</span> <span class="token comment" spellcheck="true">// 调用内置角色实现对应功能</span>            <span class="token punctuation">}</span><span class="token punctuation">,</span>            <span class="token punctuation">{</span>                label<span class="token punctuation">:</span> <span class="token string">'剪切'</span><span class="token punctuation">,</span>                role<span class="token punctuation">:</span> <span class="token string">'cut'</span>  <span class="token comment" spellcheck="true">// 调用内置角色实现对应功能</span>            <span class="token punctuation">}</span>        <span class="token punctuation">]</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>        label<span class="token punctuation">:</span> <span class="token string">'视图'</span><span class="token punctuation">,</span>        submenu<span class="token punctuation">:</span> <span class="token punctuation">[</span>            <span class="token punctuation">{</span>                label<span class="token punctuation">:</span> <span class="token string">'浏览'</span>            <span class="token punctuation">}</span><span class="token punctuation">,</span>            <span class="token punctuation">{</span>                label<span class="token punctuation">:</span> <span class="token string">'搜索'</span>            <span class="token punctuation">}</span>        <span class="token punctuation">]</span>    <span class="token punctuation">}</span><span class="token punctuation">]</span><span class="token keyword">let</span> m <span class="token operator">=</span> Menu<span class="token punctuation">.</span><span class="token function">buildFromTemplate</span><span class="token punctuation">(</span>menus<span class="token punctuation">)</span><span class="token comment" spellcheck="true">// Menu.setApplicationMenu(m)</span><span class="token comment" spellcheck="true">// 绑定右键菜单</span>window<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'contextmenu'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span>   e<span class="token punctuation">.</span><span class="token function">preventDefault</span><span class="token punctuation">(</span><span class="token punctuation">)</span>   m<span class="token punctuation">.</span><span class="token function">popup</span><span class="token punctuation">(</span><span class="token punctuation">{</span>    window<span class="token punctuation">:</span> remote<span class="token punctuation">.</span><span class="token function">getCurrentWindow</span><span class="token punctuation">(</span><span class="token punctuation">)</span>   <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://pic.lixl.cn/2020/57.png" alt="img"></p><p><strong>2. 引入</strong></p><pre class="line-numbers language-js"><code class="language-js"><span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span>index<span class="token punctuation">.</span>html<span class="token operator">--</span><span class="token operator">></span><span class="token operator">&lt;</span>script src<span class="token operator">=</span><span class="token string">"render/menu.js"</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="六、进程通信"><a href="#六、进程通信" class="headerlink" title="六、进程通信"></a>六、进程通信</h2><p><img src="https://pic.lixl.cn/2020/58.png" alt="img"></p><ul><li>渲染进程 <a href="https://electronjs.org/docs/api/ipc-renderer" target="_blank" rel="noopener">https://electronjs.org/docs/api/ipc-renderer</a></li><li>主进程 <a href="https://electronjs.org/docs/api/ipc-main" target="_blank" rel="noopener">https://electronjs.org/docs/api/ipc-main</a></li></ul><h3 id="1-主进程与渲染进程之间的通信"><a href="#1-主进程与渲染进程之间的通信" class="headerlink" title="1 主进程与渲染进程之间的通信"></a>1 主进程与渲染进程之间的通信</h3><blockquote><p>有时候我们想在渲染进程中通过一个事件去执行主进程里面的方法。或者在渲染进程中通知 主进程处理事件，主进程处理完成后广播一个事件让渲染进程去处理一些事情。这个时候就 用到了主进程和渲染进程之间的相互通信</p></blockquote><blockquote><p><code>Electron</code> 主进程，和渲染进程的通信主要用到两个模块:<code>ipcMain</code> 和 <code>ipcRenderer</code></p></blockquote><ul><li><code>ipcMain</code>:当在主进程中使用时，它处理从渲染器进程(网页)发送出来的异步和同步信息,当然也有可能从主进程向渲染进程发送消息。</li><li><code>ipcRenderer</code>: 使用它提供的一些方法从渲染进程 (<code>web</code> 页面) 发送同步或异步的消息到主进程。 也可以接收主进程回复的消息</li></ul><h4 id="1-1-渲染进程给主进程发送异步消息"><a href="#1-1-渲染进程给主进程发送异步消息" class="headerlink" title="1.1 渲染进程给主进程发送异步消息"></a>1.1 渲染进程给主进程发送异步消息</h4><blockquote><p>间接实现渲染进程执行主进程里面的方法</p></blockquote><p><strong>1. 引入ipcRender</strong></p><pre class="line-numbers language-js"><code class="language-js"><span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span>src<span class="token operator">/</span>index<span class="token punctuation">.</span>html<span class="token operator">--</span><span class="token operator">></span><span class="token operator">&lt;</span>button id<span class="token operator">=</span><span class="token string">"send"</span><span class="token operator">></span>在 渲染进程中执行主进程里的方法（异步）<span class="token operator">&lt;</span><span class="token operator">/</span>button<span class="token operator">></span><span class="token operator">&lt;</span>script src<span class="token operator">=</span><span class="token string">"render/ipcRender.js"</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>2. 引入ipcMain</strong></p><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">// 在主进程src/index.js中引入</span><span class="token keyword">const</span> createWindow <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// 创建菜单 $</span>  <span class="token comment" spellcheck="true">// 引入菜单模块</span>  <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'./main/ipcMain.js'</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>3. 渲染进程发送消息</strong></p><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">// src/render/ipcRender.js</span><span class="token comment" spellcheck="true">//渲染进程</span><span class="token keyword">let</span> send <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">querySelector</span><span class="token punctuation">(</span><span class="token string">'#send'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">const</span> <span class="token punctuation">{</span> ipcRenderer <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'electron'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>send<span class="token punctuation">.</span>onclick <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 传递消息给主进程</span>    <span class="token comment" spellcheck="true">// 异步</span>    ipcRenderer<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span><span class="token string">'sendMsg'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>name<span class="token punctuation">:</span><span class="token string">'poetries'</span><span class="token punctuation">,</span> age<span class="token punctuation">:</span> <span class="token number">23</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>2. 主进程接收消息</strong></p><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">// src/main/ipcMain.js</span><span class="token comment" spellcheck="true">//主进程</span><span class="token keyword">const</span> <span class="token punctuation">{</span> ipcMain <span class="token punctuation">}</span>  <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'electron'</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">// 主进程处理渲染进程广播数据</span>ipcMain<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">'sendMsg'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>event<span class="token punctuation">,</span> data<span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'data\n '</span><span class="token punctuation">,</span> data<span class="token punctuation">)</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'event\n '</span><span class="token punctuation">,</span> event<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://pic.lixl.cn/2020/59.png" alt="img"></p><h4 id="1-2-渲染进程发送消息，主进程接收消息并反馈"><a href="#1-2-渲染进程发送消息，主进程接收消息并反馈" class="headerlink" title="1.2 渲染进程发送消息，主进程接收消息并反馈"></a>1.2 渲染进程发送消息，主进程接收消息并反馈</h4><blockquote><p>渲染进程给主进程发送异步消息，主进程接收到异步消息以后通知渲染进程</p></blockquote><p><strong>1. 引入ipcRender</strong></p><pre class="line-numbers language-js"><code class="language-js"><span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span>src<span class="token operator">/</span>index<span class="token punctuation">.</span>html<span class="token operator">--</span><span class="token operator">></span><span class="token operator">&lt;</span>button id<span class="token operator">=</span><span class="token string">"sendFeedback"</span><span class="token operator">></span>在 渲染进程中执行主进程里的方法，并反馈给主进程（异步）<span class="token operator">&lt;</span><span class="token operator">/</span>button<span class="token operator">></span><span class="token operator">&lt;</span>script src<span class="token operator">=</span><span class="token string">"render/ipcRender.js"</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>2. 引入ipcMain</strong></p><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">// 在主进程src/index.js中引入</span><span class="token keyword">const</span> createWindow <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// 创建菜单 $</span>  <span class="token comment" spellcheck="true">// 引入菜单模块</span>  <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'./main/ipcMain.js'</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>3. 渲染进程发送消息</strong></p><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">// src/render/ipcRender.js</span><span class="token comment" spellcheck="true">//渲染进程</span><span class="token keyword">let</span> sendFeedback <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">querySelector</span><span class="token punctuation">(</span><span class="token string">'#sendFeedback'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">const</span> <span class="token punctuation">{</span> ipcRenderer <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'electron'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 向主进程发送消息</span>sendFeedback<span class="token punctuation">.</span>onclick <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 触发主进程里面的方法</span>    ipcRenderer<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span><span class="token string">'sendFeedback'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>name<span class="token punctuation">:</span><span class="token string">'poetries'</span><span class="token punctuation">,</span> age<span class="token punctuation">:</span> <span class="token number">23</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>4. 主进程收到消息处理并广播反馈通知渲染进程</strong></p><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">// src/main/ipcMain.js</span><span class="token comment" spellcheck="true">//主进程</span><span class="token keyword">const</span> <span class="token punctuation">{</span> ipcMain <span class="token punctuation">}</span>  <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'electron'</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">// 主进程处理渲染进程广播数据，并反馈给渲染进程</span>ipcMain<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">'sendFeedback'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>event<span class="token punctuation">,</span> data<span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// console.log('data\n ', data)</span>    <span class="token comment" spellcheck="true">// console.log('event\n ', event)</span>   $    <span class="token comment" spellcheck="true">// 主进程给渲染进程广播数据</span>    event<span class="token punctuation">.</span>sender<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span><span class="token string">'sendFeedbackToRender'</span><span class="token punctuation">,</span> <span class="token string">'来自主进程的反馈'</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>5. 渲染进程处理主进程广播的数据</strong></p><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">// src/render/ipcRender.js</span><span class="token comment" spellcheck="true">// 向主进程发送消息后，接收主进程广播的事件</span>ipcRenderer<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">'sendFeedbackToRender'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>e<span class="token punctuation">,</span> data<span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'event\n '</span><span class="token punctuation">,</span> e<span class="token punctuation">)</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'data\n '</span><span class="token punctuation">,</span> data<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://pic.lixl.cn/2020/60.png" alt="img"></p><h4 id="1-3-渲染进程给主进程发送同步消息"><a href="#1-3-渲染进程给主进程发送同步消息" class="headerlink" title="1.3 渲染进程给主进程发送同步消息"></a>1.3 渲染进程给主进程发送同步消息</h4><p><strong>1. 引入ipcRender</strong></p><pre class="line-numbers language-js"><code class="language-js"><span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span>src<span class="token operator">/</span>index<span class="token punctuation">.</span>html<span class="token operator">--</span><span class="token operator">></span> <span class="token operator">&lt;</span>button id<span class="token operator">=</span><span class="token string">"sendSync"</span><span class="token operator">></span>渲染进程和主进程同步通信<span class="token operator">&lt;</span><span class="token operator">/</span>button<span class="token operator">></span><span class="token operator">&lt;</span>script src<span class="token operator">=</span><span class="token string">"render/ipcRender.js"</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>2. 引入ipcMain</strong></p><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">// 在主进程src/index.js中引入</span><span class="token keyword">const</span> createWindow <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// 创建菜单 $</span>  <span class="token comment" spellcheck="true">// 引入菜单模块</span>  <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'./main/ipcMain.js'</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>3. 渲染进程给主进程同步通信</strong></p><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">// src/render/ipcMain.js</span><span class="token keyword">let</span> sendSync <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">querySelector</span><span class="token punctuation">(</span><span class="token string">'#sendSync'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 渲染进程和主进程同步通信</span>sendSync<span class="token punctuation">.</span>onclick <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 同步广播数据</span>   <span class="token keyword">let</span> msg <span class="token operator">=</span>  ipcRenderer<span class="token punctuation">.</span><span class="token function">sendSync</span><span class="token punctuation">(</span><span class="token string">'sendsync'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>name<span class="token punctuation">:</span><span class="token string">'poetries'</span><span class="token punctuation">,</span> age<span class="token punctuation">:</span> <span class="token number">23</span><span class="token punctuation">}</span><span class="token punctuation">)</span>   $   <span class="token comment" spellcheck="true">// 同步返回主进程反馈的数据</span>   console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'msg\n '</span><span class="token punctuation">,</span> msg<span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>4. 主进程接收数据处理</strong></p><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">// src/main/ipcMain.js</span><span class="token comment" spellcheck="true">// 渲染进程和主进程同步通信 接收同步广播</span>ipcMain<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">'sendsync'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>event<span class="token punctuation">,</span> data<span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// console.log('data\n ', data)</span>    <span class="token comment" spellcheck="true">// console.log('event\n ', event)</span>    <span class="token comment" spellcheck="true">// 主进程给渲染进程广播数据</span>    event<span class="token punctuation">.</span>returnValue <span class="token operator">=</span><span class="token string">'渲染进程和主进程同步通信 接收同步广播，来自主进程的反馈.'</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://pic.lixl.cn/2020/61.png" alt="img"></p><h4 id="1-4-渲染进程广播通知主进程打开窗口"><a href="#1-4-渲染进程广播通知主进程打开窗口" class="headerlink" title="1.4 渲染进程广播通知主进程打开窗口"></a>1.4 渲染进程广播通知主进程打开窗口</h4><blockquote><p>一般都是在渲染进程中执行广播操作，去通知主进程完成任务</p></blockquote><p><strong>1. 引入openWindow</strong></p><pre class="line-numbers language-js"><code class="language-js"><span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span>src<span class="token operator">/</span>index<span class="token punctuation">.</span>html<span class="token operator">--</span><span class="token operator">></span> <span class="token operator">&lt;</span>button id<span class="token operator">=</span><span class="token string">"sendSync"</span><span class="token operator">></span>渲染进程和主进程同步通信<span class="token operator">&lt;</span><span class="token operator">/</span>button<span class="token operator">></span><span class="token operator">&lt;</span>script src<span class="token operator">=</span><span class="token string">"render/openWindow.js"</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>2. 引入ipcMain2</strong></p><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">// 在主进程src/index.js中引入</span><span class="token keyword">const</span> createWindow <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// 创建菜单 $</span>  <span class="token comment" spellcheck="true">// 引入菜单模块</span>  <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'./main/ipcMain2.js'</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>3. 渲染进程通知主进程打开窗口</strong></p><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">// src/render/openWindow.js</span><span class="token comment" spellcheck="true">/* eslint-disable */</span><span class="token keyword">let</span> openWindow <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">querySelector</span><span class="token punctuation">(</span><span class="token string">'#openWindow'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">var</span> <span class="token punctuation">{</span> ipcRenderer <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'electron'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 渲染进程和渲染进程直接的通信========</span>openWindow<span class="token punctuation">.</span>onclick <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 通过广播的形式 通知主进程执行操作</span>    ipcRenderer<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span><span class="token string">'openwindow'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>name<span class="token punctuation">:</span><span class="token string">'poetries'</span><span class="token punctuation">,</span> age<span class="token punctuation">:</span> <span class="token number">23</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>4. 主进程收到通知执行操作</strong></p><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">// src/main/ipcMain2.js</span><span class="token comment" spellcheck="true">/* eslint-disable */</span><span class="token keyword">let</span> <span class="token punctuation">{</span> ipcMain<span class="token punctuation">,</span>BrowserWindow <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'electron'</span><span class="token punctuation">)</span><span class="token keyword">const</span> path <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'path'</span><span class="token punctuation">)</span><span class="token keyword">let</span> win<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 接收到广播</span>ipcMain<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">'openwindow'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>e<span class="token punctuation">,</span> data<span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 调用window打开新窗口</span>    win <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BrowserWindow</span><span class="token punctuation">(</span><span class="token punctuation">{</span>        width<span class="token punctuation">:</span> <span class="token number">400</span><span class="token punctuation">,</span>        height<span class="token punctuation">:</span> <span class="token number">300</span><span class="token punctuation">,</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    win<span class="token punctuation">.</span><span class="token function">loadURL</span><span class="token punctuation">(</span>path<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token string">'file:'</span><span class="token punctuation">,</span>__dirname<span class="token punctuation">,</span> <span class="token string">'../news.html'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    win<span class="token punctuation">.</span>webContents<span class="token punctuation">.</span><span class="token function">openDevTools</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    win<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">'closed'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>        win <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://pic.lixl.cn/2020/62.png" alt="img"></p><h3 id="2-渲染进程与渲染进程之间的通信"><a href="#2-渲染进程与渲染进程之间的通信" class="headerlink" title="2 渲染进程与渲染进程之间的通信"></a>2 渲染进程与渲染进程之间的通信</h3><blockquote><p>也就是两个窗口直接的通信</p></blockquote><h4 id="2-1-localstorage传值"><a href="#2-1-localstorage传值" class="headerlink" title="2.1 localstorage传值"></a>2.1 localstorage传值</h4><blockquote><p><code>Electron</code> 渲染进程通过 <code>localstorage</code> 给另一个渲染进程传值</p></blockquote><p><strong>1. 引入openWindow</strong></p><pre class="line-numbers language-js"><code class="language-js"><span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span>src<span class="token operator">/</span>index<span class="token punctuation">.</span>html<span class="token operator">--</span><span class="token operator">></span> <span class="token operator">&lt;</span>button id<span class="token operator">=</span><span class="token string">"sendSync"</span><span class="token operator">></span>渲染进程和主进程同步通信<span class="token operator">&lt;</span><span class="token operator">/</span>button<span class="token operator">></span><span class="token operator">&lt;</span>script src<span class="token operator">=</span><span class="token string">"render/openWindow.js"</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>2. 引入ipcMain2</strong></p><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">// 在主进程src/index.js中引入</span><span class="token keyword">const</span> createWindow <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// 创建菜单 $</span>  <span class="token comment" spellcheck="true">// 引入菜单模块</span>  <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'./main/ipcMain2.js'</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>3. 渲染进程通知主进程打开窗口</strong></p><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">// src/render/openWindow.js</span><span class="token comment" spellcheck="true">/* eslint-disable */</span><span class="token keyword">let</span> openWindow <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">querySelector</span><span class="token punctuation">(</span><span class="token string">'#openWindow'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">var</span> <span class="token punctuation">{</span> ipcRenderer <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'electron'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 渲染进程和渲染进程直接的通信========</span>openWindow<span class="token punctuation">.</span>onclick <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 通过广播的形式 通知主进程执行操作</span>    ipcRenderer<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span><span class="token string">'openwindow'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>name<span class="token punctuation">:</span><span class="token string">'poetries'</span><span class="token punctuation">,</span> age<span class="token punctuation">:</span> <span class="token number">23</span><span class="token punctuation">}</span><span class="token punctuation">)</span>   $    <span class="token comment" spellcheck="true">// ======= localstorage传值 =====</span>     localStorage<span class="token punctuation">.</span><span class="token function">setItem</span><span class="token punctuation">(</span><span class="token string">'username'</span><span class="token punctuation">,</span> <span class="token string">'poetries'</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>4. 新建news页面</strong></p><pre class="line-numbers language-js"><code class="language-js"><span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span>src<span class="token operator">/</span>news<span class="token punctuation">.</span>html<span class="token operator">--</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">!</span>DOCTYPE html<span class="token operator">></span><span class="token operator">&lt;</span>html<span class="token operator">></span>  <span class="token operator">&lt;</span>head<span class="token operator">></span>    <span class="token operator">&lt;</span>meta charset<span class="token operator">=</span><span class="token string">"utf-8"</span><span class="token operator">></span>    <span class="token operator">&lt;</span>title<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>title<span class="token operator">></span>  <span class="token operator">&lt;</span><span class="token operator">/</span>head<span class="token operator">></span>  <span class="token operator">&lt;</span>body<span class="token operator">></span>    news page  <span class="token operator">&lt;</span><span class="token operator">/</span>body<span class="token operator">></span>  <span class="token operator">&lt;</span>script src<span class="token operator">=</span><span class="token string">"render/news.js"</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>html<span class="token operator">></span><span class="token comment" spellcheck="true">// src/render/news.js</span><span class="token keyword">let</span> username <span class="token operator">=</span> localStorage<span class="token punctuation">.</span><span class="token function">getItem</span><span class="token punctuation">(</span><span class="token string">'username'</span><span class="token punctuation">)</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>username<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>5. 主进程收到通知执行操作</strong></p><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">// src/main/ipcMain2.js</span><span class="token comment" spellcheck="true">/* eslint-disable */</span><span class="token keyword">let</span> <span class="token punctuation">{</span> ipcMain<span class="token punctuation">,</span>BrowserWindow <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'electron'</span><span class="token punctuation">)</span><span class="token keyword">const</span> path <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'path'</span><span class="token punctuation">)</span><span class="token keyword">let</span> win<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 接收到广播</span>ipcMain<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">'openwindow'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>e<span class="token punctuation">,</span> data<span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 调用window打开新窗口</span>    win <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BrowserWindow</span><span class="token punctuation">(</span><span class="token punctuation">{</span>        width<span class="token punctuation">:</span> <span class="token number">400</span><span class="token punctuation">,</span>        height<span class="token punctuation">:</span> <span class="token number">300</span><span class="token punctuation">,</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    win<span class="token punctuation">.</span><span class="token function">loadURL</span><span class="token punctuation">(</span>path<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token string">'file:'</span><span class="token punctuation">,</span>__dirname<span class="token punctuation">,</span> <span class="token string">'../news.html'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    win<span class="token punctuation">.</span>webContents<span class="token punctuation">.</span><span class="token function">openDevTools</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    win<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">'closed'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>        win <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-2-BrowserWindow和webContents方式实现"><a href="#2-2-BrowserWindow和webContents方式实现" class="headerlink" title="2.2 BrowserWindow和webContents方式实现"></a>2.2 BrowserWindow和webContents方式实现</h4><blockquote><p>通过 <code>BrowserWindow</code> 和 <code>webContents</code> 模块实现渲染进程和渲染进程的通信</p></blockquote><blockquote><p><code>webContents</code> 是一个事件发出者.它负责渲染并控制网页，也是 <code>BrowserWindow</code> 对象的属性</p></blockquote><p><strong>需要了解的几个知识点</strong></p><ol><li>获取当前窗口的 <code>id</code></li></ol><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">const</span> winId <span class="token operator">=</span> BrowserWindow<span class="token punctuation">.</span><span class="token function">getFocusedWindow</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>id<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol><li>监听当前窗口加载完成的事件</li></ol><pre class="line-numbers language-js"><code class="language-js">win<span class="token punctuation">.</span>webContents<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">'did-finish-load'</span><span class="token punctuation">,</span><span class="token punctuation">(</span>event<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>   $<span class="token punctuation">}</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ol><li>同一窗口之间广播数据</li></ol><pre class="line-numbers language-js"><code class="language-js">win<span class="token punctuation">.</span>webContents<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">'did-finish-load'</span><span class="token punctuation">,</span><span class="token punctuation">(</span>event<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>    win<span class="token punctuation">.</span>webContents<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span><span class="token string">'msg'</span><span class="token punctuation">,</span>winId<span class="token punctuation">,</span><span class="token string">'我是 index.html 的数据'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ol><li>通过 <code>id</code> 查找窗口</li></ol><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">let</span> win <span class="token operator">=</span> BrowserWindow<span class="token punctuation">.</span><span class="token function">fromId</span><span class="token punctuation">(</span>winId<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>下面是具体演示</p></blockquote><p><strong>1. 引入openWindow</strong></p><pre class="line-numbers language-js"><code class="language-js"><span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span>src<span class="token operator">/</span>index<span class="token punctuation">.</span>html<span class="token operator">--</span><span class="token operator">></span> <span class="token operator">&lt;</span>button id<span class="token operator">=</span><span class="token string">"sendSync"</span><span class="token operator">></span>渲染进程和主进程同步通信<span class="token operator">&lt;</span><span class="token operator">/</span>button<span class="token operator">></span><span class="token operator">&lt;</span>script src<span class="token operator">=</span><span class="token string">"render/openWindow.js"</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>2. 引入ipcMain2</strong></p><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">// 在主进程src/index.js中引入</span><span class="token keyword">const</span> createWindow <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// 创建菜单 $</span>  <span class="token comment" spellcheck="true">// 引入菜单模块</span>  <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'./main/ipcMain2.js'</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>3. 渲染进程通知主进程打开窗口</strong></p><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">// src/render/openWindow.js</span><span class="token comment" spellcheck="true">/* eslint-disable */</span><span class="token keyword">let</span> openWindow <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">querySelector</span><span class="token punctuation">(</span><span class="token string">'#openWindow'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">var</span> <span class="token punctuation">{</span> ipcRenderer <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'electron'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 渲染进程和渲染进程直接的通信========</span>openWindow<span class="token punctuation">.</span>onclick <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 通过广播的形式 通知主进程执行操作</span>    ipcRenderer<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span><span class="token string">'openwindow'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>name<span class="token punctuation">:</span><span class="token string">'poetries'</span><span class="token punctuation">,</span> age<span class="token punctuation">:</span> <span class="token number">23</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>4. 主进程收到通知执行操作</strong></p><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">// src/main/ipcMain2.js</span><span class="token keyword">let</span> <span class="token punctuation">{</span> ipcMain<span class="token punctuation">,</span>BrowserWindow <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'electron'</span><span class="token punctuation">)</span><span class="token keyword">const</span> path <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'path'</span><span class="token punctuation">)</span><span class="token keyword">let</span> win<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 接收到广播</span>ipcMain<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">'openwindow'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>e<span class="token punctuation">,</span> userInfo<span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 调用window打开新窗口</span>    win <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BrowserWindow</span><span class="token punctuation">(</span><span class="token punctuation">{</span>        width<span class="token punctuation">:</span> <span class="token number">400</span><span class="token punctuation">,</span>        height<span class="token punctuation">:</span> <span class="token number">300</span><span class="token punctuation">,</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    win<span class="token punctuation">.</span><span class="token function">loadURL</span><span class="token punctuation">(</span>path<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token string">'file:'</span><span class="token punctuation">,</span>__dirname<span class="token punctuation">,</span> <span class="token string">'../news.html'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 新开窗口调试模式</span>    win<span class="token punctuation">.</span>webContents<span class="token punctuation">.</span><span class="token function">openDevTools</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">// 把渲染进程传递过来的数据再次传递给渲染进程news</span>    <span class="token comment" spellcheck="true">// 等待窗口加载完</span>    win<span class="token punctuation">.</span>webContents<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">'did-finish-load'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">[</span>        win<span class="token punctuation">.</span>webContents<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span><span class="token string">'toNews'</span><span class="token punctuation">,</span> userInfo<span class="token punctuation">)</span>    <span class="token punctuation">]</span><span class="token punctuation">)</span>   $    win<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">'closed'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>        win <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>5. news接收主进程传递的数据</strong></p><blockquote><p>数据经过渲染进程-&gt;主进程-&gt;<code>news</code>渲染进程</p></blockquote><pre class="line-numbers language-js"><code class="language-js"><span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span>news页面<span class="token operator">--</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">!</span>DOCTYPE html<span class="token operator">></span><span class="token operator">&lt;</span>html<span class="token operator">></span>  <span class="token operator">&lt;</span>head<span class="token operator">></span>    <span class="token operator">&lt;</span>meta charset<span class="token operator">=</span><span class="token string">"utf-8"</span><span class="token operator">></span>    <span class="token operator">&lt;</span>title<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>title<span class="token operator">></span>  <span class="token operator">&lt;</span><span class="token operator">/</span>head<span class="token operator">></span>  <span class="token operator">&lt;</span>body<span class="token operator">></span>    news page  <span class="token operator">&lt;</span><span class="token operator">/</span>body<span class="token operator">></span>  <span class="token operator">&lt;</span>script src<span class="token operator">=</span><span class="token string">"render/news.js"</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>html<span class="token operator">></span><span class="token comment" spellcheck="true">// src/render/news.js</span><span class="token keyword">var</span> <span class="token punctuation">{</span> ipcRenderer <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'electron'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// let username = localStorage.getItem('username')</span><span class="token comment" spellcheck="true">// console.log(username)</span><span class="token comment" spellcheck="true">// 监听主进程传递过来的数据$</span>ipcRenderer<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">'toNews'</span><span class="token punctuation">,</span><span class="token punctuation">(</span>e<span class="token punctuation">,</span> userInfo<span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>userInfo<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://pic.lixl.cn/2020/63.png" alt="img"></p><p><img src="https://pic.lixl.cn/2020/64.png" alt="img"></p><blockquote><p>那么，这里有一个问题，<code>news</code>进程接收到了广播后如何给出反馈呢？</p></blockquote><p><img src="https://pic.lixl.cn/2020/65.png" alt="img"></p><p><strong>1. 在主进程中获取窗口ID传递</strong></p><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">// src/main/ipcMain2.js</span><span class="token keyword">let</span> <span class="token punctuation">{</span> ipcMain<span class="token punctuation">,</span>BrowserWindow <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'electron'</span><span class="token punctuation">)</span><span class="token keyword">const</span> path <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'path'</span><span class="token punctuation">)</span><span class="token keyword">let</span> win<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 接收到广播</span>ipcMain<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">'openwindow'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>e<span class="token punctuation">,</span> userInfo<span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>      <span class="token comment" spellcheck="true">// 获取当前窗口ID 放在第一行保险  因为后面也打开了新窗口使得获取的ID有问题</span>    <span class="token keyword">let</span> winId <span class="token operator">=</span> BrowserWindow<span class="token punctuation">.</span><span class="token function">getFocusedWindow</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>id    <span class="token comment" spellcheck="true">// 调用window打开新窗口</span>    win <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BrowserWindow</span><span class="token punctuation">(</span><span class="token punctuation">{</span>        width<span class="token punctuation">:</span> <span class="token number">400</span><span class="token punctuation">,</span>        height<span class="token punctuation">:</span> <span class="token number">300</span><span class="token punctuation">,</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    win<span class="token punctuation">.</span><span class="token function">loadURL</span><span class="token punctuation">(</span>path<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token string">'file:'</span><span class="token punctuation">,</span>__dirname<span class="token punctuation">,</span> <span class="token string">'../news.html'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 新开窗口调试模式</span>    win<span class="token punctuation">.</span>webContents<span class="token punctuation">.</span><span class="token function">openDevTools</span><span class="token punctuation">(</span><span class="token punctuation">)</span> $    <span class="token comment" spellcheck="true">// 把渲染进程传递过来的数据再次传递给渲染进程news</span>    <span class="token comment" spellcheck="true">// 等待窗口加载完</span>    win<span class="token punctuation">.</span>webContents<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">'did-finish-load'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">[</span>        win<span class="token punctuation">.</span>webContents<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span><span class="token string">'toNews'</span><span class="token punctuation">,</span> userInfo<span class="token punctuation">,</span> winId<span class="token punctuation">)</span>    <span class="token punctuation">]</span><span class="token punctuation">)</span>   $    win<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">'closed'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>        win <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>2. 在news进程中广播数据</strong></p><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">// src/render/news.js</span><span class="token keyword">var</span> <span class="token punctuation">{</span> ipcRenderer <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'electron'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 注意这里 在渲染进程中需要从remote中获取BrowserWindow</span><span class="token keyword">const</span> BrowerWindow <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'electron'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>remote<span class="token punctuation">.</span>BrowserWindow<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// let username = localStorage.getItem('username')</span><span class="token comment" spellcheck="true">// console.log(username)</span><span class="token comment" spellcheck="true">// 监听主进程传递过来的数据$</span>ipcRenderer<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">'toNews'</span><span class="token punctuation">,</span><span class="token punctuation">(</span>e<span class="token punctuation">,</span> userInfo<span class="token punctuation">,</span> winId<span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// windID 第一个窗口ID</span>    <span class="token comment" spellcheck="true">// 获取对应ID的窗口</span>    <span class="token keyword">let</span> firstWin <span class="token operator">=</span> BrowerWindow<span class="token punctuation">.</span><span class="token function">fromId</span><span class="token punctuation">(</span>winId<span class="token punctuation">)</span>    firstWin<span class="token punctuation">.</span>webContents<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span><span class="token string">'toIndex'</span><span class="token punctuation">,</span> <span class="token string">'来自news进程反馈的信息'</span><span class="token punctuation">)</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>userInfo<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>3. 在另一个渲染进程中处理广播</strong></p><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">/* eslint-disable */</span><span class="token keyword">let</span> openWindow <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">querySelector</span><span class="token punctuation">(</span><span class="token string">'#openWindow'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">var</span> <span class="token punctuation">{</span> ipcRenderer <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'electron'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 渲染进程和渲染进程直接的通信========</span>openWindow<span class="token punctuation">.</span>onclick <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 传递消息给主进程</span>    ipcRenderer<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span><span class="token string">'openwindow'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>name<span class="token punctuation">:</span><span class="token string">'poetries'</span><span class="token punctuation">,</span> age<span class="token punctuation">:</span> <span class="token number">23</span><span class="token punctuation">}</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">// 传递给打开的窗口 渲染进程和渲染进程直接的通信</span>    localStorage<span class="token punctuation">.</span><span class="token function">setItem</span><span class="token punctuation">(</span><span class="token string">'username'</span><span class="token punctuation">,</span> <span class="token string">'poetries'</span><span class="token punctuation">)</span>   $<span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 接收news渲染进程传递回来的消息</span>ipcRenderer<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">'toIndex'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>e<span class="token punctuation">,</span> data<span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'==='</span><span class="token punctuation">,</span> data<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://pic.lixl.cn/2020/66.png" alt="img"></p><h2 id="七、Electron-Shell-模块"><a href="#七、Electron-Shell-模块" class="headerlink" title="七、Electron Shell 模块"></a>七、Electron Shell 模块</h2><p><img src="https://pic.lixl.cn/2020/67.png" alt="img"></p><h3 id="1-Shell-模块使用"><a href="#1-Shell-模块使用" class="headerlink" title="1 Shell 模块使用"></a>1 Shell 模块使用</h3><blockquote><p>文档 <a href="https://electronjs.org/docs/api/shell" target="_blank" rel="noopener">https://electronjs.org/docs/api/shell</a><br><code>Electron Shell</code> 模块在用户默认浏览器 中打开 <code>URL</code> 以及 <code>Electron DOM webview</code> 标签。<code>Shell</code>既属于主进程模块又是渲染进程模块<br><code>shell</code> 模块提供了集成其他桌面客户端的关联功能</p></blockquote><p><strong>1. 引入</strong></p><pre class="line-numbers language-js"><code class="language-js"><span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span>index<span class="token punctuation">.</span>html<span class="token operator">--</span><span class="token operator">></span><span class="token operator">&lt;</span>button id<span class="token operator">=</span><span class="token string">"shellDom"</span><span class="token operator">></span>通过shell打开外部链接<span class="token operator">&lt;</span><span class="token operator">/</span>button<span class="token operator">></span><span class="token operator">&lt;</span>script src<span class="token operator">=</span><span class="token string">"render/shell.js"</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>2. shell.js</strong></p><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">// src/render/shell.js</span><span class="token keyword">const</span> <span class="token punctuation">{</span> shell <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'electron'</span><span class="token punctuation">)</span><span class="token keyword">let</span> shellDom <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">querySelector</span><span class="token punctuation">(</span><span class="token string">'#shellDom'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>shellDom<span class="token punctuation">.</span>onclick <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>e<span class="token punctuation">)</span> <span class="token punctuation">{</span>   shell<span class="token punctuation">.</span><span class="token function">openExternal</span><span class="token punctuation">(</span><span class="token string">'https://github.com/poetries'</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-Electron-DOM-标签"><a href="#2-Electron-DOM-标签" class="headerlink" title="2 Electron DOM `` 标签"></a>2 <code>Electron DOM</code> `` 标签</h3><blockquote><p><code>Webview</code> 与 <code>iframe</code> 有点相似，但是与 <code>iframe</code> 不同, <code>webview</code> 和你的应用运行的是不同的进程。它不拥有渲染进程的权限，并且应用和嵌入内容之间的交互全部都是异步的。因为这能 保证应用的安全性不受嵌入内容的影响。</p></blockquote><pre class="line-numbers language-js"><code class="language-js"><span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span>src<span class="token operator">/</span>index<span class="token punctuation">.</span>html中引入<span class="token operator">--</span><span class="token operator">></span><span class="token operator">&lt;</span>webview id<span class="token operator">=</span><span class="token string">"webview"</span> src<span class="token operator">=</span><span class="token string">"http://blog.poetries.top"</span> style<span class="token operator">=</span><span class="token string">"position:fixed; width:100%; height:100%"</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>webview<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="3-shell模块-结合Menu模块使用案例"><a href="#3-shell模块-结合Menu模块使用案例" class="headerlink" title="3 shell模块``结合Menu模块使用案例"></a>3 <code>shell</code>模块``结合<code>Menu</code>模块使用案例</h3><p><strong>1. 新建src/render/webview.js</strong></p><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">/* eslint-disable */</span><span class="token keyword">var</span> <span class="token punctuation">{</span> ipcRenderer <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'electron'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">let</span> myWebview <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">querySelector</span><span class="token punctuation">(</span><span class="token string">'#myWebview'</span><span class="token punctuation">)</span>ipcRenderer<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">'openwebview'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>e<span class="token punctuation">,</span> url<span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span>    myWebview<span class="token punctuation">.</span>src <span class="token operator">=</span> url<span class="token punctuation">}</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>2. 引入src/index.html</strong></p><pre class="line-numbers language-js"><code class="language-js"><span class="token operator">&lt;</span>webview id<span class="token operator">=</span><span class="token string">"myWebview"</span> src<span class="token operator">=</span><span class="token string">"http://blog.poetries.top"</span> style<span class="token operator">=</span><span class="token string">"position:fixed; width:100%; height:100%"</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>webview<span class="token operator">></span>   $<span class="token operator">&lt;</span>script src<span class="token operator">=</span><span class="token string">"render/webview.js"</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>3. 新建src/main/menu.js</strong></p><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">/* eslint-disable */</span><span class="token keyword">const</span> <span class="token punctuation">{</span> shell<span class="token punctuation">,</span> Menu<span class="token punctuation">,</span> BrowserWindow <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'electron'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 当前窗口渲染网页</span><span class="token keyword">function</span> <span class="token function">openWebView</span><span class="token punctuation">(</span>url<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 获取当前窗口Id</span>    <span class="token keyword">let</span> win <span class="token operator">=</span> BrowserWindow<span class="token punctuation">.</span><span class="token function">getFocusedWindow</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">// 广播通知渲染进程打开webview</span>    win<span class="token punctuation">.</span>webContents<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span><span class="token string">'openwebview'</span><span class="token punctuation">,</span> url<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 在窗口外打开网页</span><span class="token keyword">function</span> <span class="token function">openWeb</span><span class="token punctuation">(</span>url<span class="token punctuation">)</span> <span class="token punctuation">{</span>    shell<span class="token punctuation">.</span><span class="token function">openExternal</span><span class="token punctuation">(</span>url<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">let</span> template <span class="token operator">=</span> <span class="token punctuation">[</span>    <span class="token punctuation">{</span>        label<span class="token punctuation">:</span> <span class="token string">'帮助'</span><span class="token punctuation">,</span>        submenu<span class="token punctuation">:</span> <span class="token punctuation">[</span>            <span class="token punctuation">{</span>                label<span class="token punctuation">:</span> <span class="token string">'关于我们'</span><span class="token punctuation">,</span>                click<span class="token punctuation">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token function">openWeb</span><span class="token punctuation">(</span><span class="token string">'http://blog.poetries.top'</span><span class="token punctuation">)</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span><span class="token punctuation">,</span>            <span class="token punctuation">{</span>                type<span class="token punctuation">:</span> <span class="token string">'separator'</span>            <span class="token punctuation">}</span><span class="token punctuation">,</span>            <span class="token punctuation">{</span>                label<span class="token punctuation">:</span> <span class="token string">'联系我们'</span><span class="token punctuation">,</span>                click<span class="token punctuation">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token function">openWeb</span><span class="token punctuation">(</span><span class="token string">'https://github.com/poetries'</span><span class="token punctuation">)</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">]</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>   <span class="token punctuation">{</span>        label<span class="token punctuation">:</span> <span class="token string">'加载网页'</span><span class="token punctuation">,</span>        submenu<span class="token punctuation">:</span> <span class="token punctuation">[</span>            <span class="token punctuation">{</span>                label<span class="token punctuation">:</span> <span class="token string">'博客'</span><span class="token punctuation">,</span>                click<span class="token punctuation">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token function">openWebView</span><span class="token punctuation">(</span><span class="token string">'http://blog.poetries.top'</span><span class="token punctuation">)</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span><span class="token punctuation">,</span>            <span class="token punctuation">{</span>                type<span class="token punctuation">:</span> <span class="token string">'separator'</span> <span class="token comment" spellcheck="true">// 分隔符</span>            <span class="token punctuation">}</span><span class="token punctuation">,</span>            <span class="token punctuation">{</span>                label<span class="token punctuation">:</span> <span class="token string">'GitHub'</span><span class="token punctuation">,</span>                click<span class="token punctuation">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token function">openWebView</span><span class="token punctuation">(</span><span class="token string">'https://github.com/poetries'</span><span class="token punctuation">)</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span><span class="token punctuation">,</span>            <span class="token punctuation">{</span>                type<span class="token punctuation">:</span> <span class="token string">'separator'</span> <span class="token comment" spellcheck="true">// 分隔符</span>            <span class="token punctuation">}</span><span class="token punctuation">,</span>            <span class="token punctuation">{</span>                label<span class="token punctuation">:</span> <span class="token string">'简书'</span><span class="token punctuation">,</span>                click<span class="token punctuation">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token function">openWebView</span><span class="token punctuation">(</span><span class="token string">'https://www.jianshu.com/users/94077fcddfc0/timeline'</span><span class="token punctuation">)</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">]</span>   <span class="token punctuation">}</span><span class="token punctuation">,</span>   <span class="token punctuation">{</span>    label<span class="token punctuation">:</span> <span class="token string">'视频网站'</span><span class="token punctuation">,</span>    submenu<span class="token punctuation">:</span> <span class="token punctuation">[</span>        <span class="token punctuation">{</span>            label<span class="token punctuation">:</span> <span class="token string">'优酷'</span><span class="token punctuation">,</span>            click<span class="token punctuation">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token function">openWebView</span><span class="token punctuation">(</span><span class="token string">'https://www.youku.com'</span><span class="token punctuation">)</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span>        <span class="token punctuation">{</span>            type<span class="token punctuation">:</span> <span class="token string">'separator'</span> <span class="token comment" spellcheck="true">// 分隔符</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span>        <span class="token punctuation">{</span>            label<span class="token punctuation">:</span> <span class="token string">'爱奇艺'</span><span class="token punctuation">,</span>            click<span class="token punctuation">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token function">openWebView</span><span class="token punctuation">(</span><span class="token string">'https://www.iqiyi.com/'</span><span class="token punctuation">)</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span>        <span class="token punctuation">{</span>            type<span class="token punctuation">:</span> <span class="token string">'separator'</span> <span class="token comment" spellcheck="true">// 分隔符</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span>        <span class="token punctuation">{</span>            label<span class="token punctuation">:</span> <span class="token string">'腾讯视频'</span><span class="token punctuation">,</span>            click<span class="token punctuation">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token function">openWebView</span><span class="token punctuation">(</span><span class="token string">'https://v.qq.com/'</span><span class="token punctuation">)</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">]</span>    <span class="token punctuation">}</span><span class="token punctuation">]</span><span class="token keyword">let</span> m <span class="token operator">=</span> Menu<span class="token punctuation">.</span><span class="token function">buildFromTemplate</span><span class="token punctuation">(</span>template<span class="token punctuation">)</span>Menu<span class="token punctuation">.</span><span class="token function">setApplicationMenu</span><span class="token punctuation">(</span>m<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>4. 引入menu</strong></p><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">// 在主进程src/index.js中引入</span><span class="token keyword">const</span> createWindow <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// 创建菜单 $</span>  <span class="token comment" spellcheck="true">// 引入菜单模块</span>  <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'./main/menu.js'</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://pic.lixl.cn/2020/68.png" alt="img"></p><h2 id="八、Electron-dialog-弹出框"><a href="#八、Electron-dialog-弹出框" class="headerlink" title="八、Electron dialog 弹出框"></a>八、Electron dialog 弹出框</h2><p><img src="https://pic.lixl.cn/2020/69.png" alt="img"></p><blockquote><p>文档 <a href="https://electronjs.org/docs/api/dialog" target="_blank" rel="noopener">https://electronjs.org/docs/api/dialog</a><br><code>dialog</code>属于主进程中的模块<br><code>dialog</code> 模块提供了 <code>api</code> 来展示原生的系统对话框，例如打开文件框，<code>alert</code> 框， 所以 <code>web</code> 应用可以给用户带来跟系统应用相同的体验</p></blockquote><p><strong>1. 在src/index.html中引入</strong></p><pre class="line-numbers language-js"><code class="language-js"><span class="token operator">&lt;</span>button id<span class="token operator">=</span><span class="token string">"showError"</span><span class="token operator">></span>showError<span class="token operator">&lt;</span><span class="token operator">/</span>button<span class="token operator">></span><span class="token operator">&lt;</span>br <span class="token operator">/</span><span class="token operator">></span><span class="token operator">&lt;</span>button id<span class="token operator">=</span><span class="token string">"showMsg"</span><span class="token operator">></span>showMsg<span class="token operator">&lt;</span><span class="token operator">/</span>button<span class="token operator">></span><span class="token operator">&lt;</span>br <span class="token operator">/</span><span class="token operator">></span><span class="token operator">&lt;</span>button id<span class="token operator">=</span><span class="token string">"showOpenDialog"</span><span class="token operator">></span>showOpenDialog<span class="token operator">&lt;</span><span class="token operator">/</span>button<span class="token operator">></span><span class="token operator">&lt;</span>br <span class="token operator">/</span><span class="token operator">></span><span class="token operator">&lt;</span>button id<span class="token operator">=</span><span class="token string">"saveDialog"</span><span class="token operator">></span>saveDialog<span class="token operator">&lt;</span><span class="token operator">/</span>button<span class="token operator">></span><span class="token operator">&lt;</span>br <span class="token operator">/</span><span class="token operator">></span><span class="token operator">&lt;</span>script src<span class="token operator">=</span><span class="token string">"render/dialog.js"</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>2. 新建render/dialog.js</strong> </p><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">// render/dialog.js</span><span class="token keyword">let</span> showError <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">querySelector</span><span class="token punctuation">(</span><span class="token string">'#showError'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">let</span> showMsg <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">querySelector</span><span class="token punctuation">(</span><span class="token string">'#showMsg'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">let</span> showOpenDialog <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">querySelector</span><span class="token punctuation">(</span><span class="token string">'#showOpenDialog'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">let</span> saveDialog <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">querySelector</span><span class="token punctuation">(</span><span class="token string">'#saveDialog'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">var</span> <span class="token punctuation">{</span>remote<span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'electron'</span><span class="token punctuation">)</span>showError<span class="token punctuation">.</span>onclick <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    remote<span class="token punctuation">.</span>dialog<span class="token punctuation">.</span><span class="token function">showErrorBox</span><span class="token punctuation">(</span><span class="token string">'警告'</span><span class="token punctuation">,</span> <span class="token string">'操作有误'</span><span class="token punctuation">)</span><span class="token punctuation">}</span>showMsg<span class="token punctuation">.</span>onclick <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    remote<span class="token punctuation">.</span>dialog<span class="token punctuation">.</span><span class="token function">showMessageBox</span><span class="token punctuation">(</span><span class="token punctuation">{</span>        type<span class="token punctuation">:</span> <span class="token string">'info'</span><span class="token punctuation">,</span>        title<span class="token punctuation">:</span> <span class="token string">'提示信息'</span><span class="token punctuation">,</span>        message<span class="token punctuation">:</span> <span class="token string">'内容'</span><span class="token punctuation">,</span>        buttons<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">'确定'</span><span class="token punctuation">,</span> <span class="token string">'取消'</span><span class="token punctuation">]</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token keyword">function</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">{</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">}</span>showOpenDialog<span class="token punctuation">.</span>onclick <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    remote<span class="token punctuation">.</span>dialog<span class="token punctuation">.</span><span class="token function">showOpenDialog</span><span class="token punctuation">(</span><span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 打开文件夹</span>        properties<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">'openDirectory'</span><span class="token punctuation">,</span> <span class="token string">'openFile'</span><span class="token punctuation">]</span>        <span class="token comment" spellcheck="true">// 打开文件</span>        <span class="token comment" spellcheck="true">// properties: ['openFile']</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>data<span class="token punctuation">)</span> <span class="token punctuation">{</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">}</span>saveDialog<span class="token punctuation">.</span>onclick <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    remote<span class="token punctuation">.</span>dialog<span class="token punctuation">.</span><span class="token function">showSaveDialog</span><span class="token punctuation">(</span><span class="token punctuation">{</span>        title<span class="token punctuation">:</span> <span class="token string">'Save File'</span><span class="token punctuation">,</span>        defaultPath<span class="token punctuation">:</span> <span class="token string">'/Users/poetry/Downloads/'</span><span class="token punctuation">,</span>        <span class="token comment" spellcheck="true">// filters 指定一个文件类型数组，用于规定用户可见或可选的特定类型范围</span>        filters<span class="token punctuation">:</span> <span class="token punctuation">[</span>            <span class="token punctuation">{</span> name<span class="token punctuation">:</span> <span class="token string">'Images'</span><span class="token punctuation">,</span> extensions<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">'jpg'</span><span class="token punctuation">,</span> <span class="token string">'png'</span><span class="token punctuation">,</span> <span class="token string">'gif'</span><span class="token punctuation">]</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>            <span class="token punctuation">{</span> name<span class="token punctuation">:</span> <span class="token string">'Movies'</span><span class="token punctuation">,</span> extensions<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">'mkv'</span><span class="token punctuation">,</span> <span class="token string">'avi'</span><span class="token punctuation">,</span> <span class="token string">'mp4'</span><span class="token punctuation">]</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>            <span class="token punctuation">{</span> name<span class="token punctuation">:</span> <span class="token string">'Custom File Type'</span><span class="token punctuation">,</span> extensions<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">'as'</span><span class="token punctuation">]</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>            <span class="token punctuation">{</span> name<span class="token punctuation">:</span> <span class="token string">'All Files'</span><span class="token punctuation">,</span> extensions<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">'*'</span><span class="token punctuation">]</span> <span class="token punctuation">}</span>        <span class="token punctuation">]</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>path<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 不是真的保存 ，具体还需nodejs处理</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>path<span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>showError</strong></p><pre class="line-numbers language-js"><code class="language-js">remote<span class="token punctuation">.</span>dialog<span class="token punctuation">.</span><span class="token function">showErrorBox</span><span class="token punctuation">(</span><span class="token string">'警告'</span><span class="token punctuation">,</span> <span class="token string">'操作有误'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://pic.lixl.cn/2020/70.png" alt="img"></p><p><strong>showMessageBox</strong></p><pre class="line-numbers language-js"><code class="language-js">remote<span class="token punctuation">.</span>dialog<span class="token punctuation">.</span><span class="token function">showMessageBox</span><span class="token punctuation">(</span><span class="token punctuation">{</span>    type<span class="token punctuation">:</span> <span class="token string">'info'</span><span class="token punctuation">,</span>    title<span class="token punctuation">:</span> <span class="token string">'提示信息'</span><span class="token punctuation">,</span>    message<span class="token punctuation">:</span> <span class="token string">'内容'</span><span class="token punctuation">,</span>    buttons<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">'确定'</span><span class="token punctuation">,</span> <span class="token string">'取消'</span><span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token keyword">function</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://pic.lixl.cn/2020/71.png" alt="img"></p><p><strong>showOpenDialog</strong></p><pre class="line-numbers language-js"><code class="language-js">remote<span class="token punctuation">.</span>dialog<span class="token punctuation">.</span><span class="token function">showOpenDialog</span><span class="token punctuation">(</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 打开文件夹</span>    properties<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">'openDirectory'</span><span class="token punctuation">,</span> <span class="token string">'openFile'</span><span class="token punctuation">]</span>    <span class="token comment" spellcheck="true">// 打开文件</span>    <span class="token comment" spellcheck="true">// properties: ['openFile']</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>data<span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://pic.lixl.cn/2020/72.png" alt="img"></p><p><strong>showSaveDialog</strong></p><pre class="line-numbers language-js"><code class="language-js">remote<span class="token punctuation">.</span>dialog<span class="token punctuation">.</span><span class="token function">showSaveDialog</span><span class="token punctuation">(</span><span class="token punctuation">{</span>    title<span class="token punctuation">:</span> <span class="token string">'Save File'</span><span class="token punctuation">,</span>    defaultPath<span class="token punctuation">:</span> <span class="token string">'/Users/poetry/Downloads/'</span><span class="token punctuation">,</span>    <span class="token comment" spellcheck="true">// filters 指定一个文件类型数组，用于规定用户可见或可选的特定类型范围</span>    filters<span class="token punctuation">:</span> <span class="token punctuation">[</span>        <span class="token punctuation">{</span> name<span class="token punctuation">:</span> <span class="token string">'Images'</span><span class="token punctuation">,</span> extensions<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">'jpg'</span><span class="token punctuation">,</span> <span class="token string">'png'</span><span class="token punctuation">,</span> <span class="token string">'gif'</span><span class="token punctuation">]</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>        <span class="token punctuation">{</span> name<span class="token punctuation">:</span> <span class="token string">'Movies'</span><span class="token punctuation">,</span> extensions<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">'mkv'</span><span class="token punctuation">,</span> <span class="token string">'avi'</span><span class="token punctuation">,</span> <span class="token string">'mp4'</span><span class="token punctuation">]</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>        <span class="token punctuation">{</span> name<span class="token punctuation">:</span> <span class="token string">'Custom File Type'</span><span class="token punctuation">,</span> extensions<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">'as'</span><span class="token punctuation">]</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>        <span class="token punctuation">{</span> name<span class="token punctuation">:</span> <span class="token string">'All Files'</span><span class="token punctuation">,</span> extensions<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">'*'</span><span class="token punctuation">]</span> <span class="token punctuation">}</span>    <span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>path<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 不是真的保存 ，具体还需nodejs处理</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>path<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://pic.lixl.cn/2020/73.png" alt="img"></p><h2 id="九、实现一个简易记事本代码编辑器"><a href="#九、实现一个简易记事本代码编辑器" class="headerlink" title="九、实现一个简易记事本代码编辑器"></a>九、实现一个简易记事本代码编辑器</h2><blockquote><p>代码 <a href="https://github.com/poetries/electron-demo/tree/master/notepad" target="_blank" rel="noopener">https://github.com/poetries/electron-demo/tree/master/notepad</a></p></blockquote><h2 id="十、系统托盘、托盘右键菜单、托盘图标闪烁"><a href="#十、系统托盘、托盘右键菜单、托盘图标闪烁" class="headerlink" title="十、系统托盘、托盘右键菜单、托盘图标闪烁"></a>十、系统托盘、托盘右键菜单、托盘图标闪烁</h2><p><img src="https://pic.lixl.cn/2020/74.png" alt="img"></p><blockquote><p>文档 <a href="https://electronjs.org/docs/api/tray" target="_blank" rel="noopener">https://electronjs.org/docs/api/tray</a><br>系统托盘，托盘右键菜单、托盘图标闪烁 点击右上角关闭按钮隐藏到托盘(仿杀毒软件)</p></blockquote><p><strong>1. 引入文件</strong></p><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">// src/index.js</span><span class="token keyword">const</span> createWindow <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'./main/tray.js'</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>2. Electron 创建任务栏图标以及任务栏图标右键菜单</strong></p><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">// src/main/tray.js</span><span class="token keyword">var</span> <span class="token punctuation">{</span>    Menu<span class="token punctuation">,</span> Tray<span class="token punctuation">,</span> app<span class="token punctuation">,</span> BrowserWindow<span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'electron'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">const</span> path <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'path'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">var</span> appIcon <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Tray</span><span class="token punctuation">(</span>path<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span>__dirname<span class="token punctuation">,</span> <span class="token string">'../static/lover.png'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">const</span> menu <span class="token operator">=</span> Menu<span class="token punctuation">.</span><span class="token function">buildFromTemplate</span><span class="token punctuation">(</span><span class="token punctuation">[</span>    <span class="token punctuation">{</span>        label<span class="token punctuation">:</span> <span class="token string">'设置'</span><span class="token punctuation">,</span>        click<span class="token punctuation">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token comment" spellcheck="true">//打开相应页面$</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>        label<span class="token punctuation">:</span> <span class="token string">'帮助'</span><span class="token punctuation">,</span>        click<span class="token punctuation">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>        label<span class="token punctuation">:</span> <span class="token string">'关于'</span><span class="token punctuation">,</span>        click<span class="token punctuation">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>        label<span class="token punctuation">:</span> <span class="token string">'退出'</span><span class="token punctuation">,</span>        click<span class="token punctuation">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>$            <span class="token comment" spellcheck="true">// BrowserWindow.getFocusedWindow().webContents().send('close-main-window');</span>            app<span class="token punctuation">.</span><span class="token function">quit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">// 鼠标放上去提示信息</span>appIcon<span class="token punctuation">.</span><span class="token function">setToolTip</span><span class="token punctuation">(</span><span class="token string">'hello poetries'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>appIcon<span class="token punctuation">.</span><span class="token function">setContextMenu</span><span class="token punctuation">(</span>menu<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://pic.lixl.cn/2020/75.png" alt="img"></p><p><strong>3. 监听任务栏图标的单击、双击事件</strong></p><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">// 实现点击关闭按钮，让应用保存在托盘里面，双击托盘打开</span><span class="token keyword">let</span> win <span class="token operator">=</span> BrowserWindow<span class="token punctuation">.</span><span class="token function">getFocusedWindow</span><span class="token punctuation">(</span><span class="token punctuation">)</span>win<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">'close'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span>    e<span class="token punctuation">.</span><span class="token function">preventDefault</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    win<span class="token punctuation">.</span><span class="token function">hide</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span>iconTray<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">'double-click'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span>    win<span class="token punctuation">.</span><span class="token function">show</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>4. Electron 点击右上角关闭按钮隐藏任务栏图标</strong></p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">const</span> win <span class="token operator">=</span> BrowserWindow<span class="token punctuation">.</span><span class="token function">getFocusedWindow</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>win<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">'close'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>e<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>win<span class="token punctuation">.</span><span class="token function">isFocused</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   $    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>win<span class="token punctuation">.</span><span class="token function">isFocused</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        win <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        e<span class="token punctuation">.</span><span class="token function">preventDefault</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">/*阻止应用退出*/</span>        win<span class="token punctuation">.</span><span class="token function">hide</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">/*隐藏当前窗口*/</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>5. Electron 实现任务栏闪烁图标</strong></p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">var</span> appIcon <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Tray</span><span class="token punctuation">(</span>path<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span>__dirname<span class="token punctuation">,</span> <span class="token string">'../static/lover.png'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>timer <span class="token operator">=</span> <span class="token function">setInterval</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    count<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>count <span class="token operator">%</span> <span class="token number">2</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        appIcon<span class="token punctuation">.</span><span class="token function">setImage</span><span class="token punctuation">(</span>path<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span>__dirname<span class="token punctuation">,</span> <span class="token string">'../static/empty.ico'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        appIcon<span class="token punctuation">.</span><span class="token function">setImage</span><span class="token punctuation">(</span>path<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span>__dirname<span class="token punctuation">,</span> <span class="token string">'../static/lover.png'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token number">500</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="十一、消息通知、监听网络变化"><a href="#十一、消息通知、监听网络变化" class="headerlink" title="十一、消息通知、监听网络变化"></a>十一、消息通知、监听网络变化</h2><h3 id="1-消息通知"><a href="#1-消息通知" class="headerlink" title="1 消息通知"></a>1 消息通知</h3><p><strong>1. Electron 实现消息通知</strong></p><blockquote><p><code>Electron</code> 里面的消息通知是基于 <code>h5</code> 的通知 <code>api</code> 实现的<br>文档 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/notification" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/API/notification</a></p></blockquote><p><strong>1. 新建notification.js</strong></p><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">// h5api实现通知</span><span class="token keyword">const</span> path <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'path'</span><span class="token punctuation">)</span><span class="token keyword">let</span> options <span class="token operator">=</span> <span class="token punctuation">{</span>    title<span class="token punctuation">:</span> <span class="token string">'electron 通知API'</span><span class="token punctuation">,</span>    body<span class="token punctuation">:</span> <span class="token string">'hello poetries'</span><span class="token punctuation">,</span>    icon<span class="token punctuation">:</span> path<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token string">'../static/img/favicon2.ico'</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 通知图标</span><span class="token punctuation">}</span>document<span class="token punctuation">.</span><span class="token function">querySelector</span><span class="token punctuation">(</span><span class="token string">'#showNotification'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>onclick <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">let</span> myNotification  <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">window<span class="token punctuation">.</span>Notification</span><span class="token punctuation">(</span>options<span class="token punctuation">.</span>title<span class="token punctuation">,</span> options<span class="token punctuation">)</span>   $    <span class="token comment" spellcheck="true">// 消息可点击</span>    myNotification<span class="token punctuation">.</span>onclick <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'click notification'</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>2. 引入</strong></p><pre class="line-numbers language-js"><code class="language-js"><span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span>src<span class="token operator">/</span>index<span class="token punctuation">.</span>html<span class="token operator">--</span><span class="token operator">></span><span class="token operator">&lt;</span>button id<span class="token operator">=</span><span class="token string">"showNotification"</span><span class="token operator">></span>弹出消息通知<span class="token operator">&lt;</span><span class="token operator">/</span>button<span class="token operator">></span><span class="token operator">&lt;</span>script src<span class="token operator">=</span><span class="token string">"render/notification.js"</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><code>mac</code>上的消息通知</p><p><img src="https://pic.lixl.cn/2020/76.png" alt="img"></p><h3 id="2-监听网络变化"><a href="#2-监听网络变化" class="headerlink" title="2 监听网络变化"></a>2 监听网络变化</h3><p><strong>1. 基本使用</strong></p><pre class="line-numbers language-js"><code class="language-js"> <span class="token comment" spellcheck="true">// 监听网络变化</span><span class="token comment" spellcheck="true">// 端开网络 再次连接测试</span> window<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'online'</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'online'</span><span class="token punctuation">)</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>$$ window<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'offline'</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'offline'</span><span class="token punctuation">)</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>2. 监听网络变化实现消息通知</strong></p><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">// 端开网络 再次连接测试</span><span class="token comment" spellcheck="true">// 监听网络变化实现消息通知</span> window<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'online'</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'online'</span><span class="token punctuation">)</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>$ window<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'offline'</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 断开网络触发事件</span>    <span class="token keyword">var</span> options <span class="token operator">=</span> <span class="token punctuation">{</span>        title<span class="token punctuation">:</span> <span class="token string">'QQ邮箱'</span><span class="token punctuation">,</span>        body<span class="token punctuation">:</span> <span class="token string">'网络异常，请检查你的网络'</span><span class="token punctuation">,</span>        icon<span class="token punctuation">:</span> path<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token string">'../static/img/favicon2.ico'</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 通知图标</span>    <span class="token punctuation">}</span>    <span class="token keyword">var</span> myNotification  <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">window<span class="token punctuation">.</span>Notification</span><span class="token punctuation">(</span>options<span class="token punctuation">.</span>title<span class="token punctuation">,</span> options<span class="token punctuation">)</span>    myNotification<span class="token punctuation">.</span>onclick <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'click notification'</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://pic.lixl.cn/2020/77.png" alt="img"></p><h2 id="十二、注册全局快捷键-剪切板事件-nativeImage-模块"><a href="#十二、注册全局快捷键-剪切板事件-nativeImage-模块" class="headerlink" title="十二、注册全局快捷键/剪切板事件/nativeImage 模块"></a>十二、注册全局快捷键/剪切板事件/nativeImage 模块</h2><blockquote><p><code>Electron</code> 注册全局快捷键 (<code>globalShortcut</code>) 以及 <code>clipboard</code> 剪 切板事件以及 <code>nativeImage</code> 模块(实现类似播放器点击机器码自动复制功 能)</p></blockquote><h3 id="1-注册全局快捷键"><a href="#1-注册全局快捷键" class="headerlink" title="1 注册全局快捷键"></a>1 注册全局快捷键</h3><p><img src="https://pic.lixl.cn/2020/78.png" alt="img"></p><ul><li><a href="https://electronjs.org/docs/tutorial/keyboard-shortcuts" target="_blank" rel="noopener">keyboard-shortcuts文档</a></li><li><a href="https://electronjs.org/docs/api/app" target="_blank" rel="noopener">app模块参考文档</a></li></ul><p><strong>1. 新建src/main/shortCut.js</strong></p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">const</span> <span class="token punctuation">{</span>globalShortcut<span class="token punctuation">,</span> app<span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'electron'</span><span class="token punctuation">)</span>app<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">'ready'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 注册全局快捷键</span>    globalShortcut<span class="token punctuation">.</span><span class="token function">register</span><span class="token punctuation">(</span><span class="token string">'command+e'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">// 检测快捷键是否注册成功 true是注册成功</span>    <span class="token keyword">let</span> isRegister <span class="token operator">=</span> globalShortcut<span class="token punctuation">.</span><span class="token function">isRegistered</span><span class="token punctuation">(</span><span class="token string">'command+e'</span><span class="token punctuation">)</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>isRegister<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">// 退出的时候取消全局快捷键</span>app<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">'will-quit'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span>    globalShortcut<span class="token punctuation">.</span><span class="token function">unregister</span><span class="token punctuation">(</span><span class="token string">'command+e'</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>2. 引入src/index.js</strong></p><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">// 注意在外部引入即可 不用放到app中</span><span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'./main/shortCut.js'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="2-剪切板clipboard、nativeImage-模块"><a href="#2-剪切板clipboard、nativeImage-模块" class="headerlink" title="2 剪切板clipboard、nativeImage 模块"></a>2 剪切板clipboard、nativeImage 模块</h3><p><img src="https://pic.lixl.cn/2020/79.png" alt="img"></p><ul><li><a href="https://electronjs.org/docs/api/clipboard" target="_blank" rel="noopener">剪切板clipboard文档</a></li><li><a href="https://electronjs.org/docs/api/native-image" target="_blank" rel="noopener">nativeImage模块</a></li></ul><p><strong>1. html</strong></p><pre class="line-numbers language-js"><code class="language-js"><span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span>src<span class="token operator">/</span>index<span class="token punctuation">.</span>html<span class="token operator">--</span><span class="token operator">></span><span class="token operator">&lt;</span>div<span class="token operator">></span>  <span class="token operator">&lt;</span>h2<span class="token operator">></span>双击下面信息复制<span class="token operator">&lt;</span><span class="token operator">/</span>h2<span class="token operator">></span>  <span class="token operator">&lt;</span>p id<span class="token operator">=</span><span class="token string">'msg'</span><span class="token operator">></span><span class="token number">123456789</span><span class="token operator">&lt;</span><span class="token operator">/</span>p<span class="token operator">></span>  <span class="token operator">&lt;</span>button id<span class="token operator">=</span><span class="token string">"plat"</span><span class="token operator">></span>粘贴<span class="token operator">&lt;</span><span class="token operator">/</span>button<span class="token operator">></span><span class="token operator">&lt;</span>br <span class="token operator">/</span><span class="token operator">></span>  <span class="token operator">&lt;</span>input id<span class="token operator">=</span><span class="token string">"text"</span> type<span class="token operator">=</span><span class="token string">"text"</span><span class="token operator">/</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span><span class="token punctuation">.</span><span class="token operator">&lt;</span>div<span class="token operator">></span>  <span class="token operator">&lt;</span>h2<span class="token operator">></span>复制图片到界面<span class="token operator">&lt;</span><span class="token operator">/</span>h2<span class="token operator">></span>  <span class="token operator">&lt;</span>button id<span class="token operator">=</span><span class="token string">"copyImg"</span><span class="token operator">></span>复制图片<span class="token operator">&lt;</span><span class="token operator">/</span>button<span class="token operator">></span><span class="token operator">&lt;</span>br <span class="token operator">/</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span><span class="token operator">&lt;</span>script src<span class="token operator">=</span><span class="token string">"render/clipboard.js"</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>2. 新建src/render/clipboard.js</strong></p><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">// clipboard可以在主进程或渲染进程使用</span><span class="token keyword">const</span> <span class="token punctuation">{</span> clipboard<span class="token punctuation">,</span> nativeImage <span class="token punctuation">}</span>  <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'electron'</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//复制</span><span class="token comment" spellcheck="true">// 运行ctrl+v可看到复制的内容</span><span class="token comment" spellcheck="true">// clipboard.writeText('poetries')</span><span class="token comment" spellcheck="true">// clipboard.readText() //获取复制的内容 粘贴</span><span class="token comment" spellcheck="true">// 双击复制消息</span><span class="token keyword">let</span> msg <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">querySelector</span><span class="token punctuation">(</span><span class="token string">'#msg'</span><span class="token punctuation">)</span><span class="token keyword">let</span> plat <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">querySelector</span><span class="token punctuation">(</span><span class="token string">'#plat'</span><span class="token punctuation">)</span><span class="token keyword">let</span> text <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">querySelector</span><span class="token punctuation">(</span><span class="token string">'#text'</span><span class="token punctuation">)</span>msg<span class="token punctuation">.</span>ondblclick  <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    clipboard<span class="token punctuation">.</span><span class="token function">writeText</span><span class="token punctuation">(</span>msg<span class="token punctuation">.</span>innerHTML<span class="token punctuation">)</span>    <span class="token function">alert</span><span class="token punctuation">(</span>msg<span class="token punctuation">.</span>innerHTML<span class="token punctuation">)</span><span class="token punctuation">}</span>plat<span class="token punctuation">.</span>onclick <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    text<span class="token punctuation">.</span>value <span class="token operator">=</span> clipboard<span class="token punctuation">.</span><span class="token function">readText</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 复制图片显示到界面</span><span class="token keyword">let</span> copyImg <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">querySelector</span><span class="token punctuation">(</span><span class="token string">'#copyImg'</span><span class="token punctuation">)</span>copyImg<span class="token punctuation">.</span>onclick <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 结合nativeImage模块</span>    <span class="token keyword">let</span> image <span class="token operator">=</span> nativeImage<span class="token punctuation">.</span><span class="token function">createFromPath</span><span class="token punctuation">(</span><span class="token string">'../static/img/lover.png'</span><span class="token punctuation">)</span>$    <span class="token comment" spellcheck="true">// 复制图片</span>    clipboard<span class="token punctuation">.</span><span class="token function">writeImage</span><span class="token punctuation">(</span>image<span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">// 粘贴图片</span>    <span class="token keyword">let</span> imgSrc <span class="token operator">=</span> clipboard<span class="token punctuation">.</span><span class="token function">readImage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toDataURL</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// base64图片</span>    <span class="token comment" spellcheck="true">// 显示到页面上</span>    <span class="token keyword">let</span> imgDom <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Image</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    imgDom<span class="token punctuation">.</span>src <span class="token operator">=</span> imgSrc$    document<span class="token punctuation">.</span>body<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>imgDom<span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="十三、结合electron-vue"><a href="#十三、结合electron-vue" class="headerlink" title="十三、结合electron-vue"></a>十三、结合electron-vue</h2><h3 id="1-electron-vue-的使用"><a href="#1-electron-vue-的使用" class="headerlink" title="1 electron-vue 的使用"></a>1 electron-vue 的使用</h3><p><strong>1. electron-vue 的一些资源</strong></p><blockquote><p><a href="https://github.com/SimulatedGREG/electron-vue" target="_blank" rel="noopener">https://github.com/SimulatedGREG/electron-vue</a></p></blockquote><p><code>Electron-vue</code> 文档 <a href="https://simulatedgreg.gitbooks.io/electron-vue/content/cn" target="_blank" rel="noopener">https://simulatedgreg.gitbooks.io/electron-vue/content/cn</a></p><p><strong>2. electron-vue 环境搭建、创建项目</strong></p><pre class="line-numbers language-js"><code class="language-js">npm install <span class="token operator">-</span>g vue<span class="token operator">-</span>clivue init simulatedgreg<span class="token operator">/</span>electron<span class="token operator">-</span>vue my<span class="token operator">-</span>projectcd my<span class="token operator">-</span>projectyarn # or npm installyarn run dev # or npm run dev<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>3. electron-vue 目录结构分析</strong></p><p><img src="https://pic.lixl.cn/2020/80.png" alt="img"></p><h3 id="2-electron-vue-中使用-sass-ElementUi"><a href="#2-electron-vue-中使用-sass-ElementUi" class="headerlink" title="2 electron-vue 中使用 sass/ElementUi"></a>2 electron-vue 中使用 sass/ElementUi</h3><p><strong>1. electron-vue UI 框架 ElementUi 的使用</strong></p><blockquote><p><a href="http://element-cn.eleme.io/#/zh-CN" target="_blank" rel="noopener">http://element-cn.eleme.io/#/zh-CN</a></p></blockquote><p><strong>2. electron-vue 中使用 sass</strong></p><ul><li><a href="https://simulatedgreg.gitbooks.io/electron-vue/content/cn/using_pre-processors.html" target="_blank" rel="noopener">electron-vue 中使用 sass</a></li></ul><pre class="line-numbers language-js"><code class="language-js"># 安装 sass<span class="token operator">-</span>loader<span class="token punctuation">:</span>npm install <span class="token operator">--</span>save<span class="token operator">-</span>dev sass<span class="token operator">-</span>loader node<span class="token operator">-</span>sass<span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span>vue 文件中修改 style 为如下代码<span class="token punctuation">:</span><span class="token operator">--</span><span class="token operator">></span><span class="token operator">&lt;</span>style lang<span class="token operator">=</span><span class="token string">"scss"</span><span class="token operator">></span>$    body <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">/* SCSS */</span>$    <span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>style<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-electron-vue-中隐藏顶部菜单隐藏"><a href="#3-electron-vue-中隐藏顶部菜单隐藏" class="headerlink" title="3 electron-vue 中隐藏顶部菜单隐藏"></a>3 electron-vue 中隐藏顶部菜单隐藏</h3><blockquote><p>electron-vue 中隐藏顶部菜单隐藏顶部最大化、最小化、关闭按钮 自定最大化、最小化 、关闭按钮</p></blockquote><p><strong>1. electron-vue 中隐藏顶部菜单</strong></p><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">// src/main/index.js</span>mainWindow<span class="token punctuation">.</span><span class="token function">setMenu</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>2. electron-vue 中隐藏关闭 最大化 最小化按钮</strong></p><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">// src/main/index.js</span>mainWindow <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BrowserWindow</span><span class="token punctuation">(</span><span class="token punctuation">{</span>    height<span class="token punctuation">:</span> <span class="token number">620</span><span class="token punctuation">,</span>    useContentSize<span class="token punctuation">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>    width<span class="token punctuation">:</span> <span class="token number">1280</span><span class="token punctuation">,</span>    frame<span class="token punctuation">:</span> <span class="token boolean">false</span> <span class="token comment" spellcheck="true">/*去掉顶部导航 去掉关闭按钮 最大化最小化按钮*/</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>3 .electron-vue 自定义关闭/最大化最小化按钮</strong></p><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">// 注意在mac下不需要监听窗口最大最小化、以为系统默认支持，这个只是针对windows平台</span>ipc<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">'window-min'</span><span class="token punctuation">,</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    mainWindow<span class="token punctuation">.</span><span class="token function">minimize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//登录窗口最大化$</span>ipc<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">'window-max'</span><span class="token punctuation">,</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>mainWindow<span class="token punctuation">.</span><span class="token function">isMaximized</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        mainWindow<span class="token punctuation">.</span><span class="token function">restore</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        mainWindow<span class="token punctuation">.</span><span class="token function">maximize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span>$ipc<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">'window-close'</span><span class="token punctuation">,</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    mainWindow<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>4. electron-vue 自定义导航可拖拽</strong></p><ul><li>可拖拽的 <code>css</code>: <code>-webkit-app-region: drag;</code></li><li>不可拖拽的 <code>css</code>: <code>-webkit-app-region: no-drag;</code></li></ul><h3 id="4-使用electron-vue开发舆情监控系统"><a href="#4-使用electron-vue开发舆情监控系统" class="headerlink" title="4 使用electron-vue开发舆情监控系统"></a>4 使用electron-vue开发舆情监控系统</h3><h4 id="4-1-配置开发环境"><a href="#4-1-配置开发环境" class="headerlink" title="4.1 配置开发环境"></a>4.1 配置开发环境</h4><p><strong>1. 项目搭建</strong></p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">npm</span> <span class="token function">install</span> -g vue-clivue init simulatedgreg/electron-vue my-project<span class="token function">cd</span> my-projectyarn <span class="token comment" spellcheck="true"># or npm install</span>yarn run dev <span class="token comment" spellcheck="true"># or npm run dev</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>2. 安装一些依赖</strong></p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 安装 sass-loader:</span><span class="token function">npm</span> <span class="token function">install</span> --save-dev sass-loader node-sass<span class="token comment" spellcheck="true"># 安装elementUI、js-md5</span><span class="token function">npm</span> i element-ui  js-md5 -S<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>在<code>.electron-vue/webpack.renderer.config.js</code>中配置<code>sass-loader</code>就可以编写``sass`了</li></ul><pre class="line-numbers language-css"><code class="language-css"><span class="token selector">&lt;!--vue 文件中修改 style 为如下代码<span class="token pseudo-class">:--</span>>&lt;style lang="scss">$    body </span><span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">/* SCSS */</span>$    <span class="token punctuation">}</span>&lt;/style><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="4-2-主进程配置"><a href="#4-2-主进程配置" class="headerlink" title="4.2 主进程配置"></a>4.2 主进程配置</h4><p><strong>1. <code>src/main/index.js</code></strong></p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">function</span> createWindow <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// 去掉顶部菜单</span>  mainWindow<span class="token punctuation">.</span><span class="token function">setMenu</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span> $  <span class="token comment" spellcheck="true">// 菜单项</span>  <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'./model/menu.js'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> $  <span class="token comment" spellcheck="true">// 系统托盘相关</span>  <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'./model/tray.js'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>2. <code>src/main/menu.js</code>菜单配置</strong></p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">const</span> <span class="token punctuation">{</span> Menu<span class="token punctuation">,</span>ipcMain<span class="token punctuation">,</span>BrowserWindow<span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'electron'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//右键菜单</span><span class="token keyword">const</span> contextMenuTemplate<span class="token operator">=</span><span class="token punctuation">[</span>    <span class="token punctuation">{</span>        label<span class="token punctuation">:</span> <span class="token string">'复制'</span><span class="token punctuation">,</span> role<span class="token punctuation">:</span> <span class="token string">'copy'</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>        label<span class="token punctuation">:</span> <span class="token string">'黏贴'</span><span class="token punctuation">,</span> role<span class="token punctuation">:</span> <span class="token string">'paste'</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>       $    <span class="token punctuation">{</span> type<span class="token punctuation">:</span> <span class="token string">'separator'</span> <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">//分隔线</span>    <span class="token punctuation">{</span>        label<span class="token punctuation">:</span> <span class="token string">'其他功能'</span><span class="token punctuation">,</span>    $        click<span class="token punctuation">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'click'</span><span class="token punctuation">)</span>         <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">const</span> contextMenu<span class="token operator">=</span>Menu<span class="token punctuation">.</span><span class="token function">buildFromTemplate</span><span class="token punctuation">(</span>contextMenuTemplate<span class="token punctuation">)</span><span class="token punctuation">;</span>ipcMain<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">'contextmenu'</span><span class="token punctuation">,</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    contextMenu<span class="token punctuation">.</span><span class="token function">popup</span><span class="token punctuation">(</span>BrowserWindow<span class="token punctuation">.</span><span class="token function">getFocusedWindow</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>3. <code>src/main/tray.js</code>系统托盘配置</strong></p><blockquote><p>托盘点击监听事件只有在<code>windows</code>下才生效，<code>mac</code>系统默认支持</p></blockquote><pre class="line-numbers language-js"><code class="language-js"><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">const</span> path<span class="token operator">=</span><span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'path'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">const</span> <span class="token punctuation">{</span>app<span class="token punctuation">,</span>Menu<span class="token punctuation">,</span>BrowserWindow<span class="token punctuation">,</span>Tray<span class="token punctuation">,</span> shell<span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'electron'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//创建系统托盘</span>    <span class="token keyword">const</span> tray <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Tray</span><span class="token punctuation">(</span>path<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span>__static<span class="token punctuation">,</span> <span class="token string">'favicon.png'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">//给托盘增加右键菜单</span>    <span class="token keyword">const</span> template<span class="token operator">=</span> <span class="token punctuation">[</span>        <span class="token punctuation">{</span>            label<span class="token punctuation">:</span> <span class="token string">'设置'</span><span class="token punctuation">,</span>            click<span class="token punctuation">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                shell<span class="token punctuation">.</span><span class="token function">openExternal</span><span class="token punctuation">(</span><span class="token string">'http://blog.poetries.top'</span><span class="token punctuation">)</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span>        <span class="token punctuation">{</span>            label<span class="token punctuation">:</span> <span class="token string">'帮助'</span><span class="token punctuation">,</span>            click<span class="token punctuation">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                shell<span class="token punctuation">.</span><span class="token function">openExternal</span><span class="token punctuation">(</span><span class="token string">'http://blog.poetries.top/2019/01/06/electron-summary'</span><span class="token punctuation">)</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span>        <span class="token punctuation">{</span>            label<span class="token punctuation">:</span> <span class="token string">'关于'</span><span class="token punctuation">,</span>            click<span class="token punctuation">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                shell<span class="token punctuation">.</span><span class="token function">openExternal</span><span class="token punctuation">(</span><span class="token string">'https://github.com/poetries/yuqing-monitor-electron'</span><span class="token punctuation">)</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span>        <span class="token punctuation">{</span>            label<span class="token punctuation">:</span> <span class="token string">'退出'</span><span class="token punctuation">,</span>            click<span class="token punctuation">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// BrowserWindow.getFocusedWindow().webContents().send('close-main-window');</span>                app<span class="token punctuation">.</span><span class="token function">quit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>           $            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">const</span> menu <span class="token operator">=</span> Menu<span class="token punctuation">.</span><span class="token function">buildFromTemplate</span><span class="token punctuation">(</span>template<span class="token punctuation">)</span><span class="token punctuation">;</span>    tray<span class="token punctuation">.</span><span class="token function">setContextMenu</span><span class="token punctuation">(</span>menu<span class="token punctuation">)</span><span class="token punctuation">;</span>    tray<span class="token punctuation">.</span><span class="token function">setToolTip</span><span class="token punctuation">(</span><span class="token string">'舆情监控系统'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//监听关闭事件隐藏到系统托盘</span>    <span class="token comment" spellcheck="true">// 这里需要注意：在window中才生效，mac下系统默认支持</span>    <span class="token comment" spellcheck="true">// var win = BrowserWindow.getFocusedWindow();</span>    <span class="token comment" spellcheck="true">// win.on('close',(e)=>{</span>    <span class="token comment" spellcheck="true">//         if(!win.isFocused()){</span>    <span class="token comment" spellcheck="true">//             win=null;</span>    <span class="token comment" spellcheck="true">//         }else{</span>    <span class="token comment" spellcheck="true">//             e.preventDefault();  </span><span class="token comment" spellcheck="true">/*阻止应用退出*/</span>    <span class="token comment" spellcheck="true">//             win.hide(); </span><span class="token comment" spellcheck="true">/*隐藏当前窗口*/</span>    <span class="token comment" spellcheck="true">//         }      $</span>    <span class="token comment" spellcheck="true">// })</span>    <span class="token comment" spellcheck="true">// //监听托盘的双击事件</span>    <span class="token comment" spellcheck="true">// tray.on('double-click',()=>{              $</span>    <span class="token comment" spellcheck="true">//     win.show();</span>    <span class="token comment" spellcheck="true">// })</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>4. <code>src/main/shortCut.js</code>快捷键配置</strong></p><p>在<code>src/main/index.js</code>中引入（<code>require(&#39;src/main/shortCut.js&#39;)</code>）即可，不需要放到<code>app</code>监控中</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">var</span> <span class="token punctuation">{</span>globalShortcut<span class="token punctuation">,</span> app<span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'electron'</span><span class="token punctuation">)</span>app<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">'ready'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 注册全局快捷键</span>    globalShortcut<span class="token punctuation">.</span><span class="token function">register</span><span class="token punctuation">(</span><span class="token string">'command+e'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">// 检测快捷键是否注册成功 true是注册成功</span>    <span class="token keyword">let</span> isRegister <span class="token operator">=</span> globalShortcut<span class="token punctuation">.</span><span class="token function">isRegistered</span><span class="token punctuation">(</span><span class="token string">'command+e'</span><span class="token punctuation">)</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>isRegister<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">// 退出的时候取消全局快捷键</span>app<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">'will-quit'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span>    globalShortcut<span class="token punctuation">.</span><span class="token function">unregister</span><span class="token punctuation">(</span><span class="token string">'command+e'</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="4-3-渲染进程配置"><a href="#4-3-渲染进程配置" class="headerlink" title="4.3 渲染进程配置"></a>4.3 渲染进程配置</h4><p><strong>1. src/render/main.js配置</strong></p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">import</span> Vue <span class="token keyword">from</span> <span class="token string">'vue'</span><span class="token keyword">import</span> axios <span class="token keyword">from</span> <span class="token string">'axios'</span><span class="token keyword">import</span> App <span class="token keyword">from</span> <span class="token string">'./App'</span><span class="token keyword">import</span> router <span class="token keyword">from</span> <span class="token string">'./router'</span><span class="token keyword">import</span> store <span class="token keyword">from</span> <span class="token string">'./store'</span><span class="token keyword">import</span> ElementUI <span class="token keyword">from</span> <span class="token string">'element-ui'</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token string">'element-ui/lib/theme-chalk/index.css'</span><span class="token punctuation">;</span><span class="token keyword">import</span> VueHighcharts <span class="token keyword">from</span> <span class="token string">'vue-highcharts'</span><span class="token punctuation">;</span><span class="token keyword">import</span> VueSocketIO <span class="token keyword">from</span> <span class="token string">'vue-socket.io'</span>Vue<span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span>ElementUI<span class="token punctuation">)</span><span class="token punctuation">;</span>Vue<span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span>VueHighcharts<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//引入socket.io配置连接</span>Vue<span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">VueSocketIO</span><span class="token punctuation">(</span><span class="token punctuation">{</span>  debug<span class="token punctuation">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>  connection<span class="token punctuation">:</span> <span class="token string">'http://118.123.14.36:3000'</span><span class="token punctuation">,</span>  vuex<span class="token punctuation">:</span> <span class="token punctuation">{</span>      store<span class="token punctuation">,</span>      actionPrefix<span class="token punctuation">:</span> <span class="token string">'SOCKET_'</span><span class="token punctuation">,</span>      mutationPrefix<span class="token punctuation">:</span> <span class="token string">'SOCKET_'</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>process<span class="token punctuation">.</span>env<span class="token punctuation">.</span>IS_WEB<span class="token punctuation">)</span> Vue<span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span><span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'vue-electron'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>Vue<span class="token punctuation">.</span>http <span class="token operator">=</span> Vue<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>$http <span class="token operator">=</span> axiosVue<span class="token punctuation">.</span>config<span class="token punctuation">.</span>productionTip <span class="token operator">=</span> <span class="token boolean">false</span><span class="token comment" spellcheck="true">/* eslint-disable no-new */</span><span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>  components<span class="token punctuation">:</span> <span class="token punctuation">{</span> App <span class="token punctuation">}</span><span class="token punctuation">,</span>  router<span class="token punctuation">,</span>  store<span class="token punctuation">,</span>  template<span class="token punctuation">:</span> <span class="token string">'&lt;App/>'</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">$mount</span><span class="token punctuation">(</span><span class="token string">'#app'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>2. 路由配置src/renderer/router/index.js</strong></p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">import</span> Vue <span class="token keyword">from</span> <span class="token string">'vue'</span><span class="token keyword">import</span> Router <span class="token keyword">from</span> <span class="token string">'vue-router'</span>Vue<span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span>Router<span class="token punctuation">)</span><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token keyword">new</span> <span class="token class-name">Router</span><span class="token punctuation">(</span><span class="token punctuation">{</span>  routes<span class="token punctuation">:</span> <span class="token punctuation">[</span>    <span class="token punctuation">{</span>      path<span class="token punctuation">:</span> <span class="token string">'/home'</span><span class="token punctuation">,</span>      name<span class="token punctuation">:</span> <span class="token string">'home'</span><span class="token punctuation">,</span>      component<span class="token punctuation">:</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'@/components/Home'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token keyword">default</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>      path<span class="token punctuation">:</span> <span class="token string">'/report'</span><span class="token punctuation">,</span>      name<span class="token punctuation">:</span> <span class="token string">'report'</span><span class="token punctuation">,</span>      component<span class="token punctuation">:</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'@/components/Report'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token keyword">default</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>      path<span class="token punctuation">:</span> <span class="token string">'/negativereport'</span><span class="token punctuation">,</span>      name<span class="token punctuation">:</span> <span class="token string">'negativereport'</span><span class="token punctuation">,</span>      component<span class="token punctuation">:</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'@/components/NegativeReport'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token keyword">default</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>      path<span class="token punctuation">:</span> <span class="token string">'/positivereport'</span><span class="token punctuation">,</span>      name<span class="token punctuation">:</span> <span class="token string">'positivereport'</span><span class="token punctuation">,</span>      component<span class="token punctuation">:</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'@/components/PositiveReport'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token keyword">default</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>      path<span class="token punctuation">:</span> <span class="token string">'/keyword'</span><span class="token punctuation">,</span>      name<span class="token punctuation">:</span> <span class="token string">'keyword'</span><span class="token punctuation">,</span>      component<span class="token punctuation">:</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'@/components/KeyWord'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token keyword">default</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>      path<span class="token punctuation">:</span> <span class="token string">'/alarm'</span><span class="token punctuation">,</span>      name<span class="token punctuation">:</span> <span class="token string">'alarm'</span><span class="token punctuation">,</span>      component<span class="token punctuation">:</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'@/components/Alarm'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token keyword">default</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>      path<span class="token punctuation">:</span> <span class="token string">'/msg'</span><span class="token punctuation">,</span>      name<span class="token punctuation">:</span> <span class="token string">'msg'</span><span class="token punctuation">,</span>      component<span class="token punctuation">:</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'@/components/Msg'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token keyword">default</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>      path<span class="token punctuation">:</span> <span class="token string">'*'</span><span class="token punctuation">,</span>      redirect<span class="token punctuation">:</span> <span class="token string">'/home'</span>    <span class="token punctuation">}</span>  <span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><a href="https://github.com/poetries/yuqing-monitor-electron/tree/master/src/renderer" target="_blank" rel="noopener">其他页面更多详情Github</a></p></blockquote><p><strong>3. 在渲染进程中使用主进程方式</strong></p><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">// electron挂载到了vue实例上 $electron</span><span class="token keyword">this</span><span class="token punctuation">.</span>$electron<span class="token punctuation">.</span>shell<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="4-4-多平台打包"><a href="#4-4-多平台打包" class="headerlink" title="4.4 多平台打包"></a>4.4 多平台打包</h4><blockquote><p>需要注意的是打包<code>mac</code>版本在<code>mac</code>系统上打包，打包<code>window</code>则在<code>windows</code>上打包，可以避免很多问题</p></blockquote><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 在不同平台上执行即可打包应用</span><span class="token function">npm</span> run build<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h5 id="4-4-1-打包介绍"><a href="#4-4-1-打包介绍" class="headerlink" title="4.4.1 打包介绍"></a>4.4.1 打包介绍</h5><blockquote><p><a href="https://simulatedgreg.gitbooks.io/electron-vue/content/cn/using-electron-packager.html" target="_blank" rel="noopener">electron-vue打包文档</a></p></blockquote><p><strong>1. electron 中构建应用最常用的模块</strong></p><ul><li><code>electron-packager</code></li><li><code>electron-builder</code></li></ul><blockquote><p><code>electron-packager</code> 和 <code>electron-builder</code>在自己单独创建的应用用也可以完成打包功 能。但是由于配置太复杂所以我们不建议单独配置</p></blockquote><p><strong>2. electron-forge</strong></p><blockquote><p><a href="https://github.com/electron-userland/electron-forge" target="_blank" rel="noopener">https://github.com/electron-userland/electron-forge</a></p></blockquote><pre class="line-numbers language-bash"><code class="language-bash">electron-forge package$electron-forge <span class="token function">make</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>3. electron-vue中的打包方式</strong></p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># https://simulatedgreg.gitbooks.io/electron-vue/content/cn/using-electron-packager. html</span><span class="token comment" spellcheck="true"># 之需要执行一条命令</span><span class="token function">npm</span> run build<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h5 id="4-4-2-修改应用信息"><a href="#4-4-2-修改应用信息" class="headerlink" title="4.4.2 修改应用信息"></a>4.4.2 修改应用信息</h5><p><strong>1. 修改package.json</strong></p><p><img src="https://pic.lixl.cn/2020/81.png" alt="img"></p><p><strong>2. 修改src/index.ejs标题信息</strong></p><p><strong>3. 修改build/icons图标</strong></p><h5 id="4-4-3-打包遇到的问题"><a href="#4-4-3-打包遇到的问题" class="headerlink" title="4.4.3 打包遇到的问题"></a>4.4.3 打包遇到的问题</h5><p><strong>1. 创建应用托盘的时候可能会遇到错误</strong></p><ul><li>把托盘图片放在根目录<code>static</code>里面，然后注意下面写法。</li></ul><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">var</span> tray <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Tray</span><span class="token punctuation">(</span>path<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span>__static<span class="token punctuation">,</span><span class="token string">'favicon.ico'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>如果托盘路径没有问题，还是包托盘相关错误的话，把托盘对应的图片换成<code>.png</code> 格式重试</li></ul><p><strong>2. 模块问题可能会遇到的错误</strong></p><p><img src="https://pic.lixl.cn/2020/82.png" alt="img"></p><p><img src="https://pic.lixl.cn/2020/83.png" alt="img"></p><p><strong>解决办法</strong></p><ul><li>删掉 <code>node_modules</code> 然后重新用 <code>npm install</code> 安装依赖</li><li>用 <code>yarn</code> 来安装模块</li><li>用手机创建一个热点电脑连上热点重试</li></ul><blockquote><p>最后执行<code>yarn run build</code>即可</p></blockquote><p><img src="https://pic.lixl.cn/2020/84.png" alt="img"></p><blockquote><p>项目源码 <a href="https://github.com/poetries/yuqing-monitor-electron" target="_blank" rel="noopener">https://github.com/poetries/yuqing-monitor-electron</a></p></blockquote><h2 id="十四、更多参考"><a href="#十四、更多参考" class="headerlink" title="十四、更多参考"></a>十四、更多参考</h2><ul><li><a href="https://www.electronjs.org/docs" target="_blank" rel="noopener">electron官方文档</a></li><li><a href="http://blog.poetries.top/2019/01/06/electron-summary/" target="_blank" rel="noopener">Electron构建跨平台应用mac/windows/linux</a></li><li><a href="https://github.com/poetries/electron-wiki" target="_blank" rel="noopener">electron学习资料整理</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 后端技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Node.js </tag>
            
            <tag> Electron </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>idea常用快捷键Mac版</title>
      <link href="/2020/020459974.html"/>
      <url>/2020/020459974.html</url>
      
        <content type="html"><![CDATA[<h2 id="Mac键盘符号和修饰键说明"><a href="#Mac键盘符号和修饰键说明" class="headerlink" title="Mac键盘符号和修饰键说明"></a>Mac键盘符号和修饰键说明</h2><ul><li><code>⌘</code> Command</li><li><code>⇧</code> Shift</li><li><code>⌥</code> Option</li><li><code>⌃</code> Control</li><li><code>↩︎</code> Return/Enter</li><li><code>⌫</code> Delete</li><li><code>⌦</code> 向前删除键（Fn+Delete）</li><li><code>↑</code> 上箭头</li><li><code>↓</code> 下箭头</li><li><code>←</code> 左箭头</li><li><code>→</code> 右箭头</li><li><code>⇞</code> Page Up（Fn+↑）</li><li><code>⇟</code> Page Down（Fn+↓）</li><li><code>Home</code> Fn + ←</li><li><code>End</code> Fn + →</li><li><code>⇥</code> 右制表符（Tab键）</li><li><code>⇤</code> 左制表符（Shift+Tab）</li><li><code>⎋</code> Escape (Esc)</li></ul><h2 id="Ctrl-类"><a href="#Ctrl-类" class="headerlink" title="Ctrl 类"></a>Ctrl 类</h2><table><thead><tr><th><strong>快捷键</strong></th><th><strong>介绍</strong></th></tr></thead><tbody><tr><td><strong>Ctrl + F</strong></td><td><strong>在当前文件进行文本查找 <code>（必备）</code></strong></td></tr><tr><td><strong>Ctrl + R</strong></td><td><strong>在当前文件进行文本替换 <code>（必备）</code></strong></td></tr><tr><td><strong>Ctrl + Z</strong></td><td><strong>撤销 （必备）</strong></td></tr><tr><td><strong>Ctrl + Y</strong></td><td><strong>删除光标所在行 或 删除选中的行 （必备）</strong></td></tr><tr><td><strong>Ctrl + X</strong></td><td><strong>剪切光标所在行 或 剪切选择内容</strong></td></tr><tr><td><strong>Ctrl + C</strong></td><td><strong>复制光标所在行 或 复制选择内容</strong></td></tr><tr><td><strong>Ctrl + D</strong></td><td><strong>复制光标所在行 或 复制选择内容，并把复制内容插入光标位置下面 <code>（必备）</code></strong></td></tr><tr><td>Ctrl + W</td><td>递进式选择代码块。可选中光标所在的单词或段落，连续按会在原有选中的基础上再扩展选中范围</td></tr><tr><td><strong>Ctrl + E</strong></td><td><strong>显示最近打开的文件记录列表</strong></td></tr><tr><td><strong>Ctrl + N</strong></td><td><strong>根据输入的 类名 查找类文件</strong></td></tr><tr><td>Ctrl + G</td><td>在当前文件跳转到指定行处</td></tr><tr><td>Ctrl + J</td><td>插入自定义动态代码模板</td></tr><tr><td>Ctrl + P</td><td>方法参数提示显示</td></tr><tr><td>Ctrl + Q</td><td>光标所在的变量 / 类名 / 方法名等上面（也可以在提示补充的时候按），显示文档内容</td></tr><tr><td>Ctrl + U</td><td>前往当前光标所在的方法的父类的方法 / 接口定义</td></tr><tr><td>Ctrl + B</td><td>进入光标所在的方法 / 变量的接口或是定义出，等效于 <code>Ctrl + 左键单击</code></td></tr><tr><td>Ctrl + K</td><td>版本控制提交项目，需要此项目有加入到版本控制才可用</td></tr><tr><td>Ctrl + T</td><td>版本控制更新项目，需要此项目有加入到版本控制才可用</td></tr><tr><td>Ctrl + H</td><td>显示当前类的层次结构</td></tr><tr><td>Ctrl + O</td><td>选择可重写的方法</td></tr><tr><td>Ctrl + I</td><td>选择可继承的方法</td></tr><tr><td>Ctrl + +</td><td>展开代码</td></tr><tr><td>Ctrl + -</td><td>折叠代码</td></tr><tr><td>Ctrl + /</td><td>注释光标所在行代码，会根据当前不同文件类型使用不同的注释符号 <code>（必备）</code></td></tr><tr><td>Ctrl + [</td><td>移动光标到当前所在代码的花括号开始位置</td></tr><tr><td>Ctrl + ]</td><td>移动光标到当前所在代码的花括号结束位置</td></tr><tr><td>Ctrl + F1</td><td>在光标所在的错误代码出显示错误信息</td></tr><tr><td>Ctrl + F3</td><td>调转到所选中的词的下一个引用位置</td></tr><tr><td>Ctrl + F4</td><td>关闭当前编辑文件</td></tr><tr><td>Ctrl + F8</td><td>在 Debug 模式下，设置光标当前行为断点，如果当前已经是断点则去掉断点</td></tr><tr><td>Ctrl + F9</td><td>执行 Make Project 操作</td></tr><tr><td>Ctrl + F11</td><td>选中文件 / 文件夹，使用助记符设定 / 取消书签</td></tr><tr><td><strong>Ctrl + F12</strong></td><td><strong>弹出当前文件结构层，可以在弹出的层上直接输入，进行筛选</strong></td></tr><tr><td>Ctrl + Tab</td><td>编辑窗口切换，如果在切换的过程又加按上 delete，则是关闭对应选中的窗口</td></tr><tr><td><strong>Ctrl + Enter</strong></td><td><strong>智能分隔行</strong></td></tr><tr><td><strong>Ctrl + End</strong></td><td><strong>跳到文件尾</strong></td></tr><tr><td><strong>Ctrl + Home</strong></td><td><strong>跳到文件头</strong></td></tr><tr><td>Ctrl + Space</td><td>基础代码补全，默认在 Windows 系统上被输入法占用，需要进行修改，建议修改为 <code>Ctrl + 逗号``（必备）</code></td></tr><tr><td>Ctrl + Delete</td><td>删除光标后面的单词或是中文句</td></tr><tr><td>Ctrl + BackSpace</td><td>删除光标前面的单词或是中文句</td></tr><tr><td>Ctrl + 1,2,3…9</td><td>定位到对应数值的书签位置</td></tr><tr><td><strong>Ctrl + 左键单击</strong></td><td><strong>在打开的文件标题上，弹出该文件路径</strong></td></tr><tr><td><strong>Ctrl + 光标定位</strong></td><td><strong>按 Ctrl 不要松开，会显示光标所在的类信息摘要</strong></td></tr><tr><td>Ctrl + 左方向键</td><td>光标跳转到当前单词 / 中文句的左侧开头位置</td></tr><tr><td>Ctrl + 右方向键</td><td>光标跳转到当前单词 / 中文句的右侧开头位置</td></tr><tr><td>Ctrl + 前方向键</td><td>等效于鼠标滚轮向前效果</td></tr><tr><td>Ctrl + 后方向键</td><td>等效于鼠标滚轮向后效果</td></tr></tbody></table><h2 id="Alt"><a href="#Alt" class="headerlink" title="Alt"></a>Alt</h2><table><thead><tr><th>快捷键</th><th>介绍</th></tr></thead><tbody><tr><td>Alt + `</td><td>显示版本控制常用操作菜单弹出层</td></tr><tr><td>Alt + Q</td><td>弹出一个提示，显示当前类的声明 / 上下文信息</td></tr><tr><td>Alt + F1</td><td>显示当前文件选择目标弹出层，弹出层中有很多目标可以进行选择</td></tr><tr><td>Alt + F2</td><td>对于前面页面，显示各类浏览器打开目标选择弹出层</td></tr><tr><td>Alt + F3</td><td>选中文本，逐个往下查找相同文本，并高亮显示</td></tr><tr><td>Alt + F7</td><td>查找光标所在的方法 / 变量 / 类被调用的地方</td></tr><tr><td>Alt + F8</td><td>在 Debug 的状态下，选中对象，弹出可输入计算表达式调试框，查看该输入内容的调试结果</td></tr><tr><td>Alt + Home</td><td>定位 / 显示到当前文件的 <code>Navigation Bar</code></td></tr><tr><td><strong>Alt + Enter</strong></td><td><strong>IntelliJ IDEA 根据光标所在问题，提供快速修复选择，光标放在的位置不同提示的结果也不同 <code>（必备）</code></strong></td></tr><tr><td><strong>Alt + Insert</strong></td><td><strong>代码自动生成，如生成对象的 set / get 方法，构造函数，toString() 等</strong></td></tr><tr><td><strong>Alt + 左方向键</strong></td><td><strong>按左方向切换当前已打开的文件视图</strong></td></tr><tr><td><strong>Alt + 右方向键</strong></td><td><strong>按右方向切换当前已打开的文件视图</strong></td></tr><tr><td>Alt + 前方向键</td><td>当前光标跳转到当前文件的前一个方法名位置</td></tr><tr><td>Alt + 后方向键</td><td>当前光标跳转到当前文件的后一个方法名位置</td></tr><tr><td>Alt + 1,2,3…9</td><td>显示对应数值的选项卡，其中 1 是 Project 用得最多</td></tr></tbody></table><h2 id="Shift"><a href="#Shift" class="headerlink" title="Shift"></a>Shift</h2><table><thead><tr><th>快捷键</th><th>介绍</th></tr></thead><tbody><tr><td>Shift + F1</td><td>如果有外部文档可以连接外部文档</td></tr><tr><td>Shift + F2</td><td>跳转到上一个高亮错误 或 警告位置</td></tr><tr><td>Shift + F3</td><td>在查找模式下，查找匹配上一个</td></tr><tr><td>Shift + F4</td><td>对当前打开的文件，使用新 Windows 窗口打开，旧窗口保留</td></tr><tr><td>Shift + F6</td><td>对文件 / 文件夹 重命名</td></tr><tr><td>Shift + F7</td><td>在 Debug 模式下，智能步入。断点所在行上有多个方法调用，会弹出进入哪个方法</td></tr><tr><td>Shift + F8</td><td>在 Debug 模式下，跳出，表现出来的效果跟 <code>F9</code> 一样</td></tr><tr><td>Shift + F9</td><td>等效于点击工具栏的 <code>Debug</code> 按钮</td></tr><tr><td>Shift + F10</td><td>等效于点击工具栏的 <code>Run</code> 按钮</td></tr><tr><td>Shift + F11</td><td>弹出书签显示层</td></tr><tr><td>Shift + Tab</td><td>取消缩进</td></tr><tr><td>Shift + ESC</td><td>隐藏当前 或 最后一个激活的工具窗口</td></tr><tr><td><strong>Shift + End</strong></td><td><strong>选中光标到当前行尾位置</strong></td></tr><tr><td><strong>Shift + Home</strong></td><td><strong>选中光标到当前行头位置</strong></td></tr><tr><td><strong>Shift + Enter</strong></td><td><strong>开始新一行。光标所在行下空出一行，光标定位到新行位置</strong></td></tr><tr><td><strong>Shift + 左键单击</strong></td><td><strong>在打开的文件名上按此快捷键，可以关闭当前打开文件</strong></td></tr><tr><td><strong>Shift + 滚轮前后滚动</strong></td><td><strong>当前文件的横向滚动轴滚动</strong></td></tr></tbody></table><h2 id="Ctrl-Alt"><a href="#Ctrl-Alt" class="headerlink" title="Ctrl + Alt"></a>Ctrl + Alt</h2><table><thead><tr><th>快捷键</th><th>介绍</th></tr></thead><tbody><tr><td><strong>Ctrl + Alt + L</strong></td><td><strong>格式化代码，可以对当前文件和整个包目录使用 <code>（必备）</code></strong></td></tr><tr><td><strong>Ctrl + Alt + O</strong></td><td><strong>优化导入的类，可以对当前文件和整个包目录使用 <code>（必备）</code></strong></td></tr><tr><td>Ctrl + Alt + I</td><td>光标所在行 或 选中部分进行自动代码缩进，有点类似格式化</td></tr><tr><td>Ctrl + Alt + T</td><td>对选中的代码弹出环绕选项弹出层</td></tr><tr><td>Ctrl + Alt + J</td><td>弹出模板选择窗口，讲选定的代码加入动态模板中</td></tr><tr><td>Ctrl + Alt + H</td><td>调用层次</td></tr><tr><td>Ctrl + Alt + B</td><td>在某个调用的方法名上使用会跳到具体的实现处，可以跳过接口</td></tr><tr><td>Ctrl + Alt + V</td><td>快速引进变量</td></tr><tr><td>Ctrl + Alt + Y</td><td>同步、刷新</td></tr><tr><td>Ctrl + Alt + S</td><td>打开 IntelliJ IDEA 系统设置</td></tr><tr><td>Ctrl + Alt + F7</td><td>显示使用的地方。寻找被该类或是变量被调用的地方，用弹出框的方式找出来</td></tr><tr><td>Ctrl + Alt + F11</td><td>切换全屏模式</td></tr><tr><td>Ctrl + Alt + Enter</td><td>光标所在行上空出一行，光标定位到新行</td></tr><tr><td>Ctrl + Alt + Home</td><td>弹出跟当前文件有关联的文件弹出层</td></tr><tr><td>Ctrl + Alt + Space</td><td>类名自动完成</td></tr><tr><td>Ctrl + Alt + 左方向键</td><td>退回到上一个操作的地方 <code>（必备）**（注意与其他软件快捷键冲突）**</code></td></tr><tr><td>Ctrl + Alt + 右方向键</td><td>前进到上一个操作的地方 <code>（必备）**（注意与其他软件快捷键冲突）**</code></td></tr><tr><td>Ctrl + Alt + 前方向键</td><td>在查找模式下，跳到上个查找的文件</td></tr><tr><td>Ctrl + Alt + 后方向键</td><td>在查找模式下，跳到下个查找的文件</td></tr></tbody></table><h2 id="Ctrl-Shift"><a href="#Ctrl-Shift" class="headerlink" title="Ctrl + Shift"></a>Ctrl + Shift</h2><table><thead><tr><th>快捷键</th><th>介绍</th></tr></thead><tbody><tr><td><strong>Ctrl + Shift + F</strong></td><td><strong>根据输入内容查找整个项目 或 指定目录内文件 <code>（必备）</code></strong></td></tr><tr><td><strong>Ctrl + Shift + R</strong></td><td><strong>根据输入内容替换对应内容，范围为整个项目 或 指定目录内文件 <code>（必备）</code></strong></td></tr><tr><td><strong>Ctrl + Shift + J</strong></td><td><strong>自动将下一行合并到当前行末尾 <code>（必备）</code></strong></td></tr><tr><td><strong>Ctrl + Shift + Z</strong></td><td><strong>取消撤销 <code>（必备）</code></strong></td></tr><tr><td>Ctrl + Shift + W</td><td>递进式取消选择代码块。可选中光标所在的单词或段落，连续按会在原有选中的基础上再扩展取消选中范围 <code>（必备）</code></td></tr><tr><td><strong>Ctrl + Shift + N</strong></td><td><strong>通过文件名定位 / 打开文件 / 目录，打开目录需要在输入的内容后面多加一个正斜杠 <code>（必备）</code></strong></td></tr><tr><td><strong>Ctrl + Shift + U</strong></td><td><strong>对选中的代码进行大 / 小写轮流转换 <code>（必备）</code></strong></td></tr><tr><td>Ctrl + Shift + T</td><td>对当前类生成单元测试类，如果已经存在的单元测试类则可以进行选择</td></tr><tr><td><strong>Ctrl + Shift + C</strong></td><td><strong>复制当前文件磁盘路径到剪贴板</strong></td></tr><tr><td><strong>Ctrl + Shift + V</strong></td><td><strong>弹出缓存的最近拷贝的内容管理器弹出层</strong></td></tr><tr><td>Ctrl + Shift + E</td><td>显示最近修改的文件列表的弹出层</td></tr><tr><td>Ctrl + Shift + H</td><td>显示方法层次结构</td></tr><tr><td><strong>Ctrl + Shift + B</strong></td><td><strong>跳转到类型声明处</strong></td></tr><tr><td>Ctrl + Shift + I</td><td>快速查看光标所在的方法 或 类的定义</td></tr><tr><td>Ctrl + Shift + A</td><td>查找动作 / 设置</td></tr><tr><td><strong>Ctrl + Shift + /</strong></td><td><strong>代码块注释 <code>（必备）</code></strong></td></tr><tr><td>Ctrl + Shift + [</td><td>选中从光标所在位置到它的顶部中括号位置</td></tr><tr><td>Ctrl + Shift + ]</td><td>选中从光标所在位置到它的底部中括号位置</td></tr><tr><td>Ctrl + Shift + +</td><td>展开所有代码</td></tr><tr><td>Ctrl + Shift + -</td><td>折叠所有代码</td></tr><tr><td>Ctrl + Shift + F7</td><td>高亮显示所有该选中文本，按 Esc 高亮消失</td></tr><tr><td>Ctrl + Shift + F8</td><td>在 Debug 模式下，指定断点进入条件</td></tr><tr><td>Ctrl + Shift + F9</td><td>编译选中的文件 / 包 / Module</td></tr><tr><td>Ctrl + Shift + F12</td><td>编辑器最大化</td></tr><tr><td>Ctrl + Shift + Space</td><td>智能代码提示</td></tr><tr><td>Ctrl + Shift + Enter</td><td>自动结束代码，行末自动添加分号 <code>（必备）</code></td></tr><tr><td>Ctrl + Shift + Backspace</td><td>退回到上次修改的地方</td></tr><tr><td>Ctrl + Shift + 1,2,3…9</td><td>快速添加指定数值的书签</td></tr><tr><td><strong>Ctrl + Shift + 左方向键</strong></td><td><strong>在代码文件上，光标跳转到当前单词 / 中文句的左侧开头位置，同时选中该单词 / 中文句</strong></td></tr><tr><td><strong>Ctrl + Shift + 右方向键</strong></td><td><strong>在代码文件上，光标跳转到当前单词 / 中文句的右侧开头位置，同时选中该单词 / 中文句</strong></td></tr><tr><td>Ctrl + Shift + 左方向键</td><td>在光标焦点是在工具选项卡上，缩小选项卡区域</td></tr><tr><td>Ctrl + Shift + 右方向键</td><td>在光标焦点是在工具选项卡上，扩大选项卡区域</td></tr><tr><td>Ctrl + Shift + 前方向键</td><td>光标放在方法名上，将方法移动到上一个方法前面，调整方法排序</td></tr><tr><td>Ctrl + Shift + 后方向键</td><td>光标放在方法名上，将方法移动到下一个方法前面，调整方法排序</td></tr></tbody></table><h2 id="Alt-Shift"><a href="#Alt-Shift" class="headerlink" title="Alt + Shift"></a>Alt + Shift</h2><table><thead><tr><th>快捷键</th><th>介绍</th></tr></thead><tbody><tr><td>Alt + Shift + N</td><td>选择 / 添加 task</td></tr><tr><td>Alt + Shift + F</td><td>显示添加到收藏夹弹出层</td></tr><tr><td>Alt + Shift + C</td><td>查看最近操作项目的变化情况列表</td></tr><tr><td>Alt + Shift + F</td><td>添加到收藏夹</td></tr><tr><td>Alt + Shift + I</td><td>查看项目当前文件</td></tr><tr><td>Alt + Shift + F7</td><td>在 Debug 模式下，下一步，进入当前方法体内，如果方法体还有方法，则会进入该内嵌的方法中，依此循环进入</td></tr><tr><td>Alt + Shift + F9</td><td>弹出 <code>Debug</code> 的可选择菜单</td></tr><tr><td>Alt + Shift + F10</td><td>弹出 <code>Run</code> 的可选择菜单</td></tr><tr><td>Alt + Shift + 左键双击</td><td>选择被双击的单词 / 中文句，按住不放，可以同时选择其他单词 / 中文句</td></tr><tr><td>Alt + Shift + 前方向键</td><td>移动光标所在行向上移动</td></tr><tr><td>Alt + Shift + 后方向键</td><td>移动光标所在行向下移动</td></tr></tbody></table><h2 id="Ctrl-Shift-Alt"><a href="#Ctrl-Shift-Alt" class="headerlink" title="Ctrl + Shift + Alt"></a>Ctrl + Shift + Alt</h2><table><thead><tr><th>快捷键</th><th>介绍</th></tr></thead><tbody><tr><td>Ctrl + Shift + Alt + V</td><td>无格式黏贴</td></tr><tr><td>Ctrl + Shift + Alt + N</td><td>前往指定的变量 / 方法</td></tr><tr><td>Ctrl + Shift + Alt + S</td><td>打开当前项目设置</td></tr><tr><td>Ctrl + Shift + Alt + C</td><td>复制参考信息</td></tr></tbody></table><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><table><thead><tr><th>快捷键</th><th>介绍</th></tr></thead><tbody><tr><td>F2</td><td>跳转到下一个高亮错误 或 警告位置 <code>（必备）</code></td></tr><tr><td>F3</td><td>在查找模式下，定位到下一个匹配处</td></tr><tr><td>F4</td><td>编辑源</td></tr><tr><td>F7</td><td>在 Debug 模式下，进入下一步，如果当前行断点是一个方法，则进入当前方法体内，如果该方法体还有方法，则不会进入该内嵌的方法中</td></tr><tr><td>F8</td><td>在 Debug 模式下，进入下一步，如果当前行断点是一个方法，则不进入当前方法体内</td></tr><tr><td>F9</td><td>在 Debug 模式下，恢复程序运行，但是如果该断点下面代码还有断点则停在下一个断点上</td></tr><tr><td>F11</td><td>添加书签</td></tr><tr><td>F12</td><td>回到前一个工具窗口</td></tr><tr><td>Tab</td><td>缩进</td></tr><tr><td>ESC</td><td>从工具窗口进入代码文件窗口</td></tr><tr><td><strong>连按两次 Shift</strong></td><td><strong>弹出 <code>Search Everywhere</code> 弹出层</strong></td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> idea </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VSCode常用快捷键Mac版</title>
      <link href="/2020/020253487.html"/>
      <url>/2020/020253487.html</url>
      
        <content type="html"><![CDATA[<h3 id="全局"><a href="#全局" class="headerlink" title="全局"></a>全局</h3><ul><li>Command + K + Command + S 打开快捷键查找/编辑页</li><li>Command + Shift + P / F1 显示命令面板</li><li>Command + P 快速打开文件</li><li>Command + Shift + N 打开新窗口</li><li>Command + W 关闭窗 口</li></ul><h3 id="基本"><a href="#基本" class="headerlink" title="基本"></a>基本</h3><ul><li>Command + X 剪切（未选中文本的情况下，剪切光标所在行）</li><li>Command + C 复制（未选中文本的情况下，复制光标所在行）</li><li>Option + Up 向上移动行</li><li>Option + Down 向下移动行</li><li>Option + Shift + Up 向上复制行</li><li>Option + Shift + Down 向下复制行</li><li>Command + Shift + K 删除行</li><li>Command + Enter 下一行插入</li><li>Command + Shift + Enter 上一行插入</li><li>Command + Shift +  跳转到匹配的括号</li><li>Command + [ 减少缩进</li><li>Command + ] 增加缩进</li><li>Home 跳转至行首</li><li>End 跳转到行尾</li><li>Command + Up 跳转至文件开头</li><li>Command + Down 跳转至文件结尾</li><li>Ctrl + PgUp 按行向上滚动</li><li>Ctrl + PgDown 按行向下滚动</li><li>Command + PgUp 按屏向上滚动</li><li>Command + PgDown 按屏向下滚动</li><li>Command + Shift + [ 折叠代码块</li><li>Command + Shift + ] 展开代码块</li><li>Command + K Command + [ 折叠全部子代码块</li><li>Command + K Command + ] 展开全部子代码块</li><li>Command + K Command + 0 折叠全部代码块</li><li>Command + K Command + J 展开全部代码块</li><li>Command + K Command + C 添加行注释</li><li>Command + K Command + U 移除行注释</li><li>Command + / 添加、移除行注释</li><li>Option + Shift + A 添加、移除块注释</li><li>Option + Z 自动换行、取消自动换行</li></ul><h3 id="多光标与选择"><a href="#多光标与选择" class="headerlink" title="多光标与选择"></a>多光标与选择</h3><ul><li>Option + 点击 插入多个光标</li><li>Command + Option + Up 向上插入光标</li><li>Command + Option + Down 向下插入光标</li><li>Command + U 撤销上一个光标操作</li><li>Option + Shift + I 在所选行的行尾插入光标</li><li>Command + I 选中当前行</li><li>Command + Shift + L 选中所有与当前选中内容相同部分</li><li>Command + F2 选中所有与当前选中单词相同的单词</li><li>Command + Ctrl + Shift + Left 折叠选中</li><li>Command + Ctrl + Shift + Right 展开选中</li><li>Alt + Shift + 拖动鼠标 选中代码块</li><li>Command + Shift + Option + Up 列选择 向上</li><li>Command + Shift + Option + Down 列选择 向下</li><li>Command + Shift + Option + Left 列选择 向左</li><li>Command + Shift + Option + Right 列选择 向右</li><li>Command + Shift + Option + PgUp 列选择 向上翻页</li><li>Command + Shift + Option + PgDown 列选择 向下翻页</li></ul><h3 id="查找替换"><a href="#查找替换" class="headerlink" title="查找替换"></a>查找替换</h3><ul><li>Command + F 查找</li><li>Command + Option + F 替换</li><li>Command + G 查找下一个</li><li>Command + Shift + G 查找上一个</li><li>Option + Enter 选中所有匹配项</li><li>Command + D 向下选中相同内容</li><li>Command + K Command + D 移除前一个向下选中相同内容</li></ul><h3 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h3><ul><li>Ctrl + Space 打开建议</li><li>Command + Shift + Space 参数提示</li><li>Tab Emmet插件缩写补全</li><li>Option + Shift + F 格式化</li><li>Command + K Command + F 格式化选中内容</li><li>F12 跳转到声明位置</li><li>Option + F12 查看具体声明内容</li><li>Command + K F12 分屏查看具体声明内容</li><li>Command + . 快速修复</li><li>Shift + F12 显示引用</li><li>F2 重命名符号</li><li>Command + Shift + . 替换为上一个值</li><li>Command + Shift + , 替换为下一个值</li><li>Command + K Command + X 删除行尾多余空格</li><li>Command + K M 更改文件语言</li></ul><h3 id="导航"><a href="#导航" class="headerlink" title="导航"></a>导航</h3><ul><li>Command + T 显示所有符号</li><li>Ctrl + G 跳转至某行</li><li>Command + P 跳转到某个文件</li><li>Command + Shift + O 跳转到某个符号</li><li>Command + Shift + M 打开问题面板</li><li>F8 下一个错误或警告位置</li><li>Shift + F8 上一个错误或警告位置</li><li>Ctrl + Shift + Tab 编辑器历史记录</li><li>Ctrl + - 后退</li><li>Ctrl + Shift + - 前进</li><li>Ctrl + Shift + M Tab 切换焦点</li></ul><h3 id="编辑器管理"><a href="#编辑器管理" class="headerlink" title="编辑器管理"></a>编辑器管理</h3><ul><li>Shift + Alt + 鼠标左键 列编辑模式</li><li>Command + W 关闭编辑器</li><li>Command + K F 关闭文件夹</li><li>Command +  编辑器分屏</li><li>Command + 1 切换到第一分组</li><li>Command + 2 切换到第二分组</li><li>Command + 3 切换到第三分组</li><li>Command + K Command + Left 切换到上一分组</li><li>Command + K Command + Right 切换到下一分组</li><li>Command + K Command + Shift + Left 左移编辑器</li><li>Command + K Command + Shift + Right 右移编辑器</li><li>Command + K Left 激活左侧编辑组</li><li>Command + K Right 激活右侧编辑组</li></ul><h3 id="文件管理"><a href="#文件管理" class="headerlink" title="文件管理"></a>文件管理</h3><ul><li>Command + N 新建文件</li><li>Command + O 打开文件</li><li>Command + S 保存文件</li><li>Command + Shift + S 另存为</li><li>Command + Option + S 全部保存</li><li>Command + W 关闭</li><li>Command + K Command + W 全部关闭</li><li>Command + Shift + T 重新打开被关闭的编辑器</li><li>Command + K Enter 保持打开</li><li>Ctrl + Tab 打开下一个</li><li>Ctrl + Shift + Tab 打开上一个</li><li>Command + K P 复制当前文件路径</li><li>Command + K R 在资源管理器中查看当前文件</li><li>Command + K O 新窗口打开当前文件</li></ul><h3 id="显示"><a href="#显示" class="headerlink" title="显示"></a>显示</h3><ul><li>Command + Ctrl + F 全屏、退出全屏</li><li>Command + Option + 1 切换编辑器分屏方式（横、竖）</li><li>Command + + 放大</li><li>Command + - 缩小</li><li>Command + B 显示、隐藏侧边栏</li><li>Command + Shift + E 显示资源管理器 或 切换焦点</li><li>Command + Shift + F 显示搜索框</li><li>Ctrl + Shift + G 显示Git面板</li><li>Command + Shift + D 显示调试面板</li><li>Command + Shift + X 显示插件面板</li><li>Command + Shift + H 全局搜索替换</li><li>Command + Shift + J 显示、隐藏高级搜索</li><li>Command + Shift + C 打开新终端</li><li>Command + Shift + U 显示输出面板</li><li>Command + Shift + V Markdown预览窗口</li><li>Command + K V 分屏显示 Markdown预览窗口</li></ul><h3 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h3><ul><li>F9 设置 或 取消断点</li><li>F5 开始 或 继续</li><li>F11 进入</li><li>Shift + F11 跳出</li><li>F10 跳过</li><li>Command + K Command + I 显示悬停信息</li></ul><h3 id="集成终端"><a href="#集成终端" class="headerlink" title="集成终端"></a>集成终端</h3><ul><li>Ctrl + ` 显示/关闭终端</li><li>Command + Up 向上滚动</li><li>Command + Down 向下滚动</li><li>PgUp 向上翻页</li><li>PgDown 向下翻页</li><li>Command + Home 滚动到顶部</li><li>Command + End 滚动到底部</li></ul>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vscode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Node.js 必知必会（安装配置、应用实例及同步控制）</title>
      <link href="/2020/011231581.html"/>
      <url>/2020/011231581.html</url>
      
        <content type="html"><![CDATA[<h2 id="一、Node-js简介"><a href="#一、Node-js简介" class="headerlink" title="一、Node.js简介"></a>一、Node.js简介</h2><p>Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行环境。使用了一个事件驱动、非阻塞式 I/O 的模型，使其轻量又高效。于2009年由Google Brain团队的软件工程师Ryan Dahl发起创建，2015年后正式被<a href="https://foundation.nodejs.org/" target="_blank" rel="noopener">NodeJS基金会</a>接管。</p><h3 id="NodeJS-架构"><a href="#NodeJS-架构" class="headerlink" title="NodeJS 架构"></a>NodeJS 架构</h3><p><img src="https://pic.lixl.cn/2019/20200113000457.png/w1280" alt="Node.js架构"></p><p>Node使用事件驱动模型，当web server接收到请求，就把它关闭然后进行处理，然后去服务下一个web请求。</p><p>当这个请求完成，它被放回处理队列，当到达队列开头，这个结果被返回给用户。</p><p>这个模型非常高效可扩展性非常强，因为 webserver 一直接受请求而不等待任何读写操作。（这也称之为非阻塞式IO或者事件驱动IO）。在事件驱动模型中，会生成一个主循环来监听事件，当检测到事件时触发回调函数。</p><h3 id="相关资源"><a href="#相关资源" class="headerlink" title="相关资源"></a>相关资源</h3><ul><li>Node.js官网：<a href="https://nodejs.org/zh-cn/" target="_blank" rel="noopener">https://nodejs.org/zh-cn/</a></li><li>版本管理工具nvm：<a href="https://github.com/nvm-sh/nvm" target="_blank" rel="noopener">https://github.com/nvm-sh/nvm</a></li><li>包管理工具npm：<a href="https://www.npmjs.com/" target="_blank" rel="noopener">https://www.npmjs.com/</a></li><li>npm中文文档：<a href="https://www.npmjs.cn/" target="_blank" rel="noopener">https://www.npmjs.cn/</a></li><li>国内的 npm 镜像源：<a href="http://cnpmjs.org/" target="_blank" rel="noopener">http://cnpmjs.org/</a></li><li>中文社区：<a href="https://cnodejs.org/" target="_blank" rel="noopener">https://cnodejs.org/</a></li></ul><h2 id="二、安装配置"><a href="#二、安装配置" class="headerlink" title="二、安装配置"></a>二、安装配置</h2><p>建议使用nvm来进行node版本管理，它会安装相应版本的npm。</p><h3 id="安装nvm及Node-js"><a href="#安装nvm及Node-js" class="headerlink" title="安装nvm及Node.js"></a>安装nvm及Node.js</h3><p>nvm全名node.js version management，顾名思义是一个nodejs的版本管理工具。通过它可以安装和切换不同版本的nodejs。</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 安装nvm（ 升级nvm重新执行此命令）:</span>curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.35.2/install.sh <span class="token operator">|</span> <span class="token function">bash</span><span class="token comment" spellcheck="true"># 列出所有可以安装的node版本号</span>nvm ls-remote<span class="token comment" spellcheck="true"># 安装指定版本号的node</span>nvm <span class="token function">install</span> v12.4.1<span class="token comment" spellcheck="true"># 设置 nodejs 默认版本</span>nvm <span class="token function">alias</span> default 12.4.1<span class="token comment" spellcheck="true"># 切换node的版本</span>nvm use v10.15.3<span class="token comment" spellcheck="true"># 当前node版本</span>nvm currentnode -v<span class="token comment" spellcheck="true"># 列出所有已经安装的node版本</span>nvm <span class="token function">ls</span><span class="token comment" spellcheck="true"># 卸载已安装的node版本</span>nvm uninstall v6.9.5<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="npm"><a href="#npm" class="headerlink" title="npm"></a>npm</h3><p>npm 是世界上最大的软件注册中心，随同NodeJS一起安装，来自全球各地的开源开发人员使用 npm 来共享和复用软件包。npm 由三个独立的部分组成：</p><ul><li>网站： <a href="https://npmjs.com" target="_blank" rel="noopener">https://npmjs.com</a> 是开发者查找包（package）、设置参数以及管理 npm 使用体验的主要途径。</li><li>注册表（registry）：是一个巨大的数据库，保存了每个包（package）的信息。</li><li>命令行工具 (CLI)：通过命令行或终端运行。开发者通过 CLI 与 npm 打交道。</li></ul><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 查看 npm 版本</span><span class="token function">npm</span> -v<span class="token comment" spellcheck="true"># 更新npm版本</span><span class="token function">npm</span> <span class="token function">install</span> npm@latest -g<span class="token comment" spellcheck="true"># 搜索模块</span><span class="token function">npm</span> search hexo<span class="token comment" spellcheck="true"># 安装依赖包</span><span class="token function">npm</span> <span class="token function">install</span> <span class="token operator">&lt;</span>Module Name<span class="token operator">></span><span class="token function">npm</span> <span class="token function">install</span> hexo      <span class="token comment" spellcheck="true"># 本地安装 hexo</span><span class="token function">npm</span> <span class="token function">install</span> hexo -g   <span class="token comment" spellcheck="true"># 全局安装 hexo</span><span class="token comment" spellcheck="true"># 查看所有全局安装的模块</span><span class="token function">npm</span> list -g<span class="token comment" spellcheck="true"># 查看某个模块</span><span class="token function">npm</span> list hexo<span class="token comment" spellcheck="true"># 卸载模块</span><span class="token function">npm</span> uninstall hexo<span class="token comment" spellcheck="true"># 卸载后，查看包是否还存在</span><span class="token function">npm</span> <span class="token function">ls</span><span class="token comment" spellcheck="true"># 更新某个模块</span><span class="token function">npm</span> update hexo<span class="token comment" spellcheck="true"># 创建模块</span><span class="token function">npm</span> init<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>每个版本的 Node 都自带一个不同版本的 npm，可以用 npm -v 来查看 npm 的版本。全局安装的 npm 包并不会在不同的 Node 环境中共享，因为这会引起兼容问题。它们被放在了不同版本的目录下，例如 ~/.nvm/versions/node/${version}/lib/node_modules 这样的目录。</p><p>运行下面这个命令，可以从特定版本导入之前安装过的 npm 包到我们将要安装的新版本 Node 中：</p><pre class="line-numbers language-bash"><code class="language-bash">nvm <span class="token function">install</span> v12.16.1 --reinstall-packages-from<span class="token operator">=</span>v10.15.3<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="三、Node特点"><a href="#三、Node特点" class="headerlink" title="三、Node特点"></a>三、Node特点</h2><h3 id="异步I-O"><a href="#异步I-O" class="headerlink" title="异步I/O"></a>异步I/O</h3><p>在Node中，绝大多数的操作都以异步的方式进行调用。在底层构建了很多异步I/O的API，从文件读取到网络请求等，均是如此。这样的意义在于，在Node中，我们可以从语言层面很自然地进行并行I/O操作。每个调用之间无须等待之前的I/O调用结束。在编程模型上可以极大提升效率。<br>下面的两个文件读取任务的耗时取决于最慢的那个文件读取的耗时：</p><pre class="line-numbers language-js"><code class="language-js">fs<span class="token punctuation">.</span><span class="token function">readFile</span><span class="token punctuation">(</span><span class="token string">'/path1'</span><span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>err<span class="token punctuation">,</span> file<span class="token punctuation">)</span> <span class="token punctuation">{</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'读取文件1完成'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>fs<span class="token punctuation">.</span><span class="token function">readFile</span><span class="token punctuation">(</span><span class="token string">'/path2'</span><span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>err<span class="token punctuation">,</span> file<span class="token punctuation">)</span> <span class="token punctuation">{</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'读取文件2完成'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>而对于同步I/O而言，它们的耗时是两个任务的耗时之和。这里异步带来的优势是显而易见的。</p><h3 id="事件与回调函数"><a href="#事件与回调函数" class="headerlink" title="事件与回调函数"></a>事件与回调函数</h3><p>在JavaScript中，函数被作为第一等公民来对待，可以将函数作为对象传递给方法作为实参进行调用。Node将前端浏览器中应用广泛且成熟的事件引入后端，配合异步I/O，将事件点暴露给业务逻辑。</p><p>下面的例子展示的是Ajax异步提交的服务器端处理过程。Node创建一个Web服务器，并侦听8080端口。对于服务器，我们为其绑定了request事件，对于请求对象，我们为其绑定了data事件和end事件：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">var</span> http <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'http'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">var</span> quertstring <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'querystring'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>http<span class="token punctuation">.</span><span class="token function">createServer</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span>req<span class="token punctuation">,</span>res<span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token keyword">var</span> postData <span class="token operator">=</span> <span class="token string">''</span><span class="token punctuation">;</span>  req<span class="token punctuation">.</span><span class="token function">setEncoding</span><span class="token punctuation">(</span><span class="token string">'utf8'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 监听请求的data事件</span>  req<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">'data'</span><span class="token punctuation">,</span><span class="token keyword">function</span><span class="token punctuation">(</span>chunk<span class="token punctuation">)</span><span class="token punctuation">{</span>    postData <span class="token operator">+</span><span class="token operator">=</span> chunk<span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 监听请求的end事件</span>  req<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">'end'</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    res<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span>postData<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">listen</span><span class="token punctuation">(</span><span class="token number">8080</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'服务器启动完成，监听端口：8080'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>相应地，我们在前端为Ajax请求绑定了success事件，在发出请求后，只需关心请求成功时执行相应的业务逻辑即可，相关代码如下：</p><pre class="line-numbers language-js"><code class="language-js">$<span class="token punctuation">.</span><span class="token function">ajax</span><span class="token punctuation">(</span><span class="token punctuation">{</span>  <span class="token string">'url'</span><span class="token punctuation">:</span> <span class="token string">'/url'</span><span class="token punctuation">,</span>  <span class="token string">'method'</span><span class="token punctuation">:</span> <span class="token string">'POST'</span><span class="token punctuation">,</span>  <span class="token string">'data'</span><span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token string">'success'</span><span class="token punctuation">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>data<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// success事件</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>与其他的Web后端编程语言相比，Node除了异步和事件外，回调函数是一大特色。纵观下来，回调函数也是最好的接受异步调用返回数据的方式。但是这种编程方式对于很多习惯同步思路编程的人来说，也许是十分不习惯的。代码的编写顺序与执行顺序并无关系，这对他们可能造成阅读上的障碍。</p><h3 id="单线程"><a href="#单线程" class="headerlink" title="单线程"></a>单线程</h3><p>Node保持了JavaScript在浏览器中单线程的特点。而且在Node中，JavaScript与其余线程是无法共享任何状态的。单线程的最大好处是不用像多线程编程那样处处在意状态的同步问题，这里没有死锁的存在，也没有线程上下文交换所带来的性能上的开销。<br>同样，单线程也有它自身的弱点。Node采用了与Web Workers相同的思路来解决单线程中大计算量的问题：<code>child_process</code>。子进程的出现，意味着Node可以从容地应对单线程在健壮性和无法利用多核CPU方面的问题。</p><h3 id="擅长I-O密集型的应用"><a href="#擅长I-O密集型的应用" class="headerlink" title="擅长I/O密集型的应用"></a>擅长I/O密集型的应用</h3><p>通常，说Node擅长I/O密集型的应用场景基本上是没人反对的。Node面向网络且擅长并行I/O，能够有效地组织起更多的硬件资源，从而提供更多好的服务。I/O密集的优势主要在于Node利用事件循环的处理能力，而不是启动每一个线程为每一个请求服务，资源占用极少。</p><h3 id="性能不俗"><a href="#性能不俗" class="headerlink" title="性能不俗"></a>性能不俗</h3><p>CPU密集型应用给Node带来的挑战主要是：由于JavaScript单线程的原因，如果有长时间运行的计算（比如大循环），将会导致CPU时间片不能释放，使得后续I/O无法发起。但是适当调整和分解大型运算任务为多个小任务，使得运算能够适时释放，不阻塞I/O调用的发起，这样既可同时享受到并行异步I/O的好处，又能充分利用CPU，I/O阻塞造成的性能浪费远比CPU的影响小。</p><p><img src="https://pic.lixl.cn/2019/20200113165953.png/w1280" alt="计算斐波那契数列的耗时排行"></p><h2 id="四、Node-js常用模块"><a href="#四、Node-js常用模块" class="headerlink" title="四、Node.js常用模块"></a>四、Node.js常用模块</h2><p>更多模块详细介绍，可查阅官方文档: <a href="https://nodejs.org/api/" target="_blank" rel="noopener">https://nodejs.org/api/</a></p><h3 id="Global模块"><a href="#Global模块" class="headerlink" title="Global模块"></a>Global模块</h3><p>浏览器JavaScript当中window是全局对象，NodeJS中全局对象是global，global最根本的作用是作为全局变量的宿主（即所有的全局变量都是global对象的属性），因此在所有模块中都可以直接使用而无需包含。</p><h3 id="Process模块"><a href="#Process模块" class="headerlink" title="Process模块"></a>Process模块</h3><p>process是全局变量(即global对象的属性)，用于描述当前NodeJS进程状态。</p><h3 id="Console模块"><a href="#Console模块" class="headerlink" title="Console模块"></a>Console模块</h3><p>console用于提供控制台标准输出。</p><p><code>console.log()</code>：向标准输出流打印字符并以换行符结束(<em>如果只有1个参数，则输出该参数的字符串形式；如果有2个参数，则以类似于C语言<code>printf()</code>的格式化输出</em>)。</p><p><code>console.error()</code>：与<code>console.log()</code>的用法相同，只是向标准错误流进行输出。</p><p><code>console.trace()</code>：向标准错误流输出当前的调用栈:</p><pre class="line-numbers language-bash"><code class="language-bash">$ node app.jsTrace    at Object.<span class="token operator">&lt;</span>anonymous<span class="token operator">></span> <span class="token punctuation">(</span>/workspace/app.js:1:71<span class="token punctuation">)</span>    at Module._compile <span class="token punctuation">(</span>module.js:643:30<span class="token punctuation">)</span>    at Object.Module._extensions<span class="token punctuation">..</span>js <span class="token punctuation">(</span>module.js:654:10<span class="token punctuation">)</span>    at Module.load <span class="token punctuation">(</span>module.js:556:32<span class="token punctuation">)</span>    at tryModuleLoad <span class="token punctuation">(</span>module.js:499:12<span class="token punctuation">)</span>    at Function.Module._load <span class="token punctuation">(</span>module.js:491:3<span class="token punctuation">)</span>    at Function.Module.runMain <span class="token punctuation">(</span>module.js:684:10<span class="token punctuation">)</span>    at startup <span class="token punctuation">(</span>bootstrap_node.js:187:16<span class="token punctuation">)</span>    at bootstrap_node.js:608:3<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Util模块"><a href="#Util模块" class="headerlink" title="Util模块"></a>Util模块</h3><p>util提供常用函数集合，用于弥补核心JavaScript功能方面的不足。</p><h3 id="Events模块"><a href="#Events模块" class="headerlink" title="Events模块"></a>Events模块</h3><p><code>events</code>是NodeJS最重要的模块，因为NodeJS本身就是基于事件式的架构，该模块提供了唯一接口，所以堪称NodeJS事件编程的基石。<code>events</code>模块不仅用于与下层的事件循环交互，还几乎被所有的模块所依赖。</p><p><code>events</code>模块只提供1个<code>events.EventEmitter</code>对象，<code>EventEmitter</code>对象封装了事件发射和事件监听器。每个<code>EventEmitter</code>事件由1个事件名和若干参数组成，事件名是1个字符串。<code>EventEmitter</code>对每个事件支持若干监听器，事件发射时，注册至该事件的监听器依次被调用，事件参数将作为回调函数参数传递。</p><p>下面例子中，<code>emitter</code>为事件<code>targetEvent</code>注册2个事件监听器，然后发射<code>targetEvent</code>事件，结果2个事件监听器的回调函数被依次先后调用。</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">var</span> events <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">"events"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">var</span> emitter <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">events<span class="token punctuation">.</span>EventEmitter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>emitter<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">"targetEvent"</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span>arg1<span class="token punctuation">,</span> arg2<span class="token punctuation">)</span> <span class="token punctuation">{</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"listener1"</span><span class="token punctuation">,</span> arg1<span class="token punctuation">,</span> arg2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>emitter<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">"targetEvent"</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span>arg1<span class="token punctuation">,</span> arg2<span class="token punctuation">)</span> <span class="token punctuation">{</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"listener2"</span><span class="token punctuation">,</span> arg1<span class="token punctuation">,</span> arg2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>emitter<span class="token punctuation">.</span><span class="token function">emit</span><span class="token punctuation">(</span><span class="token string">"targetEvent"</span><span class="token punctuation">,</span> <span class="token string">"Hank"</span><span class="token punctuation">,</span> <span class="token number">2018</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-bash"><code class="language-bash">$ node app.jslistener1 Hank 2018listener2 Hank 2018<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="EventEmitter常用API"><a href="#EventEmitter常用API" class="headerlink" title="EventEmitter常用API"></a>EventEmitter常用API</h4><ul><li><code>EventEmitter.on(event, listener)</code>：为指定事件注册监听器，接受1个字符串事件名event和1个回调函数listener。</li><li><code>EventEmitter.emit(event,[arg1],[arg2],[...])</code>：发射event事件，传递若干可选参数到事件监听器的参数列表。</li><li><code>EventEmitter.once(event, listener)</code>：为指定事件注册1个单次监听器，即该监听器最多只会触发一次，触发后立刻解除。</li><li><code>EventEmitter.removeListener(event, listener)</code>：移除指定事件的某个监听器，listener必须是该事件已经注册过的监听器。</li><li><code>EventEmitter.removeAllListeners([event])</code>：移除所有事件的所有监听器，如果指定event，则移除指定事件的所有监听器。</li></ul><h3 id="File-System模块"><a href="#File-System模块" class="headerlink" title="File System模块"></a>File System模块</h3><p><code>fs</code>模块封装了文件操作，提供了文件读取、写入、更名、删除、遍历、链接等POSIX文件系统操作，该模块中所有操作都提供了异步和同步2个版本。</p><p><code>fs.readFile(filename,[encoding],[callback(err,data)])</code>用于读取文件，第1个参数<code>filename</code>表示要读取的文件名。第2个参数<code>encoding</code>表示文件的字符编码，第3个参数<code>callback</code>是回调函数，用于接收文件内容。</p><p>回调函数提供<code>err</code>和<code>data</code>两个参数，<code>err</code>表示有无错误发生，<code>data</code>是文件内容。如果指定<code>encoding</code>，<code>data</code>将是1个解析后的字符串，否则<code>data</code>将会是以<code>Buffe</code>r`形式表示的二进制数据。</p><h4 id="fs-readFileSync"><a href="#fs-readFileSync" class="headerlink" title="fs.readFileSync()"></a>fs.readFileSync()</h4><p>NodeJS提供的<code>fs.readFileSync()</code>函数是<code>readFile()</code>的同步版本，两者接受的参数相同，读取到的文件内容会以函数返回值形式返回。如果有错误发生<code>fs</code>将会抛出异常，需要使用<code>try...catch</code>捕捉并处理异常。</p><blockquote><p>与同步I/O函数不同，NodeJS中异步函数大多没有返回值。</p></blockquote><h4 id="fs-open"><a href="#fs-open" class="headerlink" title="fs.open()"></a>fs.open()</h4><p><code>fs.open(path,flags,[mode],[callback(err,fd)])</code>封装了POSIX的<code>open()</code>函数，与C语言标准库中<code>fopen()</code>函数类似。该函数接受2个必选参数，第1个参数<code>path</code>为文件路径，第2个参数<code>flags</code>代表文件打开模式，第3个参数<code>mode</code>用于创建文件时给文件指定权限（<em>默认0666</em>），第4个参数是<strong>回调函数</strong>，函数中需要传递文件描述符<code>fd</code>。</p><h4 id="fs-read"><a href="#fs-read" class="headerlink" title="fs.read()"></a>fs.read()</h4><p><code>fs.read(fd,buffer,offset,length,position,[callback(err,bytesRead,buffer)])</code>封装了POSIX的read函数，相比<code>fs.readFile()</code>提供了更底层的接口。</p><p><code>fs.read()</code>的功能是从指定的文件描述符fd中读取数据并写入<code>buffer</code>指向的缓冲区对象。<code>offset</code>是<code>buffer</code>的写入偏移量。<code>length</code>是要从文件中读取的字节数。<code>position</code>是文件读取的起始位置，如果<code>position</code>的值为<code>null</code>，则会从当前文件指针的位置读取。回调函数传递<code>bytesRead</code>和<code>buffer</code>，分别表示读取的<strong>字节数</strong>和<strong>缓冲区对象</strong>。</p><h3 id="Http模块"><a href="#Http模块" class="headerlink" title="Http模块"></a>Http模块</h3><p>NodeJS标准库提供的<code>http</code>模块封装了一个高效的HTTP服务器<code>http.Server</code>和一个简易的HTTP客户端<code>http.request</code>。</p><p><code>http</code>模块中的HTTP服务器对象，核心由NodeJS底层依靠C++实现，接口使用JavaScript封装，兼顾了高性能与简易性。</p><h2 id="五、创建Node-js应用"><a href="#五、创建Node-js应用" class="headerlink" title="五、创建Node.js应用"></a>五、创建Node.js应用</h2><h3 id="使用Node创建http服务器"><a href="#使用Node创建http服务器" class="headerlink" title="使用Node创建http服务器"></a>使用Node创建http服务器</h3><p>使用 require 指令来载入 http 模块，并将实例化的 HTTP 赋值给变量 http，实例如下:</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">var</span> http <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">"http"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>使用 http.createServer() 方法创建服务器，并使用 listen 方法绑定 8888 端口。 函数通过 request, response 参数来接收和响应数据。在你项目的根目录下创建一个叫 server.js 的文件，并写入以下代码：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">const</span> http <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'http'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">const</span> hostname <span class="token operator">=</span> <span class="token string">'127.0.0.1'</span><span class="token punctuation">;</span><span class="token keyword">const</span> port <span class="token operator">=</span> <span class="token number">8080</span><span class="token punctuation">;</span><span class="token keyword">const</span> server <span class="token operator">=</span> http<span class="token punctuation">.</span><span class="token function">createServer</span><span class="token punctuation">(</span><span class="token punctuation">(</span>req<span class="token punctuation">,</span> res<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>  res<span class="token punctuation">.</span>statusCode <span class="token operator">=</span> <span class="token number">200</span><span class="token punctuation">;</span>  res<span class="token punctuation">.</span><span class="token function">setHeader</span><span class="token punctuation">(</span><span class="token string">'Content-Type'</span><span class="token punctuation">,</span> <span class="token string">'text/plain'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  res<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token string">'Hello World'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 终端打印如下信息</span>server<span class="token punctuation">.</span><span class="token function">listen</span><span class="token punctuation">(</span>port<span class="token punctuation">,</span> hostname<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token string">`Server running at http://</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>hostname<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">:</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>port<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">/`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>以上代码我们完成了一个可以工作的 HTTP 服务器。使用 <strong>node</strong> 命令执行以上的代码：</p><pre class="line-numbers language-js"><code class="language-js">node server<span class="token punctuation">.</span>jsServer running at http<span class="token punctuation">:</span><span class="token operator">/</span><span class="token operator">/</span><span class="token number">127.0</span><span class="token punctuation">.</span><span class="token number">0.1</span><span class="token punctuation">:</span><span class="token number">8080</span><span class="token operator">/</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>打开浏览器访问 <code>http://127.0.0.1:8080/</code>，会看到一个写着 “Hello World”的网页。</p><h3 id="web框架express简单使用"><a href="#web框架express简单使用" class="headerlink" title="web框架express简单使用"></a>web框架express简单使用</h3><p>express 是 Node应用最广泛的快速、开放、极简主义 web 框架，现在是 4.x 版本。官方提供了应用程序生成器工具 express-generator 可以快速创建应用程序骨架。安装：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">npm</span> <span class="token function">install</span> express --save<span class="token function">npm</span> <span class="token function">install</span> express-generator -g<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>创建名称为 <em>ExpressDemo</em> 的 Express 应用。此应用将在当前目录下的 <em>ExpressDemo</em> 目录中创建，并且设置为使用 <a href="https://pugjs.org/" target="_blank" rel="noopener">Pug</a> 模板引擎：</p><pre class="line-numbers language-bash"><code class="language-bash">express --view<span class="token operator">=</span>pug ExpressDemo   create <span class="token keyword">:</span> ExpressDemo/   create <span class="token keyword">:</span> ExpressDemo/public/   create <span class="token keyword">:</span> ExpressDemo/public/javascripts/   create <span class="token keyword">:</span> ExpressDemo/public/images/   create <span class="token keyword">:</span> ExpressDemo/public/stylesheets/   create <span class="token keyword">:</span> ExpressDemo/public/stylesheets/style.css   create <span class="token keyword">:</span> ExpressDemo/routes/   create <span class="token keyword">:</span> ExpressDemo/routes/index.js   create <span class="token keyword">:</span> ExpressDemo/routes/users.js   create <span class="token keyword">:</span> ExpressDemo/views/   create <span class="token keyword">:</span> ExpressDemo/views/error.pug   create <span class="token keyword">:</span> ExpressDemo/views/index.pug   create <span class="token keyword">:</span> ExpressDemo/views/layout.pug   create <span class="token keyword">:</span> ExpressDemo/app.js   create <span class="token keyword">:</span> ExpressDemo/package.json   create <span class="token keyword">:</span> ExpressDemo/bin/   create <span class="token keyword">:</span> ExpressDemo/bin/www   change directory:     $ <span class="token function">cd</span> ExpressDemo   <span class="token function">install</span> dependencies:     $ <span class="token function">npm</span> <span class="token function">install</span>   run the app:     $ DEBUG<span class="token operator">=</span>expressdemo:* <span class="token function">npm</span> start<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>按提示安装依赖并启动。</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">cd</span> ExpressDemo<span class="token function">npm</span> <span class="token function">install</span>DEBUG<span class="token operator">=</span>expressdemo:* <span class="token function">npm</span> start  <span class="token comment" spellcheck="true"># MacOS</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>在浏览器中打开 <code>http://localhost:3000/</code> 就可以看到这个应用了。</p><p>通过生成器创建的应用一般都有如下目录结构：</p><pre class="line-numbers language-bash"><code class="language-bash">tree -I <span class="token string">"node_modules"</span><span class="token keyword">.</span>├── app.js├── bin│   └── www├── package-lock.json├── package.json├── public│   ├── images│   ├── javascripts│   └── stylesheets│       └── style.css├── routes│   ├── index.js│   └── users.js└── views    ├── error.pug    ├── index.pug    └── layout.pug7 directories, 10 files<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="六、异步编程方案（Promise-amp-Async）"><a href="#六、异步编程方案（Promise-amp-Async）" class="headerlink" title="六、异步编程方案（Promise &amp; Async）"></a>六、异步编程方案（Promise &amp; Async）</h2><p>异步是Node得天独厚的特点和优势，但我们经常还是会需要解决同步执行的场景。如方法A执行完才可以执行方法B。如下面这个例子：</p><pre class="line-numbers language-javascript"><code class="language-javascript"><span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'A'</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">3000</span><span class="token punctuation">)</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'B'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>执行结果为:</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token punctuation">[</span>Running<span class="token punctuation">]</span> node <span class="token string">"test.js"</span>BA<span class="token punctuation">[</span>Done<span class="token punctuation">]</span> exited with code<span class="token operator">=</span>0 <span class="token keyword">in</span> 3.12 seconds<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>如果想要输出结果为 <code>A B</code>，可以采取 <code>Promise</code> 或 <code>Async</code> 来实现。</p><h3 id="基于Promise实现同步控制"><a href="#基于Promise实现同步控制" class="headerlink" title="基于Promise实现同步控制"></a>基于Promise实现同步控制</h3><p>Promise 是异步编程的一种解决方案，比传统的解决方案——回调函数和事件——更合理和更强大。ES6 原生提供了<code>Promise</code>对象，提供统一的 API，各种异步操作都可以用同样的方法进行处理。示例如下：</p><pre class="line-numbers language-javascript"><code class="language-javascript"><span class="token keyword">var</span> f <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'A'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">3000</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>f<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'B'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>err<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'Err'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>执行结果：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token punctuation">[</span>Running<span class="token punctuation">]</span> node <span class="token string">"test.js"</span>AB<span class="token punctuation">[</span>Done<span class="token punctuation">]</span> exited with code<span class="token operator">=</span>0 <span class="token keyword">in</span> 3.123 seconds<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>可以把 <code>Promise</code> 对象比喻为一个容器，里面有一个异步操作，<code>Promise</code> 容器只有在收到信号（resolve或者reject）时才会调用then方法。通过 <code>Promise.All</code>方法将多个Promise对象实例包装，生成并返回一个新的Promise实例，等执行完所有异步操作之后执行then方法：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">const</span> a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>  <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'A'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">3000</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">const</span> b <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>  <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'B'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">3000</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>Promise<span class="token punctuation">.</span><span class="token function">all</span><span class="token punctuation">(</span><span class="token punctuation">[</span>a<span class="token punctuation">,</span> b<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'end'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>执行结果如下：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token punctuation">[</span>Running<span class="token punctuation">]</span> node test.jsABend<span class="token punctuation">[</span>Done<span class="token punctuation">]</span> exited with code<span class="token operator">=</span>0 <span class="token keyword">in</span> 3.122 seconds<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="Promise-扩展信息"><a href="#Promise-扩展信息" class="headerlink" title="Promise 扩展信息"></a>Promise 扩展信息</h4><p><code>Promise</code> 构造函数接受一个函数作为参数，该函数两个参数分别是<code>resolve</code>和<code>reject</code>。它们是两个函数，由 avaScript 引擎提供。<code>resolve</code> 函数在异步操作成功时用，其作用是将<code>Promise</code>对象的状态从“pending”变为resolved”，并将异步操作的结果作为参数传递出去；<code>reject函数在异步操作失败时调用，其作用是将</code>Promise`对象的状态从pending”变为“rejected”，并将异步操作报出的错误作为参传递出去。</p><p> <code>Promise</code>实例生成以后，可以用<code>then</code>方法分别指定resolved<code>状态和</code>rejected<code>状态的回调函数。</code>then<code>方法以接受两个回调函数作为参数，第一个回调函数是</code>Promise<code>对的状态变为</code>resolved<code>时调用，第二个回调函数（可选提供）是Promise</code>对象的状态变为<code>rejected</code>时调用。这两个函数都受<code>Promise</code>对象传出的值作为参数。</p><p><img src="https://pic.lixl.cn/2020/20200308170211.png" alt="Promise状态转换图"></p><p> <code>Promise</code>对象有以下两个特点。</p><ul><li>对象的状态不受外界影响。<code>Promise</code>对象代表一个异步操作，有三种状态：<code>pending</code>（进行中）、<code>fulfilled</code>（已成功）和<code>rejected</code>（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。</li><li>一旦状态改变，就不会再变，任何时候都可以得到这个结果。<code>Promise</code>对象的状态改变，只有两种可能：从<code>pending</code>变为<code>fulfilled</code>和从<code>pending</code>变为<code>rejected</code>。只要这两种情况发生，状态就会一直保持不再改变,称为 resolved。</li></ul><p>下面是一个<code>Promise</code>对象的简单例子。</p><pre class="line-numbers language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">setTimeout</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span> <span class="token number">3000</span><span class="token punctuation">,</span> <span class="token string">'done.'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'A'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//会立即执行</span>  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span>result<span class="token punctuation">)</span> <span class="token punctuation">{</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token string">`resolve result: </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>result<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token keyword">function</span><span class="token punctuation">(</span>error<span class="token punctuation">)</span><span class="token punctuation">{</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token string">`reject error: </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>error<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面代码中，<code>f1</code>方法返回一个<code>Promise</code>实例，表示一段时以后才会发生的结果。过了指定的时间（3000毫秒）以后，Promise<code>实例的状态为</code>resolved<code>，就会触发</code>then`方法定的回调函数。执行结果如下:</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token punctuation">[</span>Running<span class="token punctuation">]</span> node <span class="token string">"test.js"</span>Aresolve result: done.<span class="token punctuation">[</span>Done<span class="token punctuation">]</span> exited with code<span class="token operator">=</span>0 <span class="token keyword">in</span> 3.175 seconds<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>另外，<code>resolve</code>函数的参数除了正常的值以外，还可能是另一个 Promise 实例。<code>then</code>方法是定义在原型对象<code>Promise.prototype</code>上的。返回的是一个新的<code>Promise</code>实例（注意，不是原来那个<code>Promise</code>实例）。因此可以采用链式写法，即<code>then</code>方法后面再调用另一个<code>then</code>方法。第一个回调函数完成以后，会将返回结果作为参数，传入第二个回调函数。</p><blockquote><p>Promise也有一些缺点。首先是无法取消，一旦新建它就会立即执行，无法中途取消；其次，如果不设置回调函数，Promise内部抛出的错误，不会反应到外部。第三，当处于pending状态时，无法得知目前进展到哪一个阶段。</p></blockquote><h3 id="基于Async实现同步控制"><a href="#基于Async实现同步控制" class="headerlink" title="基于Async实现同步控制"></a>基于Async实现同步控制</h3><p>ES2017 标准引入了 async 函数，使得异步操作变得更加方便。随着Node.js 8的发布，期待已久的async函数也在其中默认实现了。async 函数的实现原理，是将 Generator 函数和自动执行器，包装在一个函数里。</p><p><code>async</code>函数返回一个 Promise 对象，可以使用<code>then</code>方法添加回调函数。当函数执行的时候，一旦遇到<code>await</code>就会先返回，必须等到内部所有<code>await</code>命令后面的 Promise 对象执行完，才会发生状态改变（除非遇到<code>return</code>语句或者抛出错误），再接着执行函数体内后面的语句。看下面这个例子:</p><pre class="line-numbers language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span>resolve<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token function">setTimeout</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span> <span class="token number">3000</span><span class="token punctuation">,</span> <span class="token string">'Hello'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'A'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">asyncF</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">//前面的 `async` 关键字，表明该函数内部有异步操作。</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'B'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">await</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>value <span class="token operator">=</span><span class="token operator">></span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'C'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> value<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// return语句的返回值，会成为`then`方法回调函数的参数。</span><span class="token punctuation">}</span><span class="token function">asyncF</span><span class="token punctuation">(</span><span class="token string">'world'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>result <span class="token operator">=</span><span class="token operator">></span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>执行结果如下:</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token punctuation">[</span>Running<span class="token punctuation">]</span> node <span class="token string">"test.js"</span>B      <span class="token comment" spellcheck="true">#立即输出</span>A      <span class="token comment" spellcheck="true">#立即输出</span>Hello  <span class="token comment" spellcheck="true">#3秒后输出</span>Cworld<span class="token punctuation">[</span>Done<span class="token punctuation">]</span> exited with code<span class="token operator">=</span>0 <span class="token keyword">in</span> 3.165 seconds<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> <code>async</code> 函数的<code>await</code>命令后面，可以是 Promise 对象或原始类型的值（数值、字符串和布尔值，但会自动转成立即 resolved 的 Promise 对象）。</p><p> <code>sync</code>函数内部抛出错误，会导致返回的 Promise 对象变为<code>reject</code>状态。抛出的错误对象会被<code>catch</code>方法回调函数接收到。如下面这个例子：</p><pre class="line-numbers language-javascript"><code class="language-javascript"> <span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">'发生异常'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span> result <span class="token operator">=</span><span class="token operator">></span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token string">`resolve result: </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>result<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">,</span> error <span class="token operator">=</span><span class="token operator">></span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>error<span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> 执行结果：</p><pre class="line-numbers language-bash"><code class="language-bash"> <span class="token punctuation">[</span>Running<span class="token punctuation">]</span> node <span class="token string">"test.js"</span> Error: 发生异常  at f <span class="token punctuation">(</span>/Users/lixl.cn/nodework/blog/test.js:4:9<span class="token punctuation">)</span>  at Object.<span class="token operator">&lt;</span>anonymous<span class="token operator">></span> <span class="token punctuation">(</span>/Users/lixl.cn/nodework/blog/test.js:7:1<span class="token punctuation">)</span>  at Module._compile <span class="token punctuation">(</span>internal/modules/cjs/loader.js:701:30<span class="token punctuation">)</span>  at Object.Module._extensions<span class="token punctuation">..</span>js <span class="token punctuation">(</span>internal/modules/cjs/loader.js:712:10<span class="token punctuation">)</span>  at Module.load <span class="token punctuation">(</span>internal/modules/cjs/loader.js:600:32<span class="token punctuation">)</span>  at tryModuleLoad <span class="token punctuation">(</span>internal/modules/cjs/loader.js:539:12<span class="token punctuation">)</span>  at Function.Module._load <span class="token punctuation">(</span>internal/modules/cjs/loader.js:531:3<span class="token punctuation">)</span>  at Function.Module.runMain <span class="token punctuation">(</span>internal/modules/cjs/loader.js:754:12<span class="token punctuation">)</span>  at startup <span class="token punctuation">(</span>internal/bootstrap/node.js:283:19<span class="token punctuation">)</span>  at bootstrapNodeJSCore <span class="token punctuation">(</span>internal/bootstrap/node.js:622:3<span class="token punctuation">)</span> <span class="token punctuation">[</span>Done<span class="token punctuation">]</span> exited with code<span class="token operator">=</span>0 <span class="token keyword">in</span> 0.153 seconds<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="七、基于ESLint保障质量"><a href="#七、基于ESLint保障质量" class="headerlink" title="七、基于ESLint保障质量"></a>七、基于ESLint保障质量</h2><p>JavaScript 是一个动态的弱类型语言，在开发中比较容易出错，一般会借助 Lint 工具来保障质量。</p><p><code>ESLint</code> 是新一代开源 JavaScript 代码检查工具，使用 Node.js 编写，常用于寻找有问题的模式或者代码，并且不依赖于具体的编码风格。</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 全局安装 ESLint</span><span class="token function">npm</span> <span class="token function">install</span> -g eslint<span class="token comment" spellcheck="true"># 进入项目</span><span class="token function">cd</span> ~/NodeWork/NodeDemo<span class="token comment" spellcheck="true"># 初始化 package.json</span><span class="token function">npm</span> init -f<span class="token comment" spellcheck="true"># 初始化 ESLint 配置</span>eslint --init<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>通过 Lint 工具可以让我们：</p><ul><li>避免低级bug，找出可能发生的语法错误</li><li>提示删除多余的代码</li><li>确保代码遵循最佳实践 (可参考 <a href="https://github.com/airbnb/javascript" target="_blank" rel="noopener">airbnb style</a>、<a href="https://github.com/standard/standard" target="_blank" rel="noopener">javascript standard</a>)</li><li>统一团队的代码风格</li></ul><p>项目初始化完毕，可以开始在 <code>ESLint</code> 的提示下，高质量编写代码了。</p><h2 id="八、参考"><a href="#八、参考" class="headerlink" title="八、参考"></a>八、参考</h2><ul><li>Node官方文档：<a href="https://nodejs.org/zh-cn/docs/" target="_blank" rel="noopener">https://nodejs.org/zh-cn/docs/</a></li><li>express官网：<a href="http://www.expressjs.com.cn/" target="_blank" rel="noopener">http://www.expressjs.com.cn/</a></li><li>ESLint官方指南： <a href="https://cn.eslint.org/docs/user-guide/getting-started" target="_blank" rel="noopener">https://cn.eslint.org/docs/user-guide/getting-started</a></li><li>深入浅出Node.js：<a href="https://book.douban.com/subject/25768396/" target="_blank" rel="noopener">https://book.douban.com/subject/25768396/</a></li><li>ECMAScript 6 入门：<a href="http://es6.ruanyifeng.com/" target="_blank" rel="noopener">http://es6.ruanyifeng.com/</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 后端技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Node.js </tag>
            
            <tag> npm </tag>
            
            <tag> nvm </tag>
            
            <tag> Promise </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>利用AutoSSH建立SSH隧道，实现内网穿透</title>
      <link href="/2020/010618877.html"/>
      <url>/2020/010618877.html</url>
      
        <content type="html"><![CDATA[<p>当我们使用公司或家中电脑搭建了 Web 服务时，一般不能直接从外网访问，为了实现从外网直接访问到内网的服务，一般会需要用到 <strong>内网穿透</strong> 技术。常用的内网穿透工具有 NAT 转发、DMZ 主机、AutoSSH、ngrok、frp、花生壳等。下面将会介绍如何通过 SSH 端口转发，使内网主机 A 的服务转发至公网主机 B 上。</p><h3 id="需要条件"><a href="#需要条件" class="headerlink" title="需要条件"></a>需要条件</h3><p>​ 一台内网主机 A，一台 Linux 公网主机 B。下文以 CentOS7 系统为例。</p><h3 id="第一步：公网服务器配置"><a href="#第一步：公网服务器配置" class="headerlink" title="第一步：公网服务器配置"></a>第一步：公网服务器配置</h3><p>​ 修改公网主机 B 的 SSH 配置文件<code>/etc/ssh/sshd_config</code></p><pre><code>GatewayPorts yes</code></pre><p>​ 这样可以把监听的端口绑定到任意 IP 0.0.0.0 上，否则只有本机 127.0.0.1 可以访问。</p><p>​ 重启 sshd 服务</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">service</span> sshd restart<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="第二步：安装-AutoSSH-服务"><a href="#第二步：安装-AutoSSH-服务" class="headerlink" title="第二步：安装 AutoSSH 服务"></a>第二步：安装 AutoSSH 服务</h3><p>在内网主机 A 上，执行以下命令安装 AutoSSH</p><pre class="line-numbers language-bash"><code class="language-bash">yum <span class="token function">install</span> autossh<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="第三步：断线免密登录自动重连"><a href="#第三步：断线免密登录自动重连" class="headerlink" title="第三步：断线免密登录自动重连"></a>第三步：断线免密登录自动重连</h3><p>​ ssh 反向链接会因为超时而关闭，如果关闭了那从外网连通内网的通道就无法维持，为此我们需要结合免密码登录及 AutoSSH 来提供稳定的 ssh 反向代理隧道。</p><p>​ 1、在内网主机 A 上产生公钥和私钥</p><pre class="line-numbers language-bash"><code class="language-bash">ssh-keygen<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>然后按三次回车执行默认选项生成公钥和私钥。会生成密钥文件和私钥文件 id_rsa,id_rsa.pub 或 id_dsa,id_dsa.pub</p><p>​ 2、拷贝秘钥<br>   在内网主机 A 上继续执行如下命令，将内网主机 A 上的秘钥文件 copy 到公网主机 B 中。</p><pre class="line-numbers language-bash"><code class="language-bash">ssh-copy-id  username@ip<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>其中“username”是公网主机 B 的用户名，ip 为公网主机 B 的 ip，然后按照提示输入公网主机 B 的密码就完成了。</p><h3 id="第四步：利用-AutoSSH-实现端口转发"><a href="#第四步：利用-AutoSSH-实现端口转发" class="headerlink" title="第四步：利用 AutoSSH 实现端口转发"></a>第四步：利用 AutoSSH 实现端口转发</h3><p>在内网主机 A 上，利用 AutoSSH 建立一条 SSH 隧道</p><pre class="line-numbers language-bash"><code class="language-bash"> autossh -M 4010 -NR 80:localhost:4000 username@xxx.xxx.xxx.xxx <span class="token punctuation">(</span>-p xxxx<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​ <strong>参数解释：</strong></p><ul><li>“-M 4010”意思是使用内网主机 A 的 4010 端口监视 SSH 连接状态，连接出问题了会自动重连</li><li>“ -N”意思是不执行远程命令</li><li>“-R”意思是将远程主机（公网主机 B）的某个端口转发到本地指定机器的指定端口</li></ul><p>​ <strong>代码解释：</strong></p><ul><li><p>“80:localhost:4000”意思是将内网主机 A 的 4000 号端口转发至公网主机 B 的 80 号端口上</p></li><li><p>“username@xxx.xxx.xxx.xxx”意思是公网主机 B 的用户名和 IP</p></li><li><p>“-p xxxx”意思是公网主机 B 的 SSH 端口，如果是默认的 22 号端口，则可以不输入.</p></li></ul><h3 id="第五步：监听端口检查"><a href="#第五步：监听端口检查" class="headerlink" title="第五步：监听端口检查"></a>第五步：监听端口检查</h3><p>​ 分别检查本地主机 A 及公网主机 B 的端口监听情况，出现如下进程则为正常。</p><p>​ 本地主机 A：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@localhost ~<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># lsof -i:4010</span>COMMAND   PID    USER   FD   TYPE             DEVICE SIZE/OFF NODE NAME<span class="token function">ssh</span>      6710 lixl    5u  IPv6 0x15699cecfe8a4995      0t0  TCP localhost:altserviceboot <span class="token punctuation">(</span>LISTEN<span class="token punctuation">)</span>autossh 46984 lixl    3u  IPv4 0x15699cece41d5e95      0t0  TCP localhost:altserviceboot <span class="token punctuation">(</span>LISTEN<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>​ 远程主机 B：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@localhost ~<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># lsof -i:8080</span>COMMAND  PID USER   FD   TYPE DEVICE SIZE/OFF NODE NAMEsshd    9762 root   10u  IPv4 473994      0t0  TCP *:webcache <span class="token punctuation">(</span>LISTEN<span class="token punctuation">)</span>sshd    9762 root   11u  IPv6 473995      0t0  TCP *:webcache <span class="token punctuation">(</span>LISTEN<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="第六步：开启自启动"><a href="#第六步：开启自启动" class="headerlink" title="第六步：开启自启动"></a>第六步：开启自启动</h3><p>​ 配置 AutoSSH 开机自启动，输入：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">vi</span> /etc/rc.d/rc.local<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​ 添加内容:</p><pre class="line-numbers language-bash"><code class="language-bash">autossh -M 4010 -fCNR 80:localhost:4000 username@xxx.xxx.xxx.xxx <span class="token punctuation">(</span>-p xxxx<span class="token punctuation">)</span><span class="token function">chmod</span> +x /etc/rc.d/rc.local<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>​ centos7 之后，修改/etc/rc.d/rc.local 启动脚本需要重新赋予可执行权限。</p><p>​ 至此完成了端口转发，在相应的应用（如浏览器）中输入公网服务器 B 的 IP+端口即相当于直接访问内网主机 A 的相应服务，大功告成！</p><h3 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h3><ul><li>配置完通过外网 IP 加端口无法访问： 请检查公网服务器防火墙是否开放响应端口。</li><li>本地服务重启后，通过外部端口无法访问：这种情况是由于没有检测到通道之前已经断开，AutoSSH 应该有类似的机制，还没有仔细研究。</li></ul><h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><ul><li><a href="https://www.jianshu.com/p/7accc1e485d3" target="_blank" rel="noopener">https://www.jianshu.com/p/7accc1e485d3</a></li><li><a href="https://blog.csdn.net/weixin_36394852/article/details/72725505" target="_blank" rel="noopener">https://blog.csdn.net/weixin_36394852/article/details/72725505</a></li><li><a href="https://blog.csdn.net/zll_0405/article/details/81208606" target="_blank" rel="noopener">https://blog.csdn.net/zll_0405/article/details/81208606</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AutoSSH </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DDD领域驱动设计</title>
      <link href="/2019/122036340.html"/>
      <url>/2019/122036340.html</url>
      
        <content type="html"><![CDATA[<p><a href="https://s.geekbang.org/search/c=2/k=DDD/t=" target="_blank" rel="noopener">DDD</a>和 DSL、DCI 的关系是什么？开发团队为何需要 DDD？它与微服务与中台又有着怎样的联系？目前业界实践 DDD 最大的问题是什么？11 月 30 日，在由 ThoughtWorks 举办的领域驱动设计峰会 <a href="http://www.ddd-china.com/speaker-info.html" target="_blank" rel="noopener">DDD-China 2019</a>上，InfoQ 记者带着这些问题对中兴通讯资深软件架构师张晓龙进行了采访。</p><h2 id="DDD、DSL-和-DCI"><a href="#DDD、DSL-和-DCI" class="headerlink" title="DDD、DSL 和 DCI"></a>DDD、DSL 和 DCI</h2><p>DDD 概念最早提出于 2004 年，作为一种软件开发的指导思想，DDD 对软件开发带来了诸多可能与方向，张晓龙认为 DDD 为软件开发带来的好处主要有以下几点：</p><ul><li>首先，最大好处就是所有参与者围绕一个统一一致的领域模型工作，传统的分析模型和设计模型不再割裂，不管是做设计、做分析还是写代码、写文档，脑海中所构建的画面都是一致的。</li><li>第二，DDD 是一个软件开发过程，它显式地把领域和设计放到了软件开发的核心，软件人员和业务人员被受到同样的重视，他们合作来构建领域模型，使得软件的交付质量更高且维护成本更低；</li><li>第三，DDD 提出的分层架构，有效分离了业务复杂度和技术复杂度，凸显了领域模型，使得领域层的代码和领域模型保持高度一致；</li><li>第四，统一语言非常重要，每个概念在各自的上下文中是清晰的无歧义的，同时要控制领域模型的复杂度，于是 DDD 在战略上提出了分离子域（问题域空间）和拆分 BC（解决方案空间）的模式，BC 间通过 Context Mapping 来集成；</li><li>第五，DDD 在战术层面提出了很多模式（聚合，实体，值对象，服务，工厂，仓储），对领域模型中的元素进行了分类，并给出了每类元素在领域模型中的职责和特征，降低了领域模型的构建成本。</li></ul><p>张晓龙此前曾在 DDD-China 峰会和<a href="https://archsummit.infoq.cn/2019/beijing/" target="_blank" rel="noopener">ArchSummit 全球架构师峰会</a>上分别做过《当 DDD 遇上 DSL（Domain-Specific Language）》、《当 DDD 遇上 DCI（Data，Context， Interactive）》的演讲，在他看来，DDD 和 DSL、DCI 之间存在极强的关联性。</p><p>DDD 和 DSL 的融合有三点：</p><ol><li>面向领域；</li><li>模型的组装方式；</li><li>分层架构演进。</li></ol><p>DSL 可以看作是在领域模型之上的一层外壳，可以显著增强领域模型的能力。它的价值主要有两个，一是提升了开发人员的生产力，二是增进了开发人员与领域专家的沟通。举个例子：想让 BA 负责流程契约的设计，该流程契约是一个活文档，可以跑测试，而 BA 不熟悉宿主语言。于是，我们设计了一种外部 DSL 来专门描述流程契约，对 BA 非常友好，学习成本也很低（不超过 5 分钟就可以学会），最后发现 BA 很快就广泛使用了起来。外部 DSL 并不一定要定义新文法，我们直接复用了 plantUML 文法，安装该插件可以自动生成序列图，非常棒！对于外部 DSL，需要自己实现一个解析器将 DSL 文法解析成语法树，再根据语法树生成语义模型。语义模型可以看作领域模型（严格的讲语义模型是领域模型的子集），外部 DSL 就是对领域模型的一种组装方式。</p><p>DCI 的作用主要体现在两方面：</p><p>首先，DCI 助力 DDD 战术设计：</p><ol><li>显式地对 ROLE 建模，解决了贫血模型与充血模型之争；</li><li>一个聚合可以支持哪些 ROLE，一个 ROLE 可以由哪些聚合扮演，一个场景下哪些聚合要扮演哪些角色；</li><li>当 Aggregate 内部实体行为比较多时可以嵌套使用 DCI 来拆分和组合；</li></ol><p>其次，DCI 助力 DDD 代码落地：</p><ol><li>对象就是 Data，Client 为 Context，对象在 Client 中的行为就是 ROLE。</li><li>根据正交设计原则得到小类（素材库），根据多重继承（only C++）或依赖注入来组合素材，不管是行为类还是数据类，都按 Role 的方式来组合，对像仅仅组合 Role 并注入依赖；</li><li>小类大对象：类作为一种模块化手段，遵循高内聚，低耦合，让软件易于应对变化；对象作为一种领域对象的的直接映射，解决了过多的类带来的可理解性问题，让领域可以指导设计，设计真正反映领域；领域对象需要真正意义上的生命周期管理。</li></ol><p>张晓龙认为，DCI 对一些开发人员的影响可能比 DDD 和 DSL 还大，因为开发人员每天都在不断倒腾代码，想让代码的组合性更强，以便快速应对需求的变化。</p><h2 id="开发团队真的需要-DDD"><a href="#开发团队真的需要-DDD" class="headerlink" title="开发团队真的需要 DDD"></a>开发团队真的需要 DDD</h2><p>DDD 思想贯穿了整个软件开发的生命周期，包括对需求的分析、建模、架构、设计，和最终的代码实现，甚至对代码的测试与重构。代码是业务的核心资产，不管是否特性团队，开发团队肯定是代码的编写者和守护者。</p><p>对于开发团队而言，需要关注以下几点：</p><ul><li>首先是统一语言，让团队成员可以做到无障碍的沟通，不管是什么角色都能基于同样的画面进行讨论；</li><li>其次是团队中各个角色都围绕领域模型开展工作；</li><li>第三是代码物理设计容易标准化，比如说在分层设计时，基础设施层怎么设计，应用层怎么设计，DTO 应该放在哪儿，领域层中各个建模元素如何组织？</li></ul><p>更进一步，在分层架构里，应用层更加关注横切面的东西，比如说要上报一个告警，要给用户发送一个 Email，这些最好都集中放到应用层里面。但触发是在领域层发生的，应用层怎么知道？通过领域事件来实现依赖反转，即应用层订阅领域事件，领域层发布领域事件。</p><p>在中兴通讯，核心业务属于通信行业，DDD 的应用场景跟互联网企业有着很大差别：</p><ol><li>嵌入式软件；</li><li>兼业务复杂性和技术复杂性；</li><li>软件规模大，功能复杂，特性交叉；</li><li>高质量，高性能，高可靠等要求。</li></ol><p>张晓龙举例提到，中兴通讯在开发团队中实践 DDD 的经验具体而言有以下几点：</p><ol><li>领域专家下团队，和团队一起交流和协作；</li><li>教练指导，开展战训营，定期 review；</li><li>架构、设计、编码和工程实践：（1）DCI，DSL，正交设计，组合式设计；（2）编码规范和纪律；（3）嵌入式 C/C++ 最佳实践；（4）软件工程能力：开发者测试，小步安全流畅的重构，持续交付流水线，每日 Code Review。</li></ol><h2 id="DDD-与微服务"><a href="#DDD-与微服务" class="headerlink" title="DDD 与微服务"></a>DDD 与微服务</h2><p>DDD 概念提出距今已经有 15 年的历史，前十年时间都一直处于不温不火的状态，而在最近几年才开始大行其道。张晓龙表示，中兴通讯在 2012-2015 年期间也有过一些成功的案例，但对于整个业界来说了解的人并不多。他拿 DDD-China 峰会举例解释：这次峰会的参会者有 500 人的规模，而我们假设峰会在 2015 年之前举办的话，估计参会者不会超过 100 人。因此，我们可以断定是<a href="https://s.geekbang.org/search/c=2/k=微服务/t=" target="_blank" rel="noopener">微服务</a>的热风让人们重新发现了领域驱动设计的价值。</p><p>微服务架构从提出以来一直没有很好的理论支撑如何合理地划分服务边界，人们常常为服务要划分多大而争吵不休。而 DDD 被发现恰好可以弥补微服务的营养不良：（1）服务最大不要大过一个 BC，否则服务内可能会存在有歧义的领域概念；（2）服务最小不要小过一个聚合，否则会引入分布式事务的复杂度；（3）服务间最好通过 Domain Event 来进行交互，这样可以让服务保持松耦合。微服务和 DDD 的结合，让微服务架构看起来似乎更加稳健了。</p><p>“微服务就像是 DDD 的心上人，使得 DDD 真正焕发起了青春。”张晓龙这样解释。</p><p>对于业界目前流行的<a href="https://s.geekbang.org/search/c=2/k=中台/t=" target="_blank" rel="noopener">中台</a>概念，张晓龙同样也有自己的看法：</p><p>中台和 DDD 不是同一个层面的东西，不能为了把它们联系在一起，而强行找相似点。中台实际上就是多条业务线的共同需求，比如对于滴滴公司来说，快车、专车和出租车等业务都是微服务架构，这些业务的很多服务是相似的，考虑将这些服务从各个前台下沉到统一的平台，这个平台就是中台。中台要考虑各个前台的需求，所以复杂性变高了。</p><p>中台是一种企业级的架构模式，从企业全局整体视角来看架构全貌，而 DDD 是一种主流的软件开发方法，用来应对软件的核心复杂性。中台架构可以看作是微服务架构的延伸和发展，服务复杂性很高，所以更需要用 DDD 的方式去设计和建模，但二者之间并不是相同层面的概念。</p><h2 id="DDD-的困局"><a href="#DDD-的困局" class="headerlink" title="DDD 的困局"></a>DDD 的困局</h2><p>最近几年 DDD 的火爆也给业界开发团队带来了一些迷思，为什么我的 DDD 推行不下去？为什么我的 DDD 做起来总是跟敏捷一样，最后都变了味？</p><p>张晓龙总结了 DDD 目前面临的几大困局：</p><ul><li>首先是领域案例面比较窄。目前业界的 DDD 实践案例并不多，而且很多案例是偏向互联网领域的，对于工业领域、嵌入式领域和操作系统领域基本没有涉及；</li><li>第二，DDD 书籍非常少，而且大多数书籍是以 Java 或 C#写的。如果开发团队用的是 C、C++、Python 或 Go 语言，基本没有可参考的书籍，难度也就更大一些（尤其是 C 和 C++）；</li><li>第三，各个巨头公司，比如 Google，微软，BAT 等，很少组织、参与或赞助 DDD 峰会，没有形成引导作用，业界自然也就少有跟随效应；</li><li>第四，开发团队要么找不到领域专家，要么领域专家无法与开发团队长时间保持沟通，导致实践中出现偏差；</li><li>第五，DDD 落地有一定的门槛，对开发者的技能和素质都有较高的要求。</li></ul><p>针对以上几大困局，张晓龙也给出了自己的解决方案：</p><ol><li>培训 OOA、OOD 和 OOP 的基本知识，并实战演练，不断弥补与高手的 gap ；</li><li>领域专家和团队一起工作，确保大家头脑中的画面是一致的；</li><li>DDD 建模要有文档交付物，并和代码同步演进，以便对代码不熟悉的人员也能看到并理解领域驱动设计成果的全貌。</li></ol><p>软件开发没有银弹，DDD 也不是万能的。如果开发团队真的决定用 DDD 的思想指导软件开发，就一定要跟随时代的脚步，吃透 DDD 这个旧瓶里装的新酒。</p>]]></content>
      
      
      <categories>
          
          <category> 软件设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计原则与模式 </tag>
            
            <tag> 领域驱动设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>物流、商流、资金流、信息流之间的关系</title>
      <link href="/2019/121252656.html"/>
      <url>/2019/121252656.html</url>
      
        <content type="html"><![CDATA[<p>物流、商流、资金流和信息流是流通过程的四大组成部分，这四者构成了一个流通过程。几者的关系“互为存在、相互作用、密不可分”，既相互独立，又是一个综合体。将物流、商流、资金流和信息流有机结合起来，会产生更大的能量，创造更大的经济效益。</p><p>所谓商流，就是一种买卖或者说是一种交易活动过程，通过商流活动发生商品所有权的转移。</p><p>商流是物流、资金流和信息流的起点，也可以说是后”三流”的前提，没有商流一般不可能发生物流、资金流和信息流。反过来，没有物流、资金流和信息流的匹配和支撑，商流也不可能达到目的。”四流”之间有时是互为因果关系。</p><p>比如，A企业与B企业经过商谈，达成了一笔供货协议，确定了商品价格、品种、数量、供货时间、交货地点、运输方式等，并签订了合同，也可以说商流活动开始了。要认真履行这份合同，自然要进入物流过程，将货物进行包装、装卸、保管和运输。同时伴随着信息传递活动。如果商流和物流都顺利进行了，接下来是付款和结算，即进入资金流的过程。无论是买卖交易，还是物流和资金流，这三大过程中都离不开信息的传递和交换，没有及时的信息流，就没有顺畅的商流、物流和资金流。没有资金支付，商流不会成立，物流也不会发生。</p><p>可以讲。商流是动机和目的，资金流是条件，信息流是手段，物流是终结和归缩。</p><p>就是说由于需要或产生购买欲望，才决定购买，购买的原因和理由就是商流的动机和目的；因为想购买或决定购买某种商品，才考虑购买资金的来源或筹措资金问题。不付款商品的所有权就不归你，这就是条件；又因为决定购买，也有了资金，然后才付之行动，这就是买主要向卖主传递一个信息，或去商店向售货员传递购买信息，或电话购物、网上购物，这些都是信息传递的过程，但这种过程只是一种手段；然而，商流、资金流和信息流产生后，必须有一个物流的过程，否则商流、资金流和信息流都没有意义。</p><p>举个例子，一个单位搬进新办公地点后要购买几台空调，这个单位可能直接去商店选购，也可能打电话或网上采购，就产生了商流活动。由此也伴生出资金流(如现金支付，支票付款或银行走账)和信息流。可是只完成这”三流”，并不是事物的完结，还必须将空调送至买主，最终还是少不了运输、装卸等物流过程。</p><p>那么。怎样才能保证将卖出去的空调按买主要求的时间、地点和数量，准确、完全地送货上门呢？</p><p>首先，出售空调的商店里有库存，或者商店给厂家打电话，让厂家从仓库取货。无论从商店取货，还是从仓库取货，都需要有车将空调送过去，如果销售量过于集中，车子跑不过来，或者司机调整不过来怎么办？如果仓库里缺这种型号的空调又怎么办？看来，这都属于物流的问题。</p><p>再往复杂一些说，假如空调厂家对空调的销售量预测的不准确，预测的销售大干实际需要，就产生库存积压，浪费仓库保管费，多占压生产资金。假如预测的销售量小于实际需要，则不仅少赚利润，失去市场，而且还可能影响企业声望。怎样才能既不浪费保管费和占压资金，又能保证供货呢？除了准确的市场需求预测，及时掌握各种信息外，还要构筑一个先进、合理的物流系统。首先要进行商品的需求、购买力、市场容量、销售时点、销售数量等基础性调查研究。然后，再制定一个与商流相配套的物流规划。根据市场情况，决定建几个配适中心，建多大规模，如何构筑配送网络等等。</p><p>因为物流是受商流制约，随商流变化而变化，往往为了占领市场、扩大销售而牺牲物流利益的，所以，在竞争激烈的商品经济社会要加强对物流问题的研究，加强对信息技术等现代科学手段的充分利用。</p><p>商流和资金流是传统性的经济活动，规则性强，已经比较成熟和定型，进一步的科学化管理受时代和经济发展水平限制。信息流主要依赖互联网，由计算机支持，是电子化传输和软件开发问题。这方面的竞争会不断加剧和复杂化，各企业的技术水平将来也会彼此接近。</p><p>前几年兴起的电子商务热，之所以急剧降温，是因 “物流瓶颈”造成的，而不是信息技术自身的问题。而且，商流、资金流和信息流将来都可能由计算机和网络通信部分替代，只有物流难以做到这一点。而旦物流又最落后，物流发展的空间比商流、资金流和信息流要大，合理化、科学化管理的余地要大，节约费用的潜力要大。这是因为：</p><ul><li><p>第一，物流是一门新兴科学，很多人对物流基本知识、物流理论、物流的重要作用、重视物流的必要性和必然性还了解不多，还需要一个认识过程。物流与商流、资金流以及信息流相比，发展滞后。进度缓慢，如不及时超上，要拖其他”三流”的后腿。同时也说明，物流的发展因过去是一流空白，是”黑暗的大陆”。因此它的发展空间也就更大。</p></li><li><p>第二，物流在商品总成本中的费用比例大，过去不受重视，这块庞大的成本，只要我们稍加努力，就会有利可图。这块”第三利润源泉”，是新经济时代最有前景的领域，是节约费用最大的空间。</p></li><li><p>第三，物流发展时间尚短，成熟程度差，物流管理科学化较低。只要我们认识到这一点，认真对待，大力加强对物流的管理，就能大大提高物流生产效率，大幅度增加经济效益。</p></li><li><p>第四，过去还很少有人将物流与商流、资金流、信息流联系起来考虑。也没有将”四流”做为一个大系统对待。今后如果真正把”四流”统一起来、协调起来，那将产生不可估量的效益。目前的主要矛盾表现在物流和信息流两个方面。</p></li></ul><p>在此我们有必要强调，商流、物流、资金演、信息流，虽然各有独立存在的意义，并各有自身的运行规律，但是，”四流”是一个相互联系、互为伴随、共同支撑流通活动的整体。在认识和研究流通经济，或者在进行物流管理过程中一定要把握这一点，以使我们认识问题全面化、科学化，把物流工作做得更有成效。</p>]]></content>
      
      
      <categories>
          
          <category> 产融科技 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 供应链 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Typora 常用快捷键（翻译）</title>
      <link href="/2019/120219385.html"/>
      <url>/2019/120219385.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>原文发表于个人博客 <a href="https://www.lixl.cn">悟尘记</a>，获取更新内容请查看： <a href="https://www.lixl.cn/2020/031019385.html">https://www.lixl.cn/2020/031019385.html</a></p></blockquote><h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>您可以使用快捷键快速插入或修改样式，或者执行 Typora 支持的其他操作。</p><p>您可以在菜单栏中的每个菜单项的右侧找到快捷键。</p><h2 id="常用快捷键"><a href="#常用快捷键" class="headerlink" title="常用快捷键"></a>常用快捷键</h2><h3 id="自动完成"><a href="#自动完成" class="headerlink" title="自动完成"></a>自动完成</h3><p>在macOS上，您可以按Esc键打开内联数学预览、自动完成表情符号等功能。</p><h3 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h3><table><thead><tr><th align="left">功能</th><th align="left">Windows / Linux</th><th>macOS</th></tr></thead><tbody><tr><td align="left">新建</td><td align="left">Ctrl + N</td><td>Command + N</td></tr><tr><td align="left">新窗口</td><td align="left">Ctrl + Shift + N</td><td>Command + Shift + N</td></tr><tr><td align="left">新标签</td><td align="left"><em>（不支持）</em></td><td>Command + T</td></tr><tr><td align="left">打开</td><td align="left">Ctrl + O</td><td>Command + O</td></tr><tr><td align="left">快速打开</td><td align="left">Ctrl + P</td><td>Command + Shift + O</td></tr><tr><td align="left">重新打开已关闭文件</td><td align="left">Ctrl + Shift + T</td><td>Command + Shift + T</td></tr><tr><td align="left">保存</td><td align="left">Ctrl + S</td><td>Command + S</td></tr><tr><td align="left">另存为/复制</td><td align="left">Ctrl + Shift + S</td><td>Command + Shift + S</td></tr><tr><td align="left">偏好</td><td align="left">Ctrl + ，</td><td>Command + ，</td></tr><tr><td align="left">关闭</td><td align="left">Ctrl + W</td><td>Command + W</td></tr></tbody></table><h3 id="编辑"><a href="#编辑" class="headerlink" title="编辑"></a>编辑</h3><table><thead><tr><th align="left">功能</th><th align="left">Windows / Linux</th><th>macOS</th></tr></thead><tbody><tr><td align="left">新段落</td><td align="left">Enter</td><td>Enter</td></tr><tr><td align="left">新线</td><td align="left">Shift + Enter</td><td>Shift + Enter</td></tr><tr><td align="left">剪切</td><td align="left">Ctrl + X</td><td>Command + X</td></tr><tr><td align="left">复制</td><td align="left">Ctrl + C</td><td>Command + C</td></tr><tr><td align="left">粘贴</td><td align="left">Ctrl + V</td><td>Command + V</td></tr><tr><td align="left">复制为 Markdown</td><td align="left">Ctrl + Shift + C</td><td>Command + Shift + C</td></tr><tr><td align="left">粘贴为纯文本</td><td align="left">Ctrl + Shift + V</td><td>Command + Shift + V</td></tr><tr><td align="left">全选</td><td align="left">Ctrl + A</td><td>Command + A</td></tr><tr><td align="left">选择行/句子 <br />选择行（在表中）</td><td align="left">Ctrl + L</td><td>Command + L</td></tr><tr><td align="left">删除行（在表中）</td><td align="left">Ctrl + Shift +退格键</td><td>Command + Shift + 退格键</td></tr><tr><td align="left">选择样式范围<br />选择单元格（在表中）</td><td align="left">Ctrl + E</td><td>Command + E</td></tr><tr><td align="left">选择单词</td><td align="left">Ctrl + D</td><td>Command + D</td></tr><tr><td align="left">删除单词</td><td align="left">Ctrl + Shift + D</td><td>Command + Shift + D</td></tr><tr><td align="left">跳到顶部</td><td align="left">Ctrl +Home</td><td>Command + ↑</td></tr><tr><td align="left">跳至选择</td><td align="left">Ctrl + J</td><td>Command + J</td></tr><tr><td align="left">跳到底部</td><td align="left">Ctrl + End</td><td>Command + ↓</td></tr><tr><td align="left">查找</td><td align="left">Ctrl + F</td><td>Command + F</td></tr><tr><td align="left">查找下一个</td><td align="left">F3 / Enter</td><td>Command + G / Enter</td></tr><tr><td align="left">查找上一个</td><td align="left">Shift + F3 / Shift + Enter</td><td>Command + Shift + G / Shift + Enter</td></tr><tr><td align="left">替换</td><td align="left">Ctrl + H</td><td>Command + H</td></tr></tbody></table><h3 id="段落"><a href="#段落" class="headerlink" title="段落"></a>段落</h3><table><thead><tr><th align="left">功能</th><th align="left">Windows / Linux</th><th>macOS</th></tr></thead><tbody><tr><td align="left">标题 1 至 6</td><td align="left">Ctrl + 1/2/3/4/5/6</td><td>Command + 1/2/3/4/5/6</td></tr><tr><td align="left">段落</td><td align="left">Ctrl + 0</td><td>Command + 0</td></tr><tr><td align="left">增加标题级别</td><td align="left">Ctrl + =</td><td>Command + =</td></tr><tr><td align="left">降低标题级别</td><td align="left">Ctrl +-</td><td>Command + -</td></tr><tr><td align="left">表</td><td align="left">Ctrl + T</td><td>Command + Option + T</td></tr><tr><td align="left">代码围栏</td><td align="left">Ctrl + Shift + K</td><td>Command + Option + C</td></tr><tr><td align="left">数学块</td><td align="left">Ctrl + Shift + M</td><td>Command + Option + B</td></tr><tr><td align="left">引用</td><td align="left">Ctrl + Shift + Q</td><td>Command + Option + Q</td></tr><tr><td align="left">有序列表</td><td align="left">Ctrl + Shift + [</td><td>Command + Option + O</td></tr><tr><td align="left">无序列表</td><td align="left">Ctrl + Shift +]</td><td>Command + Option + U</td></tr><tr><td align="left">缩进</td><td align="left">Ctrl + [ / Tab</td><td>Command + [ / Tab</td></tr><tr><td align="left">突出</td><td align="left">Ctrl +] / Shift + Tab</td><td>Command +] / Shift + Tab</td></tr></tbody></table><h3 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h3><table><thead><tr><th align="left">功能</th><th align="left">Windows / Linux</th><th>macOS</th></tr></thead><tbody><tr><td align="left">加粗</td><td align="left">Ctrl + B</td><td>Command + B</td></tr><tr><td align="left">重点</td><td align="left">Ctrl + I</td><td>Command + I</td></tr><tr><td align="left">下划线</td><td align="left">Ctrl + U</td><td>Command + U</td></tr><tr><td align="left">代码</td><td align="left">Ctrl + Shift + `</td><td>Command + Shift + `</td></tr><tr><td align="left">Strike</td><td align="left">Alt + Shift + 5</td><td>Ctrl + Shift + `</td></tr><tr><td align="left">超链接</td><td align="left">Ctrl + K</td><td>Command + K</td></tr><tr><td align="left">图片</td><td align="left">Ctrl + Shift + I</td><td>Command + Control + I</td></tr><tr><td align="left">清除格式</td><td align="left">Ctrl + \</td><td>Comand + \</td></tr></tbody></table><h3 id="查看"><a href="#查看" class="headerlink" title="查看"></a>查看</h3><table><thead><tr><th align="left">功能</th><th align="left">Windows / Linux</th><th>macOS</th></tr></thead><tbody><tr><td align="left">切换侧边栏</td><td align="left">Ctrl + Shift + L</td><td>Command + Shift + L</td></tr><tr><td align="left">大纲</td><td align="left">Ctrl + Shift + 1</td><td>Command + Shift + 1</td></tr><tr><td align="left">文章</td><td align="left">Ctrl + Shift + 2</td><td>Command + Control + 2</td></tr><tr><td align="left">文件树</td><td align="left">Ctrl + Shift + 3</td><td>Command + Control + 3</td></tr><tr><td align="left">源代码模式</td><td align="left">Ctrl + /</td><td>Command + /</td></tr><tr><td align="left">聚焦模式</td><td align="left">F8</td><td>F8</td></tr><tr><td align="left">打字机模式</td><td align="left">F9</td><td>F9</td></tr><tr><td align="left">切换全屏</td><td align="left">F11</td><td>Command + Option + F</td></tr><tr><td align="left">实际尺寸</td><td align="left">Ctrl + Shift + 0</td><td><em>（不支持）</em></td></tr><tr><td align="left">放大</td><td align="left">Ctrl + Shift + =</td><td><em>（不支持）</em></td></tr><tr><td align="left">缩小</td><td align="left">Ctrl + Shift +-</td><td><em>（不支持）</em></td></tr><tr><td align="left">在打开的文档之间切换</td><td align="left">Ctrl + Tab</td><td>Command + `</td></tr><tr><td align="left">切换开发工具</td><td align="left">Ctrl + Shift + I</td><td>-</td></tr></tbody></table><h2 id="更改快捷键"><a href="#更改快捷键" class="headerlink" title="更改快捷键"></a>更改快捷键</h2><p>用户可以在 Typora 的菜单栏中设置或重新分配命令的快捷键。</p><h3 id="MacOS"><a href="#MacOS" class="headerlink" title="MacOS"></a>MacOS</h3><p>我们使用 macOS 的系统功能来自定义 Typora 在 macOS 上的按键绑定。</p><ol><li><p>打开<code>System Preference</code>→ <code>Keyboard</code>，选择选项卡<code>Shortcuts</code>。<code>App Shortcuts</code>在其左侧面板中选择。</p><p><img src="https://pic.lixl.cn/2020/Snip20160814_1.png" alt="快捷键设置"></p></li><li><p>单击“ +”按钮，将弹出一个对话框。从字段中选择“ Typora.app” <code>Application</code>，然后输入要添加的菜单命令的确切名称，然后键入要分配的快捷键组合。</p><p>例如，假设您要添加/更改快捷键以固定 Typora 的窗口，则可以如下所示填充对话框：</p><p><img src="https://pic.lixl.cn/2020/Snip20160814_5.png" alt="绑定快捷键"></p><p>然后<code>Command+Shift+P</code>将成为菜单命令“ always on top”的快捷键</p></li></ol><h3 id="Windows-Linux"><a href="#Windows-Linux" class="headerlink" title="Windows / Linux"></a>Windows / Linux</h3><blockquote><p>提示：这需要 Typora ≥ v0.9.16 的版本。</p></blockquote><ol><li><p>在 Typora 中打开<code>Menu</code>→ <code>Preference</code>，然后单击“打开高级设置”。</p><p><img src="https://pic.lixl.cn/2020/sshot-1.png" alt="打开高级设置"></p></li><li><p><code>conf.user.json</code>从打开的“文件浏览”中打开和编辑。如果没有这样的文件，请创建一个。</p></li><li><p>设置或添加表示键绑定的 JSON 对象，例如：</p><p><img src="https://pic.lixl.cn/2020/Snip20160814_7.png" alt="添加快捷键"></p></li><li><p>重新启动 Typora，将应用新的键绑定。</p><p><img src="https://pic.lixl.cn/2020/sshot-2.png" alt="应用新的快捷键"></p></li></ol><p>您可以本机窗口样式设置或更改菜单栏中菜单项的快捷键。</p><p><strong>问: 快捷键在 Ubuntu 上不起作用？</strong></p><p>对于这个问题的解决方案，请参阅:</p><ul><li><a href="https://help.ubuntu.com/community/KeyboardShortcuts" target="_blank" rel="noopener">https://help.ubuntu.com/community/KeyboardShortcuts</a> 和</li><li><a href="https://askubuntu.com/questions/208310/ctrl-a-doesnt-work-in-browsers." target="_blank" rel="noopener">https://askubuntu.com/questions/208310/ctrl-a-doesnt-work-in-browsers.</a></li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>本文翻译自：<a href="https://support.typora.io/Shortcut-Keys/" target="_blank" rel="noopener">https://support.typora.io/Shortcut-Keys/</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Typora </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用Typora + PicGo 图床 + jsDelivr CDN实现高效 Markdown 创作</title>
      <link href="/2019/120114500.html"/>
      <url>/2019/120114500.html</url>
      
        <content type="html"><![CDATA[<p>本文提到两种插件组合方式，iPic及PicGo，支持Github、SM.MS、阿里OSS、腾讯COS、微博等主流图床。通过工具的搭配使用，我们能轻松地完成在 Markdown 中插图的工作，发布到多个内容平台。</p><p>对于Typora + iPic方式，是Typora默认支持的。尤其在一次性粘贴带有多个图片的图文混合内容时，超级方便。不过iPic是收费软件，可以使用PicGo来替代，只是这样就无法实现一次性粘贴多个图片的图文混合内容了。</p><h2 id="一、iPic方式"><a href="#一、iPic方式" class="headerlink" title="一、iPic方式"></a>一、iPic方式</h2><p>目前，Markdown 编辑器 <a href="https://sspai.com/tag/Typora" target="_blank" rel="noopener">Typora</a> 已经接入 iPicUploader，通过两款工具的搭配，我们能轻松地完成在 Markdown 中插图的工作。</p><h3 id="自动上传图片至图床"><a href="#自动上传图片至图床" class="headerlink" title="自动上传图片至图床"></a>自动上传图片至图床</h3><p>打开 Typora 中的「系统偏好设置 - 图像 - 通过iPic上传图片」选项，在 Typora 中插入本地图片时，i会自动将图片上传图床并使用 Markdown 语法替换文内地址。</p><p><img src="https://pic.lixl.cn/2020/20200114223815.png/w1280" alt=""></p><h3 id="使用快捷键"><a href="#使用快捷键" class="headerlink" title="使用快捷键"></a>使用快捷键</h3><p>如果你的主力 Markdown 工具不是 Typora，在选中图片或截图之后，使用 ⌘ + U 快捷键上传，然后直接在编辑器中粘贴也是一个不错的选择。</p><h2 id="二、PicGo方式"><a href="#二、PicGo方式" class="headerlink" title="二、PicGo方式"></a>二、PicGo方式</h2><p>PicGo是一款开源的图床软件，该软件与iPic的不分伯仲，文档支持中文，支持插件开发。</p><h3 id="安装PicGo"><a href="#安装PicGo" class="headerlink" title="安装PicGo"></a>安装PicGo</h3><p>下载地址 <a href="https://github.com/Molunerfinn/PicGo/releases" target="_blank" rel="noopener">https://github.com/Molunerfinn/PicGo/releases</a> ，选择下载与系统匹配的安装包，正常安装即可。</p><h3 id="配置图床"><a href="#配置图床" class="headerlink" title="配置图床"></a>配置图床</h3><p><img src="https://pic.lixl.cn/2020/20200114213053.png/w1280" alt=""></p><p>Github图床配置如上图，参数说明：</p><ul><li>仓库名：按照 <code>账户名/仓库名的格式填写</code></li><li>分支名：一般填写 <code>master</code> 即可</li><li>Token：到 <a href="https://github.com/settings/tokens" target="_blank" rel="noopener">https://github.com/settings/tokens</a> 去生成，然后黏贴在这里</li><li>存储路径：如图配置，会在仓库根目录创建 <code>images/2019</code> 的文件夹</li><li>自定义域名：图片成功上传后，PicGo会将 <code>自定义域名+上传的图片名</code> 生成的访问链接，放到剪切板中。</li></ul><blockquote><p>使用GitHub仓库作为图床，存在的问题是国内访问github的速度很慢，可以利用 <a href="https://www.jsdelivr.com/" target="_blank" rel="noopener">jsDelivr CDN</a> 来加速访问。jsDelivr 是一个免费开源的 CDN 解决方案，该平台是首个打通中国大陆与海外的免费CDN服务，拥有中国政府颁发的 ICP 许可证，无须担心中国防火墙问题而影响使用。使用jsDelivr加速访问，需要将自定义域名设置为 <code>https://cdn.jsdelivr.net/gh/用户名/图床仓库名/</code>。</p><p>这里有一个大小为 700多K 的图片，可以体验一下速度差异：<a href="https://raw.githubusercontent.com/lxl80/blog/master/themes/hexo-theme-matery/source/medias/banner/2.jpg" target="_blank" rel="noopener">Github原始地址</a>　　　　<a href="https://cdn.jsdelivr.net/gh/lxl80/blog/themes/hexo-theme-matery/source/medias/banner/2.jpg" target="_blank" rel="noopener">jsDelivr CDN加速地址</a></p></blockquote><p><img src="https://pic.lixl.cn/2020/20200114203447.png/w1280" alt=""></p><p>阿里云OSS图床配置如上图，参数说明：</p><ul><li><p>Keyii及KeySecret：到 <a href="https://usercenter.console.aliyun.com/#/manage/ak" target="_blank" rel="noopener">阿里云控制台AccessKey管理</a> 申请并输入</p></li><li><p>仓库空间名：在对象存储中创建的Bucket的名称</p></li><li><p>存储区域：创建Bucket时所选区域的英文标识，查询地址：<a href="https://help.aliyun.com/document_detail/31837.html#concept-zt4-cvy-5db" target="_blank" rel="noopener">OSS开通Region</a></p></li><li><p>存储路径：如图配置，会自动在 OSS 存储空间根目录创建 <code>2020</code> 文件夹</p></li><li><p>网址后缀：这是阿里云 OSS 的一个很好用的功能，用于图片处理（如缩略图）。需要去OSS的 <a href="https://help.aliyun.com/document_detail/48884.html" target="_blank" rel="noopener">图片处理规则</a> 中创建样式。以下是我设置的规则，后缀 <code>w1280</code>代表将图片等比缩放到宽度&lt;=1280</p><p><img src="https://pic.lixl.cn/2020/20200114220140.png/w1280" alt=""></p></li><li><p>自定义域名：图片成功上传后，PicGo会将 <code>自定义域名+上传的图片名</code> 生成的访问链接，放到剪切板中。</p></li></ul><h3 id="快捷键及相关配置"><a href="#快捷键及相关配置" class="headerlink" title="快捷键及相关配置"></a>快捷键及相关配置</h3><p><img src="https://pic.lixl.cn/2020/20200114221441.png/w1280" alt=""></p><p>支持快捷键<code>command+shift+p</code>（macOS）或者<code>control+shift+p</code>（Windows\Linux）用以支持快捷上传剪贴板里的图片（第一张）。 PicGo 支持自定义快捷键，使用方法见 <a href="https://picgo.github.io/PicGo-Doc/zh/guide/config.html" target="_blank" rel="noopener">配置手册</a>。</p><p>通过自定义链接格式，可以直接生成符合需要的Markdown代码，方便粘贴。如我喜欢通过OSS将原始图片等比缩放到宽度&lt;=1280px，并将图片缩放50%来优化显示效果及速度，配置如下：</p><p><img src="https://pic.lixl.cn/2020/20200114222126.png/w1280" alt=""></p><p>复制或截图后，通过快捷键上传，然后直接粘贴，即可获得如下可直接粘贴到Markdown文档中的代码：</p><pre class="line-numbers language-markdown"><code class="language-markdown"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>img</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>https://pic.lixl.cn/2020/20200114222126.png/w1280<span class="token punctuation">"</span></span> <span class="token attr-name">alt</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span><span class="token punctuation">"</span></span><span class="token style-attr language-css"><span class="token attr-name"> <span class="token attr-name">style</span></span><span class="token punctuation">="</span><span class="token attr-value"><span class="token property">zoom</span><span class="token punctuation">:</span><span class="token number">50%</span><span class="token punctuation">;</span></span><span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>补充：自动生成的代码包括了图片缩放设置，您也可以通过设置自定义链接格式为 <code>![]($url)</code> ，生成标准的Markdown代码:<code>![](https://pic.lixl.cn/2020/20200114222126.png/w1280)</code></p></blockquote><h2 id="三、免安装图床插件方式"><a href="#三、免安装图床插件方式" class="headerlink" title="三、免安装图床插件方式"></a>三、免安装图床插件方式</h2><p>如果使用 <a href="https://hexo.io/zh-cn/" target="_blank" rel="noopener">Hexo</a> 来搭建本地博客，可以不安装 iPic、PicGo 等图床插件，通过 Typora 将图片保存在本地，基于 <a href="https://www.npmjs.com/package/hexo-deployer-cos-cdn" target="_blank" rel="noopener">hexo-deployer-cos-cdn</a> 插件一键自动部署，详情可参考博文：<a href="https://www.lixl.cn/2020/020936412.html">hexo-deployer-cos-cdn 插件安装使用指南</a>。</p><p><img src="https://pic.lixl.cn/2020/image-20200310103404971.png" alt="配置Typora将图片保存到指定路径"></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://www.jianshu.com/p/d1dac86fbe04" target="_blank" rel="noopener">iPic + Typora，方便快捷地在 Markdown 中插图</a></li><li><a href="https://github.com/Molunerfinn/PicGo" target="_blank" rel="noopener">Molunerfinn/PicGo</a></li><li><a href="https://www.jianshu.com/p/a36e9c64361d" target="_blank" rel="noopener">Github+jsDelivr+PicGo 打造稳定快速、高效免费图床</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Typora </tag>
            
            <tag> Markdown </tag>
            
            <tag> PicGo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于Hexo的matery主题搭建博客并深度优化</title>
      <link href="/2019/092856736.html"/>
      <url>/2019/092856736.html</url>
      
        <content type="html"><![CDATA[<p>对于有一定技术背景的同学，自己动手搭建博客网站是一个很不错的选择。选择喜欢的主题，按需进行个性化配置，随时在本地用自己喜欢的工具写文章，一键发布到多个博客托管平台，使用自己喜欢的图床/CDN 来加速…</p><blockquote><p><a href="https://www.lixl.cn">演示站点（悟尘记）</a> 基于 Hexo 的 hexo-theme-matery 主题构建，部署在腾讯云 COS 中并使用 CDN 进行内容加速，通过 PicGo + 阿里云 OSS 作为图床进行静态资源加速。</p></blockquote><h2 id="安装-hexo"><a href="#安装-hexo" class="headerlink" title="安装 hexo"></a>安装 hexo</h2><p><a href="https://hexo.io/zh-cn/" target="_blank" rel="noopener">Hexo</a> 是一个快速、简洁且高效的博客框架。Hexo 使用 <a href="http://daringfireball.net/projects/markdown/" target="_blank" rel="noopener">Markdown</a>（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。</p><h3 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h3><p>安装 Hexo 相当简单，只需要先安装下列应用程序即可：</p><ul><li><a href="http://nodejs.org/" target="_blank" rel="noopener">Node.js</a> (Node.js 版本需不低于 8.10，建议使用 Node.js 10.0 及以上版本)</li><li><a href="http://git-scm.com/" target="_blank" rel="noopener">Git</a></li></ul><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>所有必备的应用程序安装完成后，即可使用 npm 安装 Hexo。</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">npm</span> <span class="token function">install</span> -g hexo-cli<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>安装以后，可以使用以下两种方式执行 Hexo：</p><ol><li><code>npx hexo</code></li><li>将 Hexo 所在的目录下的 <code>node_modules</code> 添加到环境变量之中即可直接使用： <code>hexo</code></li></ol><pre class="line-numbers language-bash"><code class="language-bash"><span class="token keyword">echo</span> <span class="token string">'PATH="<span class="token variable">$PATH</span>:./node_modules/.bin"'</span> <span class="token operator">>></span> ~/.profile<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="升级"><a href="#升级" class="headerlink" title="升级"></a>升级</h3><p>后期需要升级的化，进入 blog 目录，先检查更新:</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">npm</span> outdatedPackage                  Current  Wanted  Latest  Locationhexo                       3.9.0   3.9.0   4.2.0  hexo-sitehexo-deployer-git          1.0.0   1.0.0   2.1.0  hexo-sitehexo-generator-archive     0.1.5   0.1.5   1.0.0  hexo-sitehexo-generator-category    0.1.3   0.1.3   1.0.0  hexo-sitehexo-generator-feed        1.2.2   1.2.2   2.2.0  hexo-sitehexo-generator-index       0.2.1   0.2.1   1.0.0  hexo-sitehexo-generator-tag         0.2.0   0.2.0   1.0.0  hexo-sitehexo-renderer-ejs          0.3.1   0.3.1   1.0.0  hexo-sitehexo-renderer-marked       0.3.2   0.3.2   2.0.0  hexo-sitehexo-renderer-stylus       0.3.3   0.3.3   1.1.0  hexo-sitehexo-server                0.3.3   0.3.3   1.0.0  hexo-site<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>修改 <code>package.json</code> 文件，基于 <code>Latest</code> 列内容更新版本号，然后更新并检查版本号：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">npm</span> <span class="token function">install</span> --save<span class="token comment" spellcheck="true"># 检查版本号</span>$ hexo -vhexo: 4.2.0hexo-cli: 3.1.0<span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="建站"><a href="#建站" class="headerlink" title="建站"></a>建站</h3><p>安装 Hexo 完成后，请执行下列命令，Hexo 将会在指定文件夹中新建所需要的文件。</p><pre class="line-numbers language-bash"><code class="language-bash">hexo init <span class="token operator">&lt;</span>folder<span class="token operator">></span><span class="token function">cd</span> <span class="token operator">&lt;</span>folder<span class="token operator">></span><span class="token function">npm</span> <span class="token function">install</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h3><p>此时，通过 <code>hexo s</code> 命令即可在本地启动您的博客站点了。</p><pre class="line-numbers language-bash"><code class="language-bash">$ hexo sINFO  Start processingINFO  Hexo is running at http://localhost:4000 <span class="token keyword">.</span> Press Ctrl+C to stop.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>接下来将安装主题，配置博客托管平台，实现一键发布并刷新 CDN 缓存。</p><h2 id="目录结构说明"><a href="#目录结构说明" class="headerlink" title="目录结构说明"></a>目录结构说明</h2><p>在执行过<code>Hexo deploy</code>命令之后，目录结构新增了<code>.deploy_git</code>，<code>public</code>，<code>.gitignore</code>，如下：</p><pre class="line-numbers language-bash"><code class="language-bash"> $ tree -L 2<span class="token keyword">.</span>├── .deploy_git├── node_modules├── public├── scaffolds│   ├── draft.md│   ├── page.md│   └── post.md├── <span class="token function">source</span>│   ├── _posts│   ├── _drafts├── themes├── _config.yml├── db.json├── package.json└── package-lock.json<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="config-yml"><a href="#config-yml" class="headerlink" title="_config.yml"></a>_config.yml</h3><p>用来配置博客相关的参数，初始化时自动创建。具体参数设置，可参照 <a href="https://hexo.io/zh-cn/docs/configuration" target="_blank" rel="noopener">Hexo 配置</a> 文档。</p><h3 id="node-modules-和-package-json"><a href="#node-modules-和-package-json" class="headerlink" title="node_modules 和 package.json"></a>node_modules 和 package.json</h3><p>都是在初始化时自动创建。</p><p><code>node_modules</code>用来存储已安装的各类依赖包。<br><code>package.json</code>用来查看 Hexo 的版本以及相关依赖包的版本。</p><p>Hexo 会默认安装：</p><ul><li>hexo：主程序</li><li>hexo-deployer-git：实现 git 部署方式</li><li>hexo-generator-archive：存档页面生成器</li><li>hexo-generator-category：分类页面生成器</li><li>hexo-generator-index：index 生成器</li><li>hexo-generator-tag：标签页面生成器</li><li>hexo-renderer-ejs：支持 EJS 渲染</li><li>hexo-renderer-marked：Markdown 引擎</li><li>hexo-renderer-stylus：支持 stylus 渲染</li><li>hexo-server：支持本地预览，默认地址 localhost:4000</li></ul><p>新安装的依赖包，也会保存在<code>node_module</code>文件夹下。</p><h3 id="scaffold"><a href="#scaffold" class="headerlink" title="scaffold"></a>scaffold</h3><p>模板文件夹，初始化时自动创建。包含<code>page</code>，<code>post</code>，<code>draft</code>三种模板，分别对应 页面、要发布的文章、草稿。</p><h3 id="themes"><a href="#themes" class="headerlink" title="themes"></a>themes</h3><p>主题文件夹，初始化时自动创建。每一个主题，都有一个单独的文件夹。默认主题为 <a href="https://github.com/hexojs/hexo-theme-landscape" target="_blank" rel="noopener">landscape</a>。</p><h3 id="source-，-public-和-deploy-git"><a href="#source-，-public-和-deploy-git" class="headerlink" title="source ， public 和 .deploy_git"></a>source ， public 和 .deploy_git</h3><ul><li>source：资源文件夹。用来存放图片、Markdown 文档（文章、草稿）、各种页面（分类、关于页面等）。</li><li>public：将 source 文件夹里的 Markdown 文档，转换成 index.html。再结合主题进行渲染，就是我们最终看到的博客。</li><li>.deploy_git：将 public 文件夹的内容提交到 Github 后生成，内容与 public 文件夹基本一致。</li></ul><p>这三者的关系大致是：source -&gt; public -&gt; .deploy_git</p><p>执行<code>hexo generate</code>，根据 source，更新 public。<br>执行<code>hexo deploy</code>，根据 public，更新 .deploy_git。</p><h2 id="配置主题"><a href="#配置主题" class="headerlink" title="配置主题"></a>配置主题</h2><h3 id="下载主题"><a href="#下载主题" class="headerlink" title="下载主题"></a>下载主题</h3><p><a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank" rel="noopener">hexo-theme-matery</a> 是一个采用 <code>Material Design</code> 和响应式设计的 Hexo 博客主题，点击 <a href="https://www.lixl.cn">这里</a> 可以查看示例效果。点击 <a href="https://codeload.github.com/blinkfox/hexo-theme-matery/zip/master" target="_blank" rel="noopener">这里</a> 下载 <code>master</code> 分支的最新稳定版的代码，解压缩后，将 <code>hexo-theme-matery</code> 的文件夹复制到 Hexo 的 <code>themes</code> 文件夹中即可。</p><h3 id="切换主题"><a href="#切换主题" class="headerlink" title="切换主题"></a>切换主题</h3><p>修改 Hexo 根目录下的 <code>_config.yml</code> 的 <code>theme</code> 的值：<code>theme: hexo-theme-matery</code></p><h4 id="config-yml-文件的其它修改建议"><a href="#config-yml-文件的其它修改建议" class="headerlink" title="_config.yml 文件的其它修改建议"></a><code>_config.yml</code> 文件的其它修改建议</h4><ul><li>请修改 <code>_config.yml</code> 的 <code>url</code> 的值为你的网站主 <code>URL</code>（如：<code>http://xxx.github.io</code>）。</li><li>建议修改两个 <code>per_page</code> 的分页条数值为 <code>6</code> 的倍数，如：<code>12</code>、<code>18</code> 等，这样文章列表在各个屏幕下都能较好的显示。</li><li>如果是中文用户，则建议修改 <code>language</code> 的值为 <code>zh-CN</code>。</li></ul><h3 id="新建分类-categories-页"><a href="#新建分类-categories-页" class="headerlink" title="新建分类 categories 页"></a>新建分类 categories 页</h3><p><code>categories</code> 页是用来展示所有分类的页面，如果 <code>source</code> 目录下还没有 <code>categories/index.md</code> 文件，那么就需要新建一个，命令如下：</p><pre class="line-numbers language-bash"><code class="language-bash">hexo new page <span class="token string">"categories"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>编辑你刚刚新建的页面文件 <code>/source/categories/index.md</code>，至少需要以下内容：</p><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token punctuation">---</span><span class="token key atrule">title</span><span class="token punctuation">:</span> categories<span class="token key atrule">date</span><span class="token punctuation">:</span> <span class="token datetime number">2018-09-30 17:25:30</span><span class="token key atrule">type</span><span class="token punctuation">:</span> <span class="token string">"categories"</span><span class="token key atrule">layout</span><span class="token punctuation">:</span> <span class="token string">"categories"</span><span class="token punctuation">---</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="新建标签-tags-页"><a href="#新建标签-tags-页" class="headerlink" title="新建标签 tags 页"></a>新建标签 tags 页</h3><p><code>tags</code> 页是用来展示所有标签的页面，如果 <code>source</code> 目录下还没有 <code>tags/index.md</code> 文件，那么就需要新建一个，命令如下：</p><pre class="line-numbers language-bash"><code class="language-bash">hexo new page <span class="token string">"tags"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>编辑刚刚新建的页面文件 <code>/source/tags/index.md</code>，至少需要以下内容：</p><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token punctuation">---</span><span class="token key atrule">title</span><span class="token punctuation">:</span> tags<span class="token key atrule">date</span><span class="token punctuation">:</span> <span class="token datetime number">2018-09-30 18:23:38</span><span class="token key atrule">type</span><span class="token punctuation">:</span> <span class="token string">"tags"</span><span class="token key atrule">layout</span><span class="token punctuation">:</span> <span class="token string">"tags"</span><span class="token punctuation">---</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="新建关于我-about-页"><a href="#新建关于我-about-页" class="headerlink" title="新建关于我 about 页"></a>新建关于我 about 页</h3><p><code>about</code> 页是用来展示<strong>关于我和我的博客</strong>信息的页面，如果 <code>source</code> 目录下还没有 <code>about/index.md</code> 文件，那么就需要新建一个，命令如下：</p><pre class="line-numbers language-bash"><code class="language-bash">hexo new page <span class="token string">"about"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>编辑刚刚新建的页面文件 <code>/source/about/index.md</code>，至少需要以下内容：</p><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token punctuation">---</span><span class="token key atrule">title</span><span class="token punctuation">:</span> about<span class="token key atrule">date</span><span class="token punctuation">:</span> <span class="token datetime number">2018-09-30 17:25:30</span><span class="token key atrule">type</span><span class="token punctuation">:</span> <span class="token string">"about"</span><span class="token key atrule">layout</span><span class="token punctuation">:</span> <span class="token string">"about"</span><span class="token punctuation">---</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="新建友情连接-friends-页（可选的）"><a href="#新建友情连接-friends-页（可选的）" class="headerlink" title="新建友情连接 friends 页（可选的）"></a>新建友情连接 friends 页（可选的）</h3><p><code>friends</code> 页是用来展示<strong>友情连接</strong>信息的页面，如果 <code>source</code> 目录下还没有 <code>friends/index.md</code> 文件，那么就需要新建一个，命令如下：</p><pre class="line-numbers language-bash"><code class="language-bash">hexo new page <span class="token string">"friends"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>编辑刚刚新建的页面文件 <code>/source/friends/index.md</code>，至少需要以下内容：</p><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token punctuation">---</span><span class="token key atrule">title</span><span class="token punctuation">:</span> friends<span class="token key atrule">date</span><span class="token punctuation">:</span> <span class="token datetime number">2018-12-12 21:25:30</span><span class="token key atrule">type</span><span class="token punctuation">:</span> <span class="token string">"friends"</span><span class="token key atrule">layout</span><span class="token punctuation">:</span> <span class="token string">"friends"</span><span class="token punctuation">---</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>同时，在 <code>source</code> 目录下新建 <code>_data</code> 目录，在 <code>_data</code> 目录中新建 <code>friends.json</code> 文件，文件内容如下所示：</p><pre class="line-numbers language-json"><code class="language-json"><span class="token punctuation">[</span>  <span class="token punctuation">{</span>    <span class="token property">"avatar"</span><span class="token operator">:</span> <span class="token string">"https://www.lixl.cn/medias/avatar.jpg"</span><span class="token punctuation">,</span>    <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"悟尘记"</span><span class="token punctuation">,</span>    <span class="token property">"introduction"</span><span class="token operator">:</span> <span class="token string">"人生就是一场修行，上善若水，厚德载物。"</span><span class="token punctuation">,</span>    <span class="token property">"url"</span><span class="token operator">:</span> <span class="token string">"https://www.lixl.cn/"</span><span class="token punctuation">,</span>    <span class="token property">"title"</span><span class="token operator">:</span> <span class="token string">"前去参观"</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token punctuation">{</span>    <span class="token property">"avatar"</span><span class="token operator">:</span> <span class="token string">"https://wiki.hyperledger.org/download/attachments/2392069/fabric?version=1&amp;modificationDate=1540928132000&amp;api=v2"</span><span class="token punctuation">,</span>    <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"Fabric"</span><span class="token punctuation">,</span>    <span class="token property">"introduction"</span><span class="token operator">:</span> <span class="token string">"A Blockchain Platform for the Enterprise"</span><span class="token punctuation">,</span>    <span class="token property">"url"</span><span class="token operator">:</span> <span class="token string">"https://hyperledger-fabric.readthedocs.io/en/master/"</span><span class="token punctuation">,</span>    <span class="token property">"title"</span><span class="token operator">:</span> <span class="token string">"前去学习"</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token punctuation">{</span>    <span class="token property">"avatar"</span><span class="token operator">:</span> <span class="token string">"https://www.bootcdn.cn/assets/img/maoyun.svg"</span><span class="token punctuation">,</span>    <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"BootCDN"</span><span class="token punctuation">,</span>    <span class="token property">"introduction"</span><span class="token operator">:</span> <span class="token string">"稳定、快速、免费的前端开源项目 CDN 加速服务。"</span><span class="token punctuation">,</span>    <span class="token property">"url"</span><span class="token operator">:</span> <span class="token string">"https://www.bootcdn.cn/"</span><span class="token punctuation">,</span>    <span class="token property">"title"</span><span class="token operator">:</span> <span class="token string">"前去加速"</span>  <span class="token punctuation">}</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="代码高亮"><a href="#代码高亮" class="headerlink" title="代码高亮"></a>代码高亮</h3><p>由于 Hexo 自带的代码高亮主题显示不好看，所以主题中使用到了 <a href="https://github.com/ele828/hexo-prism-plugin" target="_blank" rel="noopener">hexo-prism-plugin</a> 的 Hexo 插件来做代码高亮，安装命令如下：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">npm</span> i -S hexo-prism-plugin<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>然后，修改 Hexo 根目录下 <code>_config.yml</code> 文件中 <code>highlight.enable</code> 的值为 <code>false</code>，并新增 <code>prism</code> 插件相关的配置，主要配置如下：</p><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token key atrule">highlight</span><span class="token punctuation">:</span>  <span class="token key atrule">enable</span><span class="token punctuation">:</span> <span class="token boolean important">false</span><span class="token key atrule">prism_plugin</span><span class="token punctuation">:</span>  <span class="token key atrule">mode</span><span class="token punctuation">:</span> <span class="token string">"preprocess"</span> <span class="token comment" spellcheck="true"># realtime/preprocess</span>  <span class="token key atrule">theme</span><span class="token punctuation">:</span> <span class="token string">"tomorrow"</span>  <span class="token key atrule">line_number</span><span class="token punctuation">:</span> <span class="token boolean important">false </span><span class="token comment" spellcheck="true"># default false</span>  custom_css<span class="token punctuation">:</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h3><p>本主题中还使用到了 <a href="https://github.com/wzpan/hexo-generator-search" target="_blank" rel="noopener">hexo-generator-search</a> 的 Hexo 插件来做内容搜索，安装命令如下：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">npm</span> <span class="token function">install</span> hexo-generator-search --save<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在 Hexo 根目录下的 <code>_config.yml</code> 文件中，新增以下的配置项：</p><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token key atrule">search</span><span class="token punctuation">:</span>  <span class="token key atrule">path</span><span class="token punctuation">:</span> search.xml  <span class="token key atrule">field</span><span class="token punctuation">:</span> post<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="修改页脚"><a href="#修改页脚" class="headerlink" title="修改页脚"></a>修改页脚</h3><p>页脚信息可能需要做定制化修改，而且它不便于做成配置信息，所以可能需要你自己去再修改和加工。修改的地方在主题文件的 <code>/layout/_partial/footer.ejs</code> 文件中，包括站点、使用的主题、访问量等。</p><h3 id="修改社交链接"><a href="#修改社交链接" class="headerlink" title="修改社交链接"></a>修改社交链接</h3><p>在主题的 <code>_config.yml</code> 文件中，默认支持 <code>QQ</code>、<code>GitHub</code> 和邮箱的配置，可以在主题文件的 <code>/layout/_partial/social-link.ejs</code> 文件中，新增、修改需要的社交链接地址，增加链接可参考如下代码：</p><pre class="line-numbers language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span>  <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>https://github.com/blinkfox<span class="token punctuation">"</span></span>  <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>tooltipped<span class="token punctuation">"</span></span>  <span class="token attr-name">target</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>_blank<span class="token punctuation">"</span></span>  <span class="token attr-name">data-tooltip</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>访问我的GitHub<span class="token punctuation">"</span></span>  <span class="token attr-name">data-position</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>top<span class="token punctuation">"</span></span>  <span class="token attr-name">data-delay</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>50<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>i</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>fa fa-github<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>i</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其中，社交图标（如：<code>fa-github</code>）可以在 <a href="https://fontawesome.com/icons" target="_blank" rel="noopener">Font Awesome</a> 中搜索找到。以下是常用社交图标的标识，供参考：</p><ul><li>Facebook: <code>fa-facebook</code></li><li>Twitter: <code>fa-twitter</code></li><li>Google-plus: <code>fa-google-plus</code></li><li>Linkedin: <code>fa-linkedin</code></li><li>Tumblr: <code>fa-tumblr</code></li><li>Medium: <code>fa-medium</code></li><li>Slack: <code>fa-slack</code></li><li>新浪微博: <code>fa-weibo</code></li><li>微信: <code>fa-wechat</code></li><li>QQ: <code>fa-qq</code></li></ul><h3 id="修改打赏的二维码图片"><a href="#修改打赏的二维码图片" class="headerlink" title="修改打赏的二维码图片"></a>修改打赏的二维码图片</h3><p>在主题文件的 <code>source/medias/reward</code> 文件中，可以替换成你的的微信和支付宝的打赏二维码图片。</p><h3 id="一键部署"><a href="#一键部署" class="headerlink" title="一键部署"></a>一键部署</h3><p>通过 <a href="https://github.com/hexojs/hexo-deployer-git" target="_blank" rel="noopener">hexo-deployer-git</a> 插件可以实现一键将博客同时部署到多个 git 仓库中。如同时发布到 github 及 gitee 提供的 pages 服务。安装：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">npm</span> <span class="token function">install</span> hexo-deployer-git --save<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>修改 Hexo 根目录下的 <code>_config.yml</code> 文件中的如下内容:</p><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token comment" spellcheck="true">## Docs: https://hexo.io/docs/deployment.html</span><span class="token key atrule">deploy</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token key atrule">type</span><span class="token punctuation">:</span> git    <span class="token key atrule">repo</span><span class="token punctuation">:</span> https<span class="token punctuation">:</span>//github.com/lxl80/blog.git    <span class="token key atrule">branch</span><span class="token punctuation">:</span> gh<span class="token punctuation">-</span>pages    <span class="token key atrule">ignore_hidden</span><span class="token punctuation">:</span> <span class="token boolean important">false</span>  <span class="token punctuation">-</span> <span class="token key atrule">type</span><span class="token punctuation">:</span> git    <span class="token key atrule">repo</span><span class="token punctuation">:</span> https<span class="token punctuation">:</span>//gitee.com/lxl80/lxl80.git    <span class="token key atrule">branch</span><span class="token punctuation">:</span> master    <span class="token key atrule">ignore_hidden</span><span class="token punctuation">:</span> <span class="token boolean important">false</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>也可以如本站一样，采用 <a href="https://github.com/75k/hexo-deployer-cos-enhanced" target="_blank" rel="noopener">hexo-deployer-cos-enhanced</a> 插件将静态内容部署到腾讯云对象存储服务中，在 DNS 配置中将境内线路解析到腾讯云 CDN 地址，实现加速。部署完成后会自动刷新被更新文件的 CDN 缓存。</p></blockquote><p>安装：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">npm</span> <span class="token function">install</span> hexo-deployer-cos-enhanced --save<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><code>_config.yml</code> 配置如下:</p><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token key atrule">deploy</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token key atrule">type</span><span class="token punctuation">:</span> git    <span class="token key atrule">repo</span><span class="token punctuation">:</span> https<span class="token punctuation">:</span>//github.com/lxl80/blog.git    <span class="token key atrule">branch</span><span class="token punctuation">:</span> gh<span class="token punctuation">-</span>pages    <span class="token key atrule">ignore_hidden</span><span class="token punctuation">:</span> <span class="token boolean important">false</span>  <span class="token punctuation">-</span> <span class="token key atrule">type</span><span class="token punctuation">:</span> cos    <span class="token key atrule">bucket</span><span class="token punctuation">:</span> lxl80<span class="token punctuation">-</span>130****    <span class="token key atrule">region</span><span class="token punctuation">:</span> ap<span class="token punctuation">-</span>beijing    <span class="token key atrule">secretId</span><span class="token punctuation">:</span> AKIDh9***<span class="token important">*F8FvL</span>    <span class="token key atrule">secretKey</span><span class="token punctuation">:</span> Z3IGiur***<span class="token important">*QZR3PgjXmlVg</span>    <span class="token key atrule">cdnConfig</span><span class="token punctuation">:</span>      <span class="token key atrule">enable</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>      <span class="token key atrule">cdnUrl</span><span class="token punctuation">:</span> https<span class="token punctuation">:</span>//static.lixl.cn      <span class="token key atrule">bucket</span><span class="token punctuation">:</span> static<span class="token punctuation">-</span>130****      <span class="token key atrule">region</span><span class="token punctuation">:</span> ap<span class="token punctuation">-</span>beijing      <span class="token key atrule">folder</span><span class="token punctuation">:</span> static      <span class="token key atrule">secretId</span><span class="token punctuation">:</span> AKIDh9***<span class="token important">*F8FvL</span>      <span class="token key atrule">secretKey</span><span class="token punctuation">:</span> Z3IGiur***<span class="token important">*QZR3PgjXmlVg</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后通过 <code>hexo g -d</code> 即可实现一键发布，并更新 CDN 缓存。</p><h3 id="文章链接转静态短地址（建议安装）"><a href="#文章链接转静态短地址（建议安装）" class="headerlink" title="文章链接转静态短地址（建议安装）"></a>文章链接转静态短地址（建议安装）</h3><p>如果文章名称是中文的，那么 Hexo 默认生成的永久链接也会有中文，这样不利于 <code>SEO</code>，且 <code>gitment</code> 评论对中文链接也不支持。我们可以用 <a href="https://github.com/viko16/hexo-permalink-pinyin" target="_blank" rel="noopener">hexo-permalink-pinyin</a> Hexo 插件生成文章时生成中文拼音的永久链接，或者用<a href="https://github.com/rozbo/hexo-abbrlink" target="_blank" rel="noopener">hexo-abbrlink</a> 生成静态文章链接。以下结合 hexo-abbrlink 生成类似 <code>/yyyy/mmdd+随机数.html</code> 的文章链接地址。</p><p>安装命令如下：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">npm</span> <span class="token function">install</span> hexo-abbrlink --save<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在 Hexo 根目录下的 <code>_config.yml</code> 文件中，修改 <code>permalink:</code> ，并在文件末尾新增 <code>abbrlink:</code>配置项：</p><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token key atrule">permalink</span><span class="token punctuation">:</span> <span class="token punctuation">:</span>year/<span class="token punctuation">:</span>month<span class="token punctuation">:</span>day<span class="token punctuation">:</span>abbrlink.html<span class="token key atrule">abbrlink</span><span class="token punctuation">:</span>  <span class="token key atrule">alg</span><span class="token punctuation">:</span> crc16 <span class="token comment" spellcheck="true">#算法选项：crc16丨crc32</span>  <span class="token key atrule">rep</span><span class="token punctuation">:</span> dec <span class="token comment" spellcheck="true">#输出进制：dec为十进制，hex为十六进制</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="CND-加速（建议启用）"><a href="#CND-加速（建议启用）" class="headerlink" title="CND 加速（建议启用）"></a>CND 加速（建议启用）</h3><p>放在 Github 的资源在国内加载速度比较慢，因此需要使用 CDN 加速来优化网站打开速度，<a href="https://www.jsdelivr.com/" target="_blank" rel="noopener">jsDelivr</a> + Github 便是免费且好用的 CDN，非常适合博客网站使用。也可以选择主流云服务商提供的对象存储+CDN 来获得更快速及稳定的访问效果，费用低到几乎可忽略。</p><p><strong>用法：</strong></p><pre class="line-numbers language-http"><code class="language-http"><span class="token header-name keyword">https:</span>//cdn.jsdelivr.net/gh/你的用户名/你的仓库名@发布的版本号/文件路径<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>例如：</strong></p><pre class="line-numbers language-http"><code class="language-http"><span class="token header-name keyword">https:</span>//cdn.jsdelivr.net/gh/lxl80/blog@gh-pages/medias/banner/1.jpg<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>注意：版本号不是必需的，是为了区分新旧资源，如果不使用版本号，将会直接引用最新资源。</p><blockquote><p>还可以配合 <a href="https://github.com/Molunerfinn/PicGo" target="_blank" rel="noopener">PicGo</a>图床上传工具的<strong>自定义域名前缀</strong>来上传图片，使用极其方便。具体使用方法可参见我的另一篇文章: <a href="/2019/120114500.html">使用 Typora+iPic/PicGo 图床+CDN 实现高效 Markdown 创作</a></p></blockquote><h3 id="文章字数统计插件（可选的）"><a href="#文章字数统计插件（可选的）" class="headerlink" title="文章字数统计插件（可选的）"></a>文章字数统计插件（可选的）</h3><p>如果你想要在文章中显示文章字数、阅读时长信息，可以安装 <a href="https://github.com/willin/hexo-wordcount" target="_blank" rel="noopener">hexo-wordcount</a>插件。</p><p>安装命令如下：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">npm</span> i --save hexo-wordcount<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>然后只需在本主题下的 <code>_config.yml</code> 文件中，激活以下配置项即可：</p><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token key atrule">wordCount</span><span class="token punctuation">:</span>  <span class="token key atrule">enable</span><span class="token punctuation">:</span> <span class="token boolean important">false </span><span class="token comment" spellcheck="true"># 将这个值设置为 true 即可.</span>  <span class="token key atrule">postWordCount</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>  <span class="token key atrule">min2read</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>  <span class="token key atrule">totalCount</span><span class="token punctuation">:</span> <span class="token boolean important">true</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="添加-RSS-订阅支持（可选的）"><a href="#添加-RSS-订阅支持（可选的）" class="headerlink" title="添加 RSS 订阅支持（可选的）"></a>添加 RSS 订阅支持（可选的）</h3><p>本主题中还使用到了 <a href="https://github.com/hexojs/hexo-generator-feed" target="_blank" rel="noopener">hexo-generator-feed</a> 的 Hexo 插件来做 <code>RSS</code>，安装命令如下：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">npm</span> <span class="token function">install</span> hexo-generator-feed --save<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在 Hexo 根目录下的 <code>_config.yml</code> 文件中，新增以下的配置项：</p><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token key atrule">feed</span><span class="token punctuation">:</span>  <span class="token key atrule">type</span><span class="token punctuation">:</span> atom  <span class="token key atrule">path</span><span class="token punctuation">:</span> atom.xml  <span class="token key atrule">limit</span><span class="token punctuation">:</span> <span class="token number">20</span>  <span class="token key atrule">hub</span><span class="token punctuation">:</span>  <span class="token key atrule">content</span><span class="token punctuation">:</span>  <span class="token key atrule">content_limit</span><span class="token punctuation">:</span> <span class="token number">140</span>  <span class="token key atrule">content_limit_delim</span><span class="token punctuation">:</span> <span class="token string">" "</span>  <span class="token key atrule">order_by</span><span class="token punctuation">:</span> <span class="token punctuation">-</span>date<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>执行 <code>hexo clean &amp;&amp; hexo g</code> 重新生成博客文件，然后在 <code>public</code> 文件夹中即可看到 <code>atom.xml</code> 文件，说明已经安装成功了。</p><h2 id="自定制修改"><a href="#自定制修改" class="headerlink" title="自定制修改"></a>自定制修改</h2><p>在本主题的 <code>_config.yml</code> 中可以修改部分自定义信息，有以下几个部分：</p><ul><li>菜单</li><li>我的梦想</li><li>首页的音乐播放器和视频播放器配置</li><li>是否显示推荐文章名称和按钮配置</li><li><code>favicon</code> 和 <code>Logo</code></li><li>个人信息</li><li>TOC 目录</li><li>文章打赏信息</li><li>复制文章内容时追加版权信息</li><li>MathJax</li><li>文章字数统计、阅读时长</li><li>点击页面的’爱心’效果</li><li>我的项目</li><li>我的技能</li><li>我的相册</li><li><code>Gitalk</code>、<code>Gitment</code>、<code>Valine</code> 和 <code>disqus</code> 评论配置</li><li><a href="http://busuanzi.ibruce.info/" target="_blank" rel="noopener">不蒜子统计</a>和谷歌分析（<code>Google Analytics</code>）</li><li>默认特色图的集合。当文章没有设置特色图时，本主题会根据文章标题的 <code>hashcode</code> 值取余，来选择展示对应的特色图</li></ul><p>如果本主题中的诸多功能和主题色彩你不满意，可以在主题中自定义修改，很多更自由的功能和细节点的修改难以在主题的 <code>_config.yml</code> 中完成，需要修改源代码才来完成。以下列出了可能有用的地方：</p><h3 id="修改主题颜色"><a href="#修改主题颜色" class="headerlink" title="修改主题颜色"></a>修改主题颜色</h3><p>在主题文件的 <code>/source/css/matery.css</code> 文件中，搜索 <code>.bg-color</code> 来修改背景颜色：</p><pre class="line-numbers language-css"><code class="language-css"><span class="token comment" spellcheck="true">/* 整体背景颜色，包括导航、移动端的导航、页尾、标签页等的背景颜色. */</span><span class="token selector"><span class="token class">.bg-color</span> </span><span class="token punctuation">{</span>  <span class="token property">background-image</span><span class="token punctuation">:</span> <span class="token function">linear-gradient</span><span class="token punctuation">(</span>to right, <span class="token hexcode">#4cbf30</span> <span class="token number">0%</span>, <span class="token hexcode">#0f9d58</span> <span class="token number">100%</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token atrule"><span class="token rule">@-webkit-keyframes</span> rainbow</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">/* 动态切换背景颜色. */</span><span class="token punctuation">}</span><span class="token atrule"><span class="token rule">@keyframes</span> rainbow</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">/* 动态切换背景颜色. */</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="修改-banner-图和文章特色图"><a href="#修改-banner-图和文章特色图" class="headerlink" title="修改 banner 图和文章特色图"></a>修改 banner 图和文章特色图</h3><p>可以直接在 <code>/source/medias/banner</code> 文件夹中更换喜欢的 <code>banner</code> 图片，主题代码中是每天动态切换一张，只需 <code>7</code> 张即可。如果会 <code>JavaScript</code> 代码，可以修改成自己喜欢切换逻辑，如：随机切换等，<code>banner</code> 切换的代码位置在 <code>/layout/_partial/bg-cover-content.ejs</code> 文件的 <code>&lt;script&gt;&lt;/script&gt;</code> 代码中：</p><pre class="line-numbers language-javascript"><code class="language-javascript"><span class="token function">$</span><span class="token punctuation">(</span><span class="token string">".bg-cover"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">css</span><span class="token punctuation">(</span><span class="token string">"background-image"</span><span class="token punctuation">,</span> <span class="token string">"url(/medias/banner/"</span> <span class="token operator">+</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getDay</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">".jpg)"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在 <code>/source/medias/featureimages</code> 文件夹中默认有 24 张特色图片，你可以再增加或者减少，并需要在 <code>_config.yml</code> 做同步修改。</p><h2 id="文章-Front-matter-介绍"><a href="#文章-Front-matter-介绍" class="headerlink" title="文章 Front-matter 介绍"></a>文章 Front-matter 介绍</h2><h3 id="Front-matter-选项详解"><a href="#Front-matter-选项详解" class="headerlink" title="Front-matter 选项详解"></a>Front-matter 选项详解</h3><p><code>Front-matter</code> 选项中的所有内容均为<strong>非必填</strong>的。但仍然建议至少填写 <code>title</code> 和 <code>date</code> 的值。</p><table><thead><tr><th>配置选项</th><th>默认值</th><th>描述</th></tr></thead><tbody><tr><td>title</td><td><code>Markdown</code> 的文件标题</td><td>文章标题</td></tr><tr><td>date</td><td>文件创建时的日期时间</td><td>发布时间，应保证全局唯一</td></tr><tr><td>author</td><td>根 <code>_config.yml</code> 中的 <code>author</code></td><td>文章作者</td></tr><tr><td>img</td><td><code>featureImages</code> 中的某个值</td><td>文章特征图</td></tr><tr><td>top</td><td><code>true</code></td><td>文章是否置顶，值为 <code>true</code>，则会作为首页推荐文章</td></tr><tr><td>cover</td><td><code>false</code></td><td>是否需要加入到首页轮播封面中</td></tr><tr><td>coverImg</td><td>无</td><td>该文章在首页轮播封面需要显示的图片路径，如果没有，则默认使用文章的特色图片</td></tr><tr><td>password</td><td>无</td><td>文章阅读密码，该值必须是用 <code>SHA256</code> 加密后的密码，防止被他人识破。</td></tr><tr><td>toc</td><td><code>true</code></td><td>是否开启 TOC，可以针对某篇文章单独关闭 TOC 的功能。</td></tr><tr><td>mathjax</td><td><code>false</code></td><td>是否开启数学公式支持</td></tr><tr><td>summary</td><td>无</td><td>文章卡片摘要显示的文字，如果无值程序会自动截取文章的部分内容作为摘要</td></tr><tr><td>categories</td><td>无</td><td>文章分类，建议一篇文章一个分类</td></tr><tr><td>tags</td><td>无</td><td>文章标签，一篇文章可以多个标签</td></tr></tbody></table><blockquote><p><strong>注意</strong>:</p><ol><li>如果 <code>img</code> 属性不填写的话，文章特色图会根据文章标题的 <code>hashcode</code> 的值取余，然后选取主题中对应的特色图片，从而达到让所有文章都的特色图<strong>各有特色</strong>。</li><li><code>date</code> 的值尽量保证每篇文章是唯一的，因为本主题中 <code>Gitalk</code> 和 <code>Gitment</code> 识别 <code>id</code> 是通过 <code>date</code> 的值来作为唯一标识的。</li><li>如果要对文章设置阅读验证密码的功能，不仅要在 Front-matter 中设置采用了 SHA256 加密的 password 的值，还需要在主题的 <code>_config.yml</code> 中激活了配置。有些在线的 SHA256 加密的地址，可供使用：<a href="http://tool.oschina.net/encrypt?type=2" target="_blank" rel="noopener">开源中国在线工具</a>、<a href="http://encode.chahuo.com/" target="_blank" rel="noopener">chahuo</a>、<a href="http://tool.chinaz.com/tools/hash.aspx" target="_blank" rel="noopener">站长工具</a>。</li></ol></blockquote><p>以下为文章的 <code>Front-matter</code> 示例。</p><h3 id="最简示例"><a href="#最简示例" class="headerlink" title="最简示例"></a>最简示例</h3><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token punctuation">---</span><span class="token key atrule">title</span><span class="token punctuation">:</span> 基于Hexo的hexo<span class="token punctuation">-</span>theme<span class="token punctuation">-</span>matery主题搭建博客并优化<span class="token key atrule">date</span><span class="token punctuation">:</span> <span class="token datetime number">2019-10-03 14:25:00</span><span class="token punctuation">---</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="最全示例"><a href="#最全示例" class="headerlink" title="最全示例"></a>最全示例</h3><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token punctuation">---</span><span class="token key atrule">title</span><span class="token punctuation">:</span> 基于Hexo的hexo<span class="token punctuation">-</span>theme<span class="token punctuation">-</span>matery主题搭建博客并优化<span class="token key atrule">date</span><span class="token punctuation">:</span> <span class="token datetime number">2019-10-03 14:25:00</span><span class="token key atrule">author</span><span class="token punctuation">:</span> 悟尘<span class="token key atrule">img</span><span class="token punctuation">:</span> /source/images/xxx.jpg<span class="token key atrule">top</span><span class="token punctuation">:</span> <span class="token boolean important">true</span><span class="token key atrule">cover</span><span class="token punctuation">:</span> <span class="token boolean important">true</span><span class="token key atrule">coverImg</span><span class="token punctuation">:</span> /images/1.jpg<span class="token key atrule">password</span><span class="token punctuation">:</span> 8d969eef6ecad3c29a3a629280e686cf0c3f5d5a86aff3ca12020c923adc6c92<span class="token key atrule">toc</span><span class="token punctuation">:</span> <span class="token boolean important">false</span><span class="token key atrule">mathjax</span><span class="token punctuation">:</span> <span class="token boolean important">false</span><span class="token key atrule">summary</span><span class="token punctuation">:</span> 这是你自定义的文章摘要内容，如果这个属性有值，文章卡片摘要就显示这段文字，否则程序会自动截取文章的部分内容作为摘要<span class="token key atrule">categories</span><span class="token punctuation">:</span> 工具<span class="token key atrule">tags</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> blog  <span class="token punctuation">-</span> hexo<span class="token punctuation">---</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="SEO-优化"><a href="#SEO-优化" class="headerlink" title="SEO 优化"></a>SEO 优化</h2><p>搜索引擎优化，又称为 SEO，即 Search Engine Optimization，它是一种通过分析搜索引擎的排名规律，了解各种搜索引擎怎样进行搜索、怎样抓取互联网页面、怎样确定特定关键词的搜索结果排名的技术。Google 自动收录效果还不错，百度就差得远了（<code>GitHub</code>不允许百度的<code>Spider</code>爬取<code>GitHub</code>上的内容）。</p><p>安装 sitemap 插件生成站点地图文件:</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">npm</span> <span class="token function">install</span> hexo-generator-sitemap --save<span class="token function">npm</span> <span class="token function">install</span> hexo-generator-baidu-sitemap --save  <span class="token comment" spellcheck="true">#百度专用</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>安装后直接执行 <code>hexo cl&amp;&amp;hexo g -d</code> 命令，就会在网站根目录生成 <code>sitemap.xml</code> 及 <code>baidusitemap.xml</code> 文件。</p><h3 id="百度优化"><a href="#百度优化" class="headerlink" title="百度优化"></a>百度优化</h3><p>登录<a href="https://ziyuan.baidu.com/" target="_blank" rel="noopener">百度搜索资源平台</a>， 登录成功之后在 用户中心 –&gt; 站点管理 页面中点击<a href="https://ziyuan.baidu.com/site/siteadd" target="_blank" rel="noopener">添加网站</a>，按提示操作。</p><p><img src="https://pic.lixl.cn/2020/20200129213302.png/w1280" alt="添加网站"></p><blockquote><p>提示：由于百度的 spider 是爬取不到 GitHub 的内容的，所以在第三步验证网站的时候，建议选择<code>CNAME验证</code>的方式。</p></blockquote><p>经过以上步骤，百度已经知道有我们网站的存在了，但是百度还不知道我们的网站上有什么内容，所以要向百度推送我们的内容。点击 网站支持 –&gt; 数据引入 –&gt; 链接提交菜单，提交站点地图：<br><img src="https://pic.lixl.cn/2020/20200130153759.png/w1280" alt="提交站点地图"></p><p>另外，<code>hexo-theme-matery</code>主题已经内置了 <code>自动推送</code> 的功能， 检查 <code>themes/hexo-theme-matery/_config.yml</code> 文件中如下配置:</p><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token comment" spellcheck="true"># 百度搜索资源平台提交链接</span><span class="token key atrule">baiduPush</span><span class="token punctuation">:</span> <span class="token boolean important">true</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>自动推送的 JS 代码部署在站点的每一个页面源代码中，当页面在每次被浏览时，链接就会被自动推送给百度。</p><h3 id="谷歌优化"><a href="#谷歌优化" class="headerlink" title="谷歌优化"></a>谷歌优化</h3><p>登录 <a href="https://search.google.com/search-console?hl=zh-CN" target="_blank" rel="noopener">Google Search Console</a>，点击添加资源，输入自己的域名，按提示操作。</p><p><img src="https://pic.lixl.cn/2020/20200129214720.png/w1280" alt="添加资源"></p><blockquote><p>提示：需要进行 DNS 验证，进入 DNS 域名解析设置页面，按提示增加 TXT 记录，如下图:<br><img src="https://pic.lixl.cn/2020/20200129215358.png/w1280" alt="DNS验证内容填写示例"></p></blockquote><p>验证成功后，需要提交站点地图。参照下图提交，然后等待收录。<br><img src="https://pic.lixl.cn/2020/20200129223124.png/w1280" alt="提交站点地图"></p><blockquote><p>注意：hexo 配置文件中的 url 一定要输入正确的域名，插件是根据 url 生成站点地图的。</p></blockquote><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><h3 id="指令说明"><a href="#指令说明" class="headerlink" title="指令说明"></a>指令说明</h3><p><code>hexo server</code> #启动本地服务器，用于预览主题。Hexo 会监视文件变动并自动更新，除修改站点配置文件外,无须重启服务器,直接刷新网页即可生效。</p><p><code>hexo server -s</code> #以静态模式启动</p><p><code>hexo server -p 5000</code> #更改访问端口 (默认端口为 4000，’ctrl + c’关闭 server)</p><p><code>hexo server -i IP地址</code> #自定义 IP</p><p><code>hexo clean</code> #清除缓存 ,网页正常情况下可以忽略此条命令,执行该指令后,会删掉站点根目录下的 public 文件夹</p><p><code>hexo g</code> #生成静态网页 (执行 $ <code>hexo g</code>后会在站点根目录下生成 public 文件夹, hexo 会将”/blog/source/“ 下面的.md 后缀的文件编译为.html 后缀的文件,存放在”/blog/public/ “ 路径下)</p><p><code>hexo d</code> #自动生成网站静态文件，并将本地数据部署到设定的仓库(如 github)</p><p><code>hexo init</code> 文件夹名称 #初始化 XX 文件夹名称</p><p><code>npm update hexo -g</code>#升级</p><p><code>npm install hexo -g</code> #安装</p><p><code>node-v</code> #查看 node.js 版本号</p><p><code>npm -v</code> #查看 npm 版本号</p><p><code>git --version</code> #查看 git 版本号</p><p><code>hexo -v</code> #查看 hexo 版本号</p><h3 id="简写指令"><a href="#简写指令" class="headerlink" title="简写指令"></a>简写指令</h3><p><code>hexo n &quot;我的第一篇文章&quot;</code> 等价于 <code>hexo new &quot;我的第一篇文章&quot;</code> 还等价于 <code>hexo new post &quot;我的第一篇文章&quot;</code></p><p><code>hexo p</code> 等价于 <code>hexo publish</code></p><p><code>hexo g</code> 等价于 <code>hexo generate</code></p><p><code>hexo s</code>等价于 <code>hexo server</code></p><p><code>hexo d</code> 等价于 <code>hexo deploy</code></p><p><code>hexo g -d</code>等价于<code>hexo generate --deploy</code></p><p>注: <code>hexo clean</code> 没有 简写, <code>git --version</code> 没有简写</p><h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><p><strong>1. 通过<code>hexo g -d</code>部署时报<code>Error: Spawn failed</code>错误:</strong></p><blockquote><p>这是由于 git 本地记录的提交版本号与 github 上不一致导致的，通过<code>git reset --hard commitCode</code>即可解决。</p></blockquote><ul><li>检查本地最近提交记录，获取最后一次提交记录的更新时间及标识，如<code>280a7fdd46fcfd7d34e652aec15523dcd247fac8</code></li></ul><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">cd</span> .deploy_git<span class="token function">cat</span> .git/logs/HEAD<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li>获取 github pages 服务所关联分支的最近一次提交记录，获取更新时间及标识。地址一般为：<code>https://github.com/用户名/仓库名/commits/分支名</code>，如<code>https://github.com/lxl80/blog/commits/gh-pages</code></li><li>如果发现提交最新的提交时间/标识不一致，通过以下命令即可解决:</li></ul><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">git</span> reset --hard f085038efdf79546c09641d37b2a2429c1ae8e60 <span class="token comment" spellcheck="true">#github上最新的提交标识</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="参照"><a href="#参照" class="headerlink" title="参照"></a>参照</h2><ul><li><a href="https://hexo.io/zh-cn/docs/" target="_blank" rel="noopener">hexo 官方文档</a></li><li><a href="https://blinkfox.github.io/2018/09/28/qian-duan/hexo-bo-ke-zhu-ti-zhi-hexo-theme-matery-de-jie-shao/" target="_blank" rel="noopener">闪烁之狐</a></li><li><a href="https://github.com/blinkfox/hexo-theme-matery/blob/develop/README_CN.md" target="_blank" rel="noopener">hexo-theme-matery</a></li><li><a href="https://blog.sky03.cn/posts/42790.html#toc-heading-1" target="_blank" rel="noopener">Hexo 进阶之各种优化</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> blog </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Tensorflow2.0入门实战</title>
      <link href="/2019/090963177.html"/>
      <url>/2019/090963177.html</url>
      
        <content type="html"><![CDATA[<p>TensorFlow 是 2015 年年底开源的一套深度学习框架，是目前最活跃的深度学习框架。本文基于 2.0 版本，首先介绍它的安装和基本用法，然后讨论了深度学习的基本概念，包括神经网络前向计算、损失函数、反向传播计算和优化函数等，接着介绍了卷积神经网络和循环神经网络，最后介绍了在大规模应用的场景下，如何实现分布式的深度学习训练。</p><h3 id="安装-Tensorflow-环境"><a href="#安装-Tensorflow-环境" class="headerlink" title="安装 Tensorflow 环境"></a>安装 Tensorflow 环境</h3><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 安装python3,pip</span><span class="token function">sudo</span> yum -y <span class="token function">install</span> epel-release<span class="token function">sudo</span> yum -y <span class="token function">install</span> gcc gcc-c++ python3-pip python-devel atlas atlas-devel gcc-gfortran openssl-devel libffi-devel<span class="token comment" spellcheck="true">#更新python国内源</span> <span class="token function">mkdir</span> ~/.pip vim ~/.pip/pip.conf  <span class="token punctuation">[</span>global<span class="token punctuation">]</span>  index-url <span class="token operator">=</span> https://pypi.mirrors.ustc.edu.cn/simple/  <span class="token punctuation">[</span>install<span class="token punctuation">]</span>  trusted-host <span class="token operator">=</span> mirrors.ustc.edu.cn<span class="token comment" spellcheck="true"># 安装virtualenv</span>pip3 <span class="token function">install</span> --upgrade virtualenvvirtualenv --system-site-packages ~/venvs/tensorflowcurl<span class="token function">sudo</span> python get-pip.pypip --version<span class="token function">sudo</span> pip <span class="token function">install</span> virtualenvvirtualevn --version<span class="token comment" spellcheck="true"># 创建python虚拟环境</span>virtualenv --system-site-packages -p python2.7 ./venv<span class="token comment" spellcheck="true"># 激活虚拟环境</span><span class="token function">source</span> venv/bin/activate<span class="token comment" spellcheck="true"># 安装Tensorflow</span>pip <span class="token function">install</span>  -i http://mirrors.aliyun.com/pypi/simple/ tensorflow<span class="token comment" spellcheck="true"># 查看安装的软件</span>pip list installed<span class="token comment" spellcheck="true">#通过python交互式环境验证安装是否成功</span>python<span class="token function">import</span> tensorflow as tfexit<span class="token punctuation">(</span><span class="token punctuation">)</span>  //退出python交互环境deactivate  //退出python虚拟环境<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Helloworld-示例验证"><a href="#Helloworld-示例验证" class="headerlink" title="Helloworld 示例验证"></a>Helloworld 示例验证</h3><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">source</span> venv/bin/activatepython //进入python交互式环境<span class="token function">import</span> tensorflow as tfhello <span class="token operator">=</span> tf.constant<span class="token punctuation">(</span>"hello tensorflow.<span class="token punctuation">)</span>sess <span class="token operator">=</span> tf.Session<span class="token punctuation">(</span><span class="token punctuation">)</span>sess.run<span class="token punctuation">(</span>hello<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="在-Jupyter-交互式环境中使用-Tensorflow"><a href="#在-Jupyter-交互式环境中使用-Tensorflow" class="headerlink" title="在 Jupyter 交互式环境中使用 Tensorflow"></a>在 Jupyter 交互式环境中使用 Tensorflow</h3><pre class="line-numbers language-bash"><code class="language-bash">pip <span class="token function">install</span> jupyterpython -m ipykernel <span class="token function">install</span> --user --name<span class="token operator">=</span>venvjupyter kernelspec listjupyter notebook //自动打开浏览器<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="在-Docker-中使用-Tensorflow"><a href="#在-Docker-中使用-Tensorflow" class="headerlink" title="在 Docker 中使用 Tensorflow"></a>在 Docker 中使用 Tensorflow</h3><pre class="line-numbers language-bash"><code class="language-bash">docker pull tensorflow/tensorflow:nightly-jupytervim docker-compose.yml <span class="token comment" spellcheck="true">#制作配置文件</span>docker-compose up -d <span class="token comment" spellcheck="true">#初次启动，以后用start/stop</span>docker <span class="token function">exec</span> -it xxxx <span class="token function">bash</span> <span class="token comment" spellcheck="true">#进入docker,然后执行如下命令升级安装Python3</span> <span class="token function">apt-get</span> update <span class="token function">apt-get</span> <span class="token function">install</span> python-software-properties <span class="token function">apt-get</span> <span class="token function">install</span> python3.6 apt <span class="token function">install</span> python3-pip <span class="token comment" spellcheck="true">#更新python国内源</span> <span class="token function">mkdir</span> ~/.pip vim ~/.pip/pip.conf  <span class="token punctuation">[</span>global<span class="token punctuation">]</span>  index-url <span class="token operator">=</span> https://pypi.mirrors.ustc.edu.cn/simple/  <span class="token punctuation">[</span>install<span class="token punctuation">]</span>  trusted-host <span class="token operator">=</span> mirrors.ustc.edu.cn <span class="token comment" spellcheck="true">#在jupyter中启用python3</span> jupyter kernelspec list <span class="token comment" spellcheck="true"># 查看激活的kernel</span> python3 -m pip <span class="token function">install</span> ipykernel python3 -m ipykernel <span class="token function">install</span> --user <span class="token function">rm</span> /usr/local/bin/python <span class="token function">ln</span> -s /usr/bin/python3.6 /usr/local/bin/python python --version  <span class="token comment" spellcheck="true">#显示Python 3.6.x，则安装成功</span> pip <span class="token function">install</span> --upgrade tensorflow jupyter matplotlib pandas seaborn numpy tensorflow-hub tensorflow-datasets pillow pip list installed<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>使用 docker-compose 管理容器</li></ul><pre class="line-numbers language-ymal"><code class="language-ymal">version:  '3'services:  tensorflow-jupyter:    image: tensorflow/tensorflow:nightly-jupyter    ports:      - "8888:8888"      - "6006:6006"    volumes:      - .:/tf/notebooks<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>启动： docker-compose up</p><h3 id="Tensorflow-架构介绍"><a href="#Tensorflow-架构介绍" class="headerlink" title="Tensorflow 架构介绍"></a>Tensorflow 架构介绍</h3><p><img src="https://pic4.zhimg.com/80/v2-14f1196030f7bd2db1ceff96bc9b0ddb_hd.jpg" alt="Tensorflow架构图一"><br><img src="https://picabstract-preview-ftn.weiyun.com/ftn_pic_abs_v3/3b16e5b406f603289fdeb140ee76e14190f57f14a72d49c11aea6fbd116b59234c971528be44e40cf6d42d638a2c3b14?pictype=scale&from=30113&version=3.3.3.3&size=750=" alt="Tensorflow架构图二"><br><img src="https://picabstract-preview-ftn.weiyun.com/ftn_pic_abs_v3/4250deb81e391cffa189c9d95f4a4e1c74c1fbb43c6a60b0ddd5efea4acd47ba090e0f3c42b5146ddfe7d7edf6bc8686?pictype=scale&from=30113&version=3.3.3.3&size=750=" alt=""></p><h3 id="实战：使用-CNN-识别彩色尺寸各异的猫狗图片"><a href="#实战：使用-CNN-识别彩色尺寸各异的猫狗图片" class="headerlink" title="实战：使用 CNN 识别彩色尺寸各异的猫狗图片"></a>实战：使用 CNN 识别彩色尺寸各异的猫狗图片</h3><p>​ 参考 <a href="https://colab.research.google.com/drive/1WerlZnNfh7N4RqO26gbctQ6NINkMxPkO" target="_blank" rel="noopener">Colab</a></p><h4 id="扁平化处理"><a href="#扁平化处理" class="headerlink" title="扁平化处理"></a>扁平化处理</h4><p>调整尺寸为一致的 150 * 150，以便可以生成相同大小的一位数组</p><h4 id="彩色图像处理"><a href="#彩色图像处理" class="headerlink" title="彩色图像处理"></a>彩色图像处理</h4><p>使用三维数组建模，增加 RGB 作为 3 维数组的深度值，如图：<br><img src="https://picabstract-preview-ftn.weiyun.com/ftn_pic_abs_v3/0479c21b4302a6c26eb97984094a43864ca895cb1e33bb3f41de3f5a7d408d9d7a723f11ff403adc1ea9749c252ae77e?pictype=scale&from=30113&version=3.3.3.3&size=750=" alt=""></p><h4 id="对彩色图像执行卷积运算"><a href="#对彩色图像执行卷积运算" class="headerlink" title="对彩色图像执行卷积运算"></a>对彩色图像执行卷积运算</h4><ul><li>将彩色图像分解为 3 维数组<br><img src="https://picabstract-preview-ftn.weiyun.com/ftn_pic_abs_v3/c50a4ac38c7ce1aba88acd8610c03e76ca95fe46cdd25a11313bf9f5626602d00af10dc4b8cbab30601f6c19eb1a30ae?pictype=scale&from=30113&version=3.3.3.3&uin=369888789&fname=111.png&size=750" alt=""></li><li>利用三个过滤核进行卷积运算示例<br><img src="https://picabstract-preview-ftn.weiyun.com/ftn_pic_abs_v3/d5867af3457e0692e7d8e33c54aa169ac453c7e75c4a9a9e634b195027b320c708e3aa95b9f8c2c048096570fffb3f4e?pictype=scale&from=30113&version=3.3.3.3&uin=369888789&fname=112.png&size=450" alt=""></li><li>示例中使用三个三维过滤器进行卷积运算<br><img src="https://picabstract-preview-ftn.weiyun.com/ftn_pic_abs_v3/c059b5c447235ce967e6a6624cc566aa1905b7e2ab7754c0c23b38b32dd9059dc59fc3c7eae44bdb951220dcbbc79e53?pictype=scale&from=30113&version=3.3.3.3&uin=369888789&fname=WX20190913-163837%402x.png&size=750" alt="使用三个过滤核进行卷积运算获得的三维结果"></li><li>代码说明</li></ul><pre class="line-numbers language-python"><code class="language-python">  tf<span class="token punctuation">.</span>keras<span class="token punctuation">.</span>layers<span class="token punctuation">.</span>Conv2D<span class="token punctuation">(</span>filters<span class="token punctuation">,</span> kernel_size<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">#  参数：过滤器数量, 卷积核形状, ...</span>  <span class="token comment" spellcheck="true">#本例中使用：</span>  tf<span class="token punctuation">.</span>keras<span class="token punctuation">.</span>layers<span class="token punctuation">.</span>Conv2D<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>​ 在训练 CNN 时，将通过损失函数更新三维核中的值，从而最小化损失。</p><h4 id="执行最大池化运算"><a href="#执行最大池化运算" class="headerlink" title="执行最大池化运算"></a>执行最大池化运算</h4><p><img src="https://picabstract-preview-ftn.weiyun.com/ftn_pic_abs_v3/9f7687a18e5b38514ae2a90d6fc13fdbeec4ce39957fb08f465afbf43f16b912d982cdb72fb9f3d24e7cd455d1ffec8f?pictype=scale&amp;from=30113&amp;version=3.3.3.3&amp;uin=369888789&amp;fname=WX20190913-175829%402x.png&amp;size=750=" alt=""></p><p>最大池化处理后，获得的三维数组宽度和高度减半，但深度不变。</p><h4 id="使用验证集解决过拟合问题（早停法）"><a href="#使用验证集解决过拟合问题（早停法）" class="headerlink" title="使用验证集解决过拟合问题（早停法）"></a>使用验证集解决过拟合问题（早停法）</h4><p>​ 通常在完成训练后，在测试集上进行验证才能发现过拟合问题。可以通过增加验证集，在每轮训练过程中基于验证集检查效果，分析训练损失和验证损失与周期的函数图，可判断出模型泛化效果。</p><p><img src="https://picabstract-preview-ftn.weiyun.com/ftn_pic_abs_v3/e8f7b98ddbbc9f117c5d1bf110d76ef3b414866b0b6e3539338b3216fe451f8aa59c6ffa5601e4c59d970ba8ecffb2db?pictype=scale&from=30113&version=3.3.3.3&uin=369888789&fname=WX20190913-201908%402x.png&size=750" alt=""></p><p>可以看出，验证集有助于我们判断 CNN 应该训练多少个周期，即可以达到较好的训练效果又不会出现过拟合，提前结束训练一遍获取最优模型。对于有多个潜在模型可选择时（如为模型选择合适的参数/结构），也可以用这种方法对比选择最优模型。</p><blockquote><p>如果训练集足够广泛（如各种各样可能的图片都有，如大小，位置，猫狗完整性等），将有助于训练出泛化能力强的模型。</p></blockquote><h4 id="使用图像增加技术避免过拟合"><a href="#使用图像增加技术避免过拟合" class="headerlink" title="使用图像增加技术避免过拟合"></a>使用图像增加技术避免过拟合</h4><p>​ 通过应用各种图片变换，可以增加样本数量，提高泛化能力避免过拟合的效果。</p><p><img src="https://picabstract-preview-ftn.weiyun.com/ftn_pic_abs_v3/0d8bfb44efdffc9b668a4823a975c2cf71f25fa4d821352a1d1ca753744267a8df99e53f85482386e6a262712cfef8dc?pictype=scale&from=30113&version=3.3.3.3&uin=369888789&fname=WX20190913-204934%402x.png&size=750" alt=""></p><h3 id="使用随机丢弃避免过拟合（仅限深度神经网络）"><a href="#使用随机丢弃避免过拟合（仅限深度神经网络）" class="headerlink" title="使用随机丢弃避免过拟合（仅限深度神经网络）"></a>使用随机丢弃避免过拟合（仅限深度神经网络）</h3><p>​ 丢弃是指在训练过程中，随机关闭网络中的某些神经元。可以强制其它神经元产生更大的影响，在训练中扮演积极角色，如图：</p><p><img src="https://picabstract-preview-ftn.weiyun.com/ftn_pic_abs_v3/2c5a2132d7102530a3931a7105d7a8072be268a23bce15834b5e7535b6980e861cd49cbe5491ab8a854259885654f033?pictype=scale&from=30113&version=3.3.3.3&uin=369888789&fname=WX20190913-211219%402x.png&size=750" alt=""></p><p>在实践中，会指定每个训练周期每个神经元被丢弃的概率。</p><h3 id="实战：-图片增强的狗与猫图片分类"><a href="#实战：-图片增强的狗与猫图片分类" class="headerlink" title="实战： 图片增强的狗与猫图片分类"></a>实战： 图片增强的狗与猫图片分类</h3><p>参考<a href="https://colab.research.google.com/drive/1d3BmTUhMi4zFL9p4PMrKObJvfwj1zvFL#scrollTo=LZPYT-EmVrWo" target="_blank" rel="noopener">Colab</a>，我们将遵循一般的机器学习流程:</p><ul><li>Examine and understand data 检查和理解数据</li><li>Build an input pipeline 构建输入管道</li><li>Build our model 建立我们的模型</li><li>Train our model 训练我们的模型</li><li>Test our model 测试我们的模型</li><li>Improve our model/Repeat the process 改进我们的模型 / 重复这个过程</li></ul><h3 id="其它避免过拟合的技巧"><a href="#其它避免过拟合的技巧" class="headerlink" title="其它避免过拟合的技巧"></a>其它避免过拟合的技巧</h3><ul><li><p>收集更多数据及添加噪音：这和数据增强的目的是一样的，但是也会使模型对于自然界中可能遇到的干扰更加稳定。</p></li><li><p>简化模型：通过逐步降低模型的复杂性ーー随机森林中估计值的数目、神经网络中参数的数目等ーー你可以使模型足够简单，不会过度拟合，但也足够复杂，可以从你的数据中学习。 要做到这一点，根据模型的复杂性来查看两个数据集上的错误是很方便的。</p></li><li><p>改变训练方式：包括改变损失函数，或者模型在训练期间的工作方式。</p></li><li><p>正则化：正则化是一个约束模型学习以减少过拟合的过程。 其中一个最强大的和众所周知的技术正则化是增加一个惩罚的损失函数。 最常见的是 L1 和 L2。L1 惩罚的目的是最小化权重的绝对值，这有助于识别数据集中最相关的特性。L2 惩罚的目的是使权重的平方最小化，效率高于 L1。通过惩罚，该模型被迫在权重上做出妥协，因为它不能再将权重任意增加。 这使得模型更加通用，有助于防止过拟合。</p><p>参考文章： <a href="https://hackernoon.com/memorizing-is-not-learning-6-tricks-to-prevent-overfitting-in-machine-learning-820b091dc42" target="_blank" rel="noopener">6 tricks to prevent overfitting in machine learning.</a></p></li></ul><h3 id="练习：增加版花朵图像分类"><a href="#练习：增加版花朵图像分类" class="headerlink" title="练习：增加版花朵图像分类"></a>练习：增加版花朵图像分类</h3><p>​ 参考：<a href="https://colab.research.google.com/drive/1uURGgGNTeeyJ4Zfeoz81ggmUARxuNhfK#scrollTo=tk5NT1PW3j_P" target="_blank" rel="noopener">自行练习版 Colab</a>，<a href="">官方版 Colab</a></p><h3 id="迁移学习"><a href="#迁移学习" class="headerlink" title="迁移学习"></a>迁移学习</h3><h4 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h4><p>迁移学习的原理是通过使用由机器学习专家创建的经过大型数据训练过的模型，将模型已经学习到的知识迁移到新的数据集上，可以显著提高预测准确率。如上面猫狗识别的实战可以将准确率从 80%提高到 95%</p><p><img src="https://picabstract-preview-ftn.weiyun.com/ftn_pic_abs_v3/8ec95bbbf4a17ab91b71cffaca9dca22f2f4020cd3b621c387f2972b0678f4ae35aec76d835f9c464c5a5f9edfed187b?pictype=scale&from=30113&version=3.3.3.3&uin=369888789&fname=WX20190914-130000%402x.png&size=750=" alt=""></p><p>​ 在迁移学习中，预训练的模型中的参数将被冻结（避免随机初始化权重），只训练最后分类层级的变量，可以显著提高训练速度。</p><p><img src="https://picabstract-preview-ftn.weiyun.com/ftn_pic_abs_v3/695902034ea19e36c9a7169926b7872bebc6f2c9f4aa53fa4aa88cc556012da1cb029e18d4688174459ef489ca77d718?pictype=scale&from=30113&version=3.3.3.3&uin=369888789&fname=WX20190914-130849%402x.png&size=750" alt=""><br>​ 示例代码：</p><p><img src="https://picabstract-preview-ftn.weiyun.com/ftn_pic_abs_v3/58b0e59034ade88fb41c26a1c7c918efc3eccfae6995ec8fb908883b250ea2273c2653bb2cfc96dbe6a6cb144570c40d?pictype=scale&from=30113&version=3.3.3.3&uin=369888789&fname=WX20190914-132906%402x.png&size=750" alt=""></p><p>​ 参考 Colab：<a href="https://colab.research.google.com/drive/1aGtbtCl2wSrcIMk9aadlJz2LtCHZ601R#scrollTo=3n0Wb9ylKd8R" target="_blank" rel="noopener">对猫狗数据集应用迁移学习</a> , <a href="https://colab.research.google.com/drive/177BHQe1KCLdzMvMW7TvSRfblPsG30fJV#scrollTo=oXiJjX0jfx1o" target="_blank" rel="noopener">通过迁移学习分类花朵图像</a></p><h3 id="实战：房价预测（线性回归）"><a href="#实战：房价预测（线性回归）" class="headerlink" title="实战：房价预测（线性回归）"></a>实战：房价预测（线性回归）</h3><h4 id="基础知识-1"><a href="#基础知识-1" class="headerlink" title="基础知识"></a>基础知识</h4><p><img src="https://picabstract-preview-ftn.weiyun.com/ftn_pic_abs_v3/9a5c4539cd94381da65ed1936112134e2b4a12ee162954ca027e4b288fe87ba83dcf95a32a54eaa18a52be096bb2d439?pictype=scale&from=30113&version=3.3.3.3&uin=369888789&fname=WX20190914-151749%402x.png&size=750" alt=""></p><p><img src="https://picabstract-preview-ftn.weiyun.com/ftn_pic_abs_v3/08aa206814b71996987241fb6f0cfaad6b870417d5ab71ee80d9795d49a33764f92bf4e4aacf94824ecb83a82f88ed63?pictype=scale&from=30113&version=3.3.3.3&uin=369888789&fname=WX20190914-153950%402x.png&size=750" alt=""></p><ul><li><p>matplotlib 是一个 Python 2D 绘图库，可以生成出版物质量级别的图像和各种硬拷贝格式，并广泛支持多种平台，如:Python 脚本，Python，IPython Shell 和 Jupyter Notebook。</p></li><li><p>seaborn 是一个基于 matplotlib 的 Python 数据可视化库。它提供了更易用的高级接口，用于绘制精美且信息丰富的统计图形。</p></li><li><p>mpl_toolkits.mplot3d 是一个基础 3D 绘图(散点图、平面图、折线图等)工具集，也是 matplotlib 库的一部分。同时，它也支持轻量级的独立安装模式。</p></li><li><p>NumPy 是一个 BSD 开源协议许可的，面向 Python 用户的基础科学计算库，在多 维数组上实现了线性代数、傅立叶变换和其他丰富的函数运算。</p><p><img src="https://picabstract-preview-ftn.weiyun.com/ftn_pic_abs_v3/f602ee77363996f0a1d8eae20742ca797fbdf93f868417b1733f05ed5dae75508b1bc5c10925984456133eb0f56014b9?pictype=scale&from=30113&version=3.3.3.3&uin=369888789&fname=WX20190914-171026%402x.png&size=750" alt=""></p></li></ul><h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><ul><li><a href="https://classroom.udacity.com/courses/ud187" target="_blank" rel="noopener">Tensorflow free course</a></li><li><a href="https://medium.com/tensorflow/introducing-tensorflow-hub-a-library-for-reusable-machine-learning-modules-in-tensorflow-cdee41fa18f9" target="_blank" rel="noopener">Introducing TensorFlow Hub: A Library for Reusable Machine Learning Modules in TensorFlow</a></li><li><a href="https://towardsdatascience.com/understanding-your-convolution-network-with-visualizations-a4883441533b" target="_blank" rel="noopener">Understanding your Convolution network with Visualizations</a></li><li><a href="https://time.geekbang.org/course/detail/153-78981" target="_blank" rel="noopener">TensorFlow 快速入门与实战</a></li><li><a href="https://www.cnblogs.com/guoyaohua/p/9265268.html" target="_blank" rel="noopener">Win10 安装 Tensorflow</a></li><li><a href="https://blog.csdn.net/xiaohuihui1994/article/details/83589701" target="_blank" rel="noopener">超详细：win10 安装 tensorflow-gpu1.8.0 完整步骤</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 人工智能 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tensorflow </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机器学习常用术语</title>
      <link href="/2019/090864521.html"/>
      <url>/2019/090864521.html</url>
      
        <content type="html"><![CDATA[<p>机器学习领域有着许多非常基本的术语，这些术语听来可能相当高深莫测、它们事实上也可能拥有非常复杂的数学背景，本文会对这些常用的基本术语进行说明与解释。</p><ul><li>人工智能：一种计算机科学分支，旨在让计算机达到人类的智慧。实现这一目标有很多方式，包括机器学习和深度学习。</li><li>机器学习：一系列相关技术，用于训练计算机执行特定的任务。</li><li>神经网络：一种机器学习结构，灵感来自人类大脑的神经元网络。神经网络是深度学习的基本概念。</li><li>深度学习：机器学习的一个分支，利用多层神经网络实现目标。通常“机器学习”和“深度学习”可以相互指代。</li><li>监督式学习：</li><li>非监督式学习：</li><li>训练流程：是指将网络的内部变量调整为最佳可能值，使它们能够将输入映射到输出。为了实现这个目标，我们将采用梯度下降法这一优化流程，它会使用数值分析找到模- 型内部变量的最佳可能值。</li><li>梯度下降法：梯度下降法会以迭代方式调整参数，每次朝着正确的方向小幅更改参数，直到达到最佳值。“最佳值”是指再调整的话，会降低模型的效果。在每次迭代过程中- 衡量模型好坏的函数称为“损失函数”，每次调整的目标是“最小化损失函数”。</li><li>特征：模型的输入</li><li>样本：用于训练流程的输入/输出对</li><li>标签：模型的输出</li><li>层级：神经网络中相互连接的节点集合。</li><li>模型：神经网络的表示法</li><li>密集全连接层 (FC)：一个层级中的每个节点都与上个层级中的每个节点相连。</li><li>权重和偏差：模型的内部变量</li><li>损失：期望输出和真实输出之间的差值</li><li>MSE：均方误差，一种损失函数，它会将一小部分很大的差值视作比大量很小的差值更糟糕。</li><li>梯度下降法：每次小幅调整内部变量，从而逐渐降低损失函数的算法。</li><li>优化器：梯度下降法的一种具体实现方法。（有很多算法。在这门课程中，我们将仅使用“Adam”优化器，它是 - ADAptive with Momentum 的简称，并且被视为最佳优化器。）</li><li>学习速率：梯度下降过程中的损失改进“步长”。</li><li>批次：在训练神经网络的过程中使用的一组样本。</li><li>周期：完全经过整个训练数据集一轮</li><li>前向传播：根据输入计算输出值</li><li>反向传播：根据优化器算法计算内部变量的调整幅度，从输出层级开始，并往回计算每个层级，直到抵达输入层。</li><li>扁平化：将二维图像转换为一维向量的过程</li><li>ReLU：一种激活函数，使模型能够解决非线性问题。如果它接收到任何负输入，则该函数返回0，但对于任何正值x，它返回该值。参考：<a href="https://www.kaggle.com/dansbecker/rectified-linear-units-relu-in-deep-learning" target="_blank" rel="noopener">深度学习中的 ReLU</a></li><li>Softmax：一种函数，能够为每个潜在输出类别生成概率</li><li>分类：一种机器学习模型，用于区分两个或多个输出类别</li><li>训练集：用于训练神经网络的数据。</li><li>测试集：用于测试神经网络最终效果的数据。</li><li>验证集：训练完毕时，使用验证集衡量模型的最终准确率。</li><li>递归：输出一个值的模型。例如，估算房屋价值。</li><li>分类：一种模型，能够输出多个类别的概率分布。</li><li>CNN：卷积神经网络。即至少有一个卷积层的网络。典型的 CNN 还包括其他类型的层级，例如池化层和密集层。</li><li>卷积：向图像应用核（滤波器）的过程</li><li>核/滤波器：小于输入的矩阵，用于将输入变成多个小区域</li><li>填充：在输入图像周围添加像素，像素值通常为 0</li><li>池化：通过下采样降低图像大小的过程。池化层有多种类型。例如，平均池化通过求平均值将多个值变成一个值。但是最大池化是最常见- 的池化类型。</li><li>最大池化：一种池化过程，通过获取多个值中的最大值，将多个值变成一个值。</li><li>步长：在图像上滑动核（滤波器）的间隔像素数量。</li><li>下采样：降低图像大小的操作</li></ul><h2 id="其它基础知识常用术语："><a href="#其它基础知识常用术语：" class="headerlink" title="其它基础知识常用术语："></a>其它基础知识常用术语：</h2><ul><li>线性与非线性：</li><li>一维向量：</li><li>方差：是指一组数据中的各个数减这组数据的平均数的平方和的平均数，如（1，2，3,4,5）这组数据的方差，就先求出这组数据的平均数（1+2+3+4+5）÷5＝3，然后再求各个数与平均数的差的平方和，用（1-3）²+（2-3）²+（3-3）²+（4-3）²+（5-3）²＝10，再求平均数10÷5＝2，即这组数据的方差为2. 意义：当数据分布比较分散（即数据在平均数附近波动较大）时，各个数据与平均数的差的平方和较大，方差就较大；当数据分布比较集中时，各个数据与平均数的差的平方和较小。因此方差越大，数据的波动越大；方差越小，数据的波动就越小。方差不仅仅表达了样本偏离均值的程度，更是揭示了样本内部彼此波动的程度，也可以理解为方差代表了样本彼此波动的期望。</li></ul><h2 id="常用算法模型"><a href="#常用算法模型" class="headerlink" title="常用算法模型"></a>常用算法模型</h2><ul><li><p>OpenPose：OpenPose人体姿态识别项目是美国卡耐基梅隆大学（CMU）基于卷积神经网络和监督学习并以caffe为框架开发的开源库。可以实现人体动作、面部表情、手指运动等姿态估计。适用于单人和多人，具有极好的鲁棒性。是世界上首个基于深度学习的实时多人二维姿态估计应用。其成功的一部分原因是它在 GitHub 上开源了其实现代码（ <a href="https://github.com/CMU-Perceptual-Computing-Lab/openpose" target="_blank" rel="noopener">https://github.com/CMU-Perceptual-Computing-Lab/openpose</a> ），并配有详细的说明文档。</p></li><li><p>DeepCut：DeepCut（ <a href="https://arxiv.org/abs/1511.06645" target="_blank" rel="noopener">https://arxiv.org/abs/1511.06645</a> ）是一个自底向上的多人人体姿态估计方法。</p></li><li><p>RMPE（AlphaPose）：是一个流行的自顶向下姿态估计算法。该论文的作者认为，自顶向下方法的性能通常依赖于人体检测器的精度，毕竟人体姿态估计是在检测器检出的框的区域内进行的。因此，错误的定位和重复的候选框会使姿态检测算法的性能降低。为解决这一问题，作者提出了使用对称空间变换网络（Symmetric Spatial Transformer Network，SSTN）来从不准确的候选框中抽取高质量的单人区域。然后，作者使用了一个单人的姿态估计器（Single Person Pose Estimator，SPPE）来从抽取到的区域中估计此人的姿态骨架。接着，作者用一个空间逆变换网络（Spatial De-Transformer Network，SDTN），将估计出的姿态重新映射到图像坐标系下。最后，用一个参数化的姿态非极大抑制（Non-Maximum Suppression，NMS）方法来处理重复预测的问题。另外，作者还引入了一种姿态候选生成器（Pose Guided Proposals Generator），来增广训练样本，以便更好地训练 SPPE 和 SSTN 网络。RMPE 的显著特征是，该方法可以推广到任意的人体检测算法和 SSPE 的组合。</p></li><li><p>Mask RCNN：Mask RCNN（ <a href="https://arxiv.org/abs/1703.06870" target="_blank" rel="noopener">https://arxiv.org/abs/1703.06870</a> ）是一个非常流行的语义和实例分割架构。该模型可以同时预测图像中多个物体的候选框位置及分割其语义信息的 mask。该模型的基础架构很容易被扩展到人体姿态估计上来。</p></li><li><p>DensePose：这是Mask-RCNN的一种变体，可以以每秒多帧的速度在每个人体区域内密集地回归特定部位的UV坐标。它基于一种能将图像像素通过卷积网络映射到密集网格的系统——DenseReg。模型的目标是决定每个像素在表面的位置以及它所在部分相对应的2D参数。DensePose借用了Mask-RCNN的架构，同时带有Feature Pyramid Network（FPN）的特征，以及ROI-Align池化。除此之外，他们在ROI池化的顶层搭建了一个全卷积网络。想了解DensePose更多的技术细节，请阅读原论文。</p></li><li><p>Realtime Multi-Person Pose Estimation： 这一模型和上面的OpenPose高度相关，同时特征模型能与多种框架相关联。论文的作者提供了一种自下而上的方法，对多人的姿态进行实时估计，不需要用任何人物探测器。这种方法运用了一种非参数表示，我们称为Part Affinity Fields（PAFs），用它可以学习将图中人物和其身体部位联系到一起。有关该技术的具体细节和理论，可以阅读原文。另外，这一方法最棒的特征之一就是它可以在多种不同的框架中实现，针对不同框架，已经公开了相关代码和模型。</p></li><li><p>AlphaPose：lphaPose是一款精准的多人姿态评估工具，并声称是第一款开源系统。AlphaPose既可以在图片、视频或多图中进行姿态估计，也能在画面中对动作进行追踪。它的输出形式非常广泛，包括PNG、JPG和AVI等具有关键点的图片形式，也有JSON格式的输出，这一特点也使其成为众多应用受欢迎的工具。目前，这一工具支持TensorFlow和PyTorch两种实现。AlphaPose利用一种区域性的多人动作估计框架将不精准的人类边界框该进程精确的动作估计。这里有三种元素：对称空间转换网络（SSTN）、参数化姿态非极大抑制（NMS）以及姿态导向的生成器（PGPG）。</p></li><li><p>DeepPose： DeepPose算是比较“古老”的了，论文发布与2014年，提出了一种基于深度神经网络的姿态估计方法，是基于DNN向身体关节回归的问题。它以一种整体的方式估计姿态，并且表述起来非常简洁强大。DeepPose是第一个将深度学习应用到人类姿态估计上的应用，并且取得了当时顶尖的结果，成为了其他方法的baseline。</p></li><li><p>MTCNN人脸检测：是2016年的论文提出来的，MTCNN的“MT”是指多任务学习(Multi-Task)，在同一个任务中同时学习”识别人脸“、”边框回归“、”人脸关键点识别“。相比2015年的CVPR(边框调整和识别人脸分开做)的结构，MTCNN是有创新的。</p></li><li><p>FaceNet：是 Google 研究人员于 2015 年开发的人脸识别系统，一个通用的系统，可以用于人脸验证（是否是同一人？），识别（这个人是谁？）和聚类（寻找类似的人？）。与其他的深度学习方法在人脸上的应用不同，FaceNet并没有用传统的softmax的方式去进行分类学习，然后抽取其中某一层作为特征，而是直接进行端对端学习一个从图像到欧式空间的编码方法，然后基于这个编码再做人脸识别、人脸验证和人脸聚类等。通过卷积神经网络学习将图像映射到欧几里得空间。空间距离直接和图片相似度相关：同一个人的不同图像在空间距离很小，不同人的图像在空间中有较大的距离。</p></li><li><p>CTPN：是在ECCV 2016提出的一种文字检测算法。CTPN结合CNN与LSTM深度网络，能有效的检测出复杂场景的横向分布的文字，是目前比较好的文字检测算法。 <a href="https://zhuanlan.zhihu.com/p/34757009" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/34757009</a></p></li><li><p>Faster RCNN：经过R-CNN和Fast RCNN的积淀，Ross B. Girshick在2016年提出了新的Faster RCNN，在结构上，Faster RCNN已经将特征抽取(feature extraction)，proposal提取，bounding box regression(rect refine)，classification都整合在了一个网络中，使得综合性能有较大提高，在检测速度方面尤为明显。</p></li><li><p>SLAM： Simultaneous Localization And Mapping的 英文首字母组合，一般翻译为：同时定位与建图、同时定位与地图构建。SLAM是指当某种移动设备（如机器人、无人机、手机等）从一个未知环境里的未知地点出发，在运动过程中通过传感器（如激光雷达、摄像头等）观测定位自身位置、姿态、运动轨迹，再根据自身位置进行增量式的地图构建，从而达到同时定位和地图构建的目的。定位和建图是两个相辅相成的过程，地图可以提供更好的定位，而定位也可以进一步扩建地图。需要说明的是，上述扫地机器人例子中，定位和建图是SLAM的基本要求，而路径规划是在此基础上的高级功能，不属于SLAM的讨论范畴。</p></li><li><p>SFM：Structure From Motion，通过相机的移动来确定目标的空间和几何关系，是三维重建的一种常见方法。<br>它与Kinect这种3D摄像头最大的不同在于，它只需要普通的RGB摄像头即可，因此成本更低廉，且受环境约束较小，<br>在室内和室外均能使用。</p></li><li><p>ResNet：ResNet是由微软研究院的Kaiming He等四名华人提出，他们通过自己提出的ResNet Unit成功训练出来152层的神经网络并在ILSVRC2015比赛中斩获冠军。ResNet语义分割领域最受欢迎且最广泛运用的神经网络.ResNet的核心思想就是在网络中引入恒等映射，允许原始输入信息直接传到后面的层中，在学习过程中可以只学习上一个网络输出的残差（F(x)），因此ResNet又叫做残差网络。、</p></li><li><p>R-CNN：伯克利大学的Girshick教授等人共同提出了首个在目标检测方向应用的深度学习模型：Region-based Convolutional Neural Network（R-CNN）。该网络模型如下图所示，其主要流程为：先使用selective search算法提取2000个候选框，然后通过卷积网络对候选框进行串行的特征提取，再根据提取的特征使用SVM对候选框进行分类预测，最后使用回归方法对区域框进行修正。</p><p><img src="https://pic2.zhimg.com/80/v2-bd5baff7669ca7ddce811c7149c11799_hd.jpg" alt=""></p></li><li><p>Fast R-CNN：由于R-CNN的效率太低，2015年由Ross等学者提出了它的改进版本：Fast R-CNN。其网络结构图如下图所示（从提取特征开始，略掉了region的选择）Fast R-CNN在传统的R-CNN模型上有所改进的地方是它是直接使用一个神经网络对整个图像进行特征提取，就省去了串行提取特征的时间；接着使用一个RoI Pooling Layer在全图的特征图上摘取每一个RoI对应的特征，再通过FC进行分类和包围框的修正。</p><p><img src="https://pic2.zhimg.com/80/v2-ae08e5aa35c2e8bfd65491e3c39888cd_hd.jpg" alt=""></p></li><li><p>Faster R-CNN：2016年提出的Faster R-CNN可以说有了突破性的进展（虽然还是目标检测哈哈哈），因为它改变了它的前辈们最耗时最致命的部位：selective search算法。它将selective search算法替换成为RPN，使用RPN网络进行region的选取，将2s的时间降低到10ms，其网络结构如下图所示：</p><p><img src="https://pic3.zhimg.com/80/v2-d7b27123e9e95200303959aeaf8816e2_hd.jpg" alt=""></p><p>​    Faster R-CNN优缺点：</p><ul><li>使用RPN替换了耗时的selective search算法，对整个网络结构有了突破性的优化；</li><li>Faster R-CNN中使用的RPN和selective search比起来虽然速度更快，但是精度和selective search相比稍有不及，如果更注重速度而不是精度的话完全可以只使用RPN；</li></ul></li><li><p>Mask R-CNN：Mask R-CNN（终于到分割了！）是何恺明大神团队提出的一个基于Faster R-CNN模型的一种新型的分割模型，此论文斩获ICCV 2017的最佳论文，在Mask R-CNN的工作中，它主要完成了三件事情：目标检测，目标分类，像素级分割。恺明大神是在Faster R-CNN的结构基础上加上了Mask预测分支，并且改良了ROI Pooling，提出了ROI Align。其网络结构真容就如下图所示啦：</p><p><img src="https://pic4.zhimg.com/80/v2-8123af16197c5b6b486808fafe2246d7_hd.jpg" alt=""></p><p>​    MS R-CNN的优缺点：</p><ul><li>优化了Mask R-CNN中的信息传播，提高了生成预测模板的质量；</li><li>未经大批量训练的情况下，就拿下了COCO 2017挑战赛实例分割任务冠军；</li><li>要说缺点的话。。应该就是整个网络有些庞大，一方面需要ResNet当作主干网络，另一方面需要其它各种Head共同承担各种任务。</li></ul></li><li><p>SetNet：SegNet是剑桥提出的旨在解决自动驾驶或者智能机器人的图像语义分割深度网络，SegNet基于FCN，与FCN的思路十分相似，只是其编码-解码器和FCN的稍有不同，其解码器中使用去池化对特征图进行上采样，并在分各种保持高频细节的完整性；而编码器不使用全连接层，因此是拥有较少参数的轻量级网络：</p><p><img src="https://pic4.zhimg.com/80/v2-f6a18a6bad1cbfd8c359a45656604fe3_hd.jpg" alt=""></p><p>​    SetNet的优缺点：</p><ul><li>保存了高频部分的完整性；</li><li>网络不笨重，参数少，较为轻便；</li><li>对于分类的边界位置置信度较低；</li><li>对于难以分辨的类别，例如人与自行车，两者如果有相互重叠，不确定性会增加。</li></ul></li><li><p>LSTM:长短时记忆（LSTM，Long Short Term Memory）模型在时间信息处理中很受欢迎，关键思想是单元（cell）状态，如图水平线贯穿的顶部。LSTM将信息移除或添加到单元状态（cell state），称为门（gates）：输入门（𝑖𝑡），忘记门（𝑓𝑡）和输出门（𝑜𝑡）可以定义为如下公式：</p><p><img src="https://pic2.zhimg.com/80/v2-3f99658ef0bee863c16c243cf5de9279_hd.jpg" alt=""></p></li><li><p>GRU：Gated Recurrent Unit ，也来自LSTMs。GRU受欢迎的主要原因是计算成本和模型的简单性，如图所示。在拓扑、计算成本和复杂性方面，GRU是比标准LSTM更轻的RNN版。 该技术将遗忘门（forget gates）和输入门（input gates）组合成单个“更新门（update gate）”，并将单元状态、隐藏状态以及一些其他变化合并。更简单的GRU模型越来越受欢迎。数学上GRU可以用表示如下公式：</p><p><img src="https://pic4.zhimg.com/80/v2-15ac0386cacc6f89cd9b4bbe07806ebf_hd.jpg" alt=""></p></li><li><p>RNN： 递归神经网络（Recurrent Neural Network，RNN），不同于CNN，是用来处理序列数据的模型。有一点共同的是，RNN在几个时间点也具有共享权重的特点。RNN是唯一的，它允许随时间推移在一系列向量上进行操作。在Elman架构中，使用隐层的输出和隐层的正常输入一起作为输入。 另一方面，Jordan网络中输出单元的输出作为隐藏层的输入。相反地Jordan使用输出单元的输出同时作为自身和隐藏层的输入。RNN方法的主要问题是梯度消失/下降。如图示意所示。</p><p><img src="https://pic4.zhimg.com/80/v2-4359eedb6d8821257dae8988614b7d23_hd.jpg" alt=""></p></li><li><p>迁移学习：迁移学习是一种机器学习的方法，指的是一个预训练的模型被重新用在另一个任务中。迁移学习是一种优化，是一种节省时间或者得到更好性能的捷径。</p></li><li><p>ArchiGAN: 基于GAN实现公寓户型及家具自动划分，参考地址: <a href="https://devblogs.nvidia.com/archigan-generative-stack-apartment-building-design/?linkId=70968833" target="_blank" rel="noopener">https://devblogs.nvidia.com/archigan-generative-stack-apartment-building-design/?linkId=70968833</a></p></li><li><p>SLAM：同时定位与建图（simultaneous localization and mapping，SLAM）是自动驾驶与增强现实领域中常用的技术。主要研究装置通过各种传感器在未知环境中的感知与定位问题。可以描述为: 机器人在未知环境中从一个未知位置开始移动,在移动过程中根据位置估计和地图进行自身定位,同时在自身定位的基础上建造增量式地图，实现机器人的自主定位和导航。使用的基于机器人操作系统（ROS）框架工作的SLAM算法。 在ROS中提供的五种基于2D激光的SLAM算法分别是：HectorSLAM，Gmapping，KartoSLAM，CoreSLAM和LagoSLAM。当然最后还有比较经典的google开源的cartographer，虽然不是基于ROS的但是大牛们已经将它修改为基于ＲＯＳ的版本的cartographer_ros</p></li><li><p>U-Net：在图像分割任务特别是医学图像分割中，U-Net[1]无疑是最成功的方法之一，该方法在2015年MICCAI会议上提出，目前已达到四千多次引用。其采用的编码器（下采样）-解码器（上采样）结构和跳跃连接是一种非常经典的设计方法。目前已有许多新的卷积神经网络设计方式，但很多仍延续了U-Net的核心思想，加入了新的模块或者融入其他设计理念。</p><p><img src="https://pic3.zhimg.com/v2-63be140aee258bc15cfc1541f0a60d22_1200x500.jpg" alt="图像分割的U-Net系列方法"></p></li><li></li></ul><p>参考文章</p><ul><li><a href="https://developers.google.com/machine-learning/glossary/" target="_blank" rel="noopener">Google机器学习和TensorFlow专用术语表</a></li><li><a href="https://zhuanlan.zhihu.com/p/70758906" target="_blank" rel="noopener">最全综述 | 图像分割算法</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 人工智能 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常用Bash命令收集</title>
      <link href="/2019/081342868.html"/>
      <url>/2019/081342868.html</url>
      
        <content type="html"><![CDATA[<h2 id="系统相关"><a href="#系统相关" class="headerlink" title="系统相关"></a>系统相关</h2><h3 id="1-hostname-查看主机名"><a href="#1-hostname-查看主机名" class="headerlink" title="1. hostname - 查看主机名"></a>1. hostname - 查看主机名</h3><p><code>hostname</code>命令用于查看系统的主机名，或是修改系统的主机名。</p><p><code>hostname</code>的常用命令如下：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 显示系统的当前主机名</span><span class="token function">hostname</span><span class="token comment" spellcheck="true"># 修改你系统的主机名</span><span class="token function">hostname</span> blinkfox-system<span class="token comment" spellcheck="true"># 使用 -F 选项，从指定的文件中读取主机名</span><span class="token function">hostname</span> -F /root/hostname.txt<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-uptime-查看系统运行时间"><a href="#2-uptime-查看系统运行时间" class="headerlink" title="2. uptime - 查看系统运行时间"></a>2. uptime - 查看系统运行时间</h3><p><code>uptime</code>命令用于打印系统的运行时间等信息。使用如下：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">uptime</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="3-w、who-列出登录的用户"><a href="#3-w、who-列出登录的用户" class="headerlink" title="3. w、who - 列出登录的用户"></a>3. w、who - 列出登录的用户</h3><p><code>w</code>命令用于显示登录用户及他们当前运行的进程。输入的内容格式如下：</p><pre class="line-numbers language-bash"><code class="language-bash">w<span class="token comment" spellcheck="true"># 打印如下</span>22:42  up 18 days, 1 hr, 2 users, load averages: 1.23 1.79 1.75USER     TTY      FROM              LOGIN@  IDLE WHATblinkfox console  -                日19   6days -blinkfox s000     -                五23       - w<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>who</code>命令有与<code>w</code>命令类似的用途，但它的功能比<code>w</code>命令更强大一些。语法格式如下：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">who</span> <span class="token punctuation">[</span>OPTION<span class="token punctuation">]</span><span class="token punctuation">..</span>. <span class="token punctuation">[</span>FILE <span class="token operator">|</span> ARG1 ARG2<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><code>who</code>常用命令如下：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 显示当前登录的所有用户信息</span><span class="token function">who</span><span class="token comment" spellcheck="true"># 显示系统的启动时间</span><span class="token function">who</span> -b<span class="token comment" spellcheck="true"># 显示系统登录进程</span><span class="token function">who</span> -l<span class="token comment" spellcheck="true"># 显示与当前标准输入关联的用户信息</span><span class="token function">who</span> -m<span class="token comment" spellcheck="true"># 显示系统的运行级别</span><span class="token function">who</span> -r<span class="token comment" spellcheck="true"># 显示所有登录用户的用户名和登录用户数</span><span class="token function">who</span> -q<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4-uname-查看系统信息"><a href="#4-uname-查看系统信息" class="headerlink" title="4. uname - 查看系统信息"></a>4. uname - 查看系统信息</h3><p><code>uname</code>命令用于打印内核名称和版本、主机名等系统信息。命令的语法如下所示：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">uname</span> <span class="token punctuation">[</span>OPTION<span class="token punctuation">]</span><span class="token punctuation">..</span>.<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>常用使用方式如下：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 只打印内核的名称</span><span class="token function">uname</span><span class="token comment" spellcheck="true"># 使用 -n 选项，只打印系统的主机名</span><span class="token function">uname</span> -n<span class="token comment" spellcheck="true"># 使用 -r 选项，打印内核版本信息</span><span class="token function">uname</span> -r<span class="token comment" spellcheck="true"># 使用 -m 选项，打印系统的硬件名称</span><span class="token function">uname</span> -m<span class="token comment" spellcheck="true"># 使用 -p 选项，打印系统的处理器类型信息</span><span class="token function">uname</span> -p<span class="token comment" spellcheck="true"># 使用 -i 选项，打印系统的硬件平台信息</span><span class="token function">uname</span> -i<span class="token comment" spellcheck="true"># 使用 -a 选项，打印上述所有示例中的信息</span><span class="token function">uname</span> -a<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="5-date-显示和设置系统日期和时间"><a href="#5-date-显示和设置系统日期和时间" class="headerlink" title="5. date - 显示和设置系统日期和时间"></a>5. date - 显示和设置系统日期和时间</h3><p><code>date</code>命令用于以多种格式显示日期和时间，或设置系统的日期和时间。<code>date</code>命令的语法如下所示：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">date</span> <span class="token punctuation">[</span>OPTION<span class="token punctuation">]</span><span class="token punctuation">..</span>. <span class="token punctuation">[</span>+FORMAT<span class="token punctuation">]</span><span class="token function">date</span> <span class="token punctuation">[</span>-u<span class="token operator">|</span>--utc<span class="token operator">|</span>--universal<span class="token punctuation">]</span> <span class="token punctuation">[</span>MMDDhhmm<span class="token punctuation">[</span><span class="token punctuation">[</span>CC<span class="token punctuation">]</span>YY<span class="token punctuation">]</span><span class="token punctuation">[</span>.ss<span class="token punctuation">]</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>常用使用命令如下：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 以默认格式显示系统的当前日期时间</span><span class="token function">date</span><span class="token comment" spellcheck="true"># 格式化当前日期</span><span class="token function">date</span> +<span class="token string">"%Y-%m-%d"</span><span class="token comment" spellcheck="true"># 格式化输出昨天的日期</span><span class="token function">date</span> -d <span class="token string">"1 day ago"</span> +<span class="token string">"%Y-%m-%d"</span><span class="token comment" spellcheck="true"># 2秒后格式化输出</span><span class="token function">date</span> -d <span class="token string">"2 second"</span> +<span class="token string">"%Y-%m-%d %H:%M.%S"</span><span class="token comment" spellcheck="true"># 普通格式化转出</span><span class="token function">date</span> -d <span class="token string">"2009-12-12"</span> +<span class="token string">"%Y/%m/%d %H:%M.%S"</span><span class="token comment" spellcheck="true"># apache格式转换</span><span class="token function">date</span> -d <span class="token string">"Dec 5, 2009 12:00:37 AM"</span> +<span class="token string">"%Y-%m-%d %H:%M.%S"</span><span class="token comment" spellcheck="true"># 日期加减操作</span><span class="token function">date</span> +%Y%m%d <span class="token comment" spellcheck="true">#显示前天年月日</span><span class="token function">date</span> -d <span class="token string">"+1 day"</span> +%Y%m%d <span class="token comment" spellcheck="true">#显示前一天的日期</span><span class="token function">date</span> -d <span class="token string">"-1 day"</span> +%Y%m%d <span class="token comment" spellcheck="true">#显示后一天的日期</span><span class="token function">date</span> -d <span class="token string">"-1 month"</span> +%Y%m%d <span class="token comment" spellcheck="true">#显示上一月的日期</span><span class="token function">date</span> -d <span class="token string">"+1 month"</span> +%Y%m%d <span class="token comment" spellcheck="true">#显示下一月的日期</span><span class="token function">date</span> -d <span class="token string">"-1 year"</span> +%Y%m%d <span class="token comment" spellcheck="true">#显示前一年的日期</span><span class="token function">date</span> -d <span class="token string">"+1 year"</span> +%Y%m%d <span class="token comment" spellcheck="true">#显示下一年的日期</span><span class="token comment" spellcheck="true"># 设定时间</span><span class="token function">date</span> -s <span class="token comment" spellcheck="true"># 设置当前时间，只有root权限才能设置，其他只能查看</span><span class="token function">date</span> -s 20160816 <span class="token comment" spellcheck="true"># 设置成20160816，这样会把具体时间设置成空00:00:00</span><span class="token function">date</span> -s 01:01:01 <span class="token comment" spellcheck="true"># 设置具体时间，不会对日期做更改</span><span class="token function">date</span> -s <span class="token string">"01:01:01 2012-05-23"</span> <span class="token comment" spellcheck="true"># 这样可以设置全部时间</span><span class="token function">date</span> -s <span class="token string">"01:01:01 20120523"</span> <span class="token comment" spellcheck="true"># 这样可以设置全部时间</span><span class="token function">date</span> -s <span class="token string">"2012-05-23 01:01:01"</span> <span class="token comment" spellcheck="true"># 这样可以设置全部时间</span><span class="token function">date</span> -s <span class="token string">"20120523 01:01:01"</span> <span class="token comment" spellcheck="true"># 这样可以设置全部时间</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="6-id-显示用户属性"><a href="#6-id-显示用户属性" class="headerlink" title="6. id - 显示用户属性"></a>6. id - 显示用户属性</h3><p><code>id</code>命令用于打印输出用户<code>uid</code>、<code>gid</code>、用户名和组名等用户身份信息。<code>id</code>命令的语法如下所示：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">id</span> <span class="token punctuation">[</span>OPTION<span class="token punctuation">]</span><span class="token punctuation">..</span>. <span class="token punctuation">[</span>USERNAME<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>常见使用命令如下：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 输出当前用户的uid、用户名、gid、组名及用户属于的群组信息</span><span class="token function">id</span><span class="token comment" spellcheck="true"># 使用 -u 选项，输出用户的 uid</span><span class="token function">id</span> -u<span class="token comment" spellcheck="true">#-u 选项和 -n 选项结合使用，输出账户的用户名</span><span class="token function">id</span> -un<span class="token comment" spellcheck="true"># 使用 -g 选项，输出帐号当前起作用的gid</span><span class="token function">id</span> -g<span class="token comment" spellcheck="true"># -g 与 -n 选项结合使用，输出帐号当前起作用的用户组名</span><span class="token function">id</span> -gn<span class="token comment" spellcheck="true"># 使用 -G 选项，输出帐号所属的所有群组id</span><span class="token function">id</span> -G root<span class="token comment" spellcheck="true"># -G 与 -n 选项结合使用，输出账号所属的所有群组的名称</span><span class="token function">id</span> -Gn root<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="文件和目录操作"><a href="#文件和目录操作" class="headerlink" title="文件和目录操作"></a>文件和目录操作</h2><h3 id="1-touch-创建文件"><a href="#1-touch-创建文件" class="headerlink" title="1. touch - 创建文件"></a>1. touch - 创建文件</h3><p><code>touch</code>命令就可用于创建、变更和修改文件的时间戳。它是 Linux 操作系统的标准程序。<code>touch</code>命令又如下选项：</p><pre class="line-numbers language-bash"><code class="language-bash">-a: 只改变访问时间-c: 不创建任何文件-m: 只改变修改时间-r: 使用指定文件的时间替代当前时间-t: 使用 <span class="token punctuation">[</span><span class="token punctuation">[</span>CC<span class="token punctuation">]</span>YY<span class="token punctuation">]</span>MMDDhhmm<span class="token punctuation">[</span>.ss<span class="token punctuation">]</span> 替代当前时间<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>touch 命令的常见用法如下：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 创建一个名为 effyl 的新空文件</span><span class="token function">touch</span> effyl<span class="token comment" spellcheck="true"># 同时创建名称分别为 effyl myeffyl lueffyl 的三个文件</span><span class="token function">touch</span> effyl myeffyl lueffyl<span class="token comment" spellcheck="true"># 使用 -a 选项，可以改变或更新文件的最新访问时间，如果文件 effyl 不存在，则新创建一个</span><span class="token function">touch</span> -a effyl<span class="token comment" spellcheck="true"># 使用 -c 选项，可以避免创建一个新文件，并用当前时间更新文件的时间戳</span><span class="token function">touch</span> -c effyl<span class="token comment" spellcheck="true"># 使用 -m 选项，可以只改变文件的修改时间，而访问时间不变</span><span class="token function">touch</span> -m effyl<span class="token comment" spellcheck="true"># 使用 -c 和 -t 选项，来明确设置文件的时间</span><span class="token function">touch</span> -c -t YYMMDDHHMM filename<span class="token comment" spellcheck="true"># 如果想使用文件 myeffyl 的时间戳更新文件 effyl 的时间戳，可以使用 -r 选项</span><span class="token function">touch</span> -r myeffyl effyl<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-mkdir-创建目录"><a href="#2-mkdir-创建目录" class="headerlink" title="2.mkdir - 创建目录"></a>2.mkdir - 创建目录</h3><p><code>mkdir</code>命令用于创建一个新目录。最基本的<code>mkdir</code>命令的使用方法如下所示：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 在当前目录下创建一个给定的目录名</span><span class="token function">mkdir</span> <span class="token operator">&lt;</span>dirname<span class="token operator">></span><span class="token comment" spellcheck="true"># 在 backup 中的相对路径创建一个名为 old 的目录</span><span class="token function">mkdir</span> backup/old<span class="token comment" spellcheck="true"># 在 backup 中的绝对路径中创建一个名为 old 的目录</span><span class="token function">mkdir</span> /home/blinkfox/backup/old<span class="token comment" spellcheck="true"># 使用 -p 选项，会自动创建所有还不存在的父目录</span><span class="token function">mkdir</span> -p backup/old<span class="token comment" spellcheck="true"># 使用 -m 选项，可以设置将要创建目录的权限</span><span class="token comment" spellcheck="true"># 如：创建一个任何人都有读写访问权限的目录</span><span class="token function">mkdir</span> -p -m 777 backup/old<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-cp-复制文件或目录"><a href="#3-cp-复制文件或目录" class="headerlink" title="3.cp - 复制文件或目录"></a>3.cp - 复制文件或目录</h3><p><code>cp</code>命令用于将文件从一个地方复制到另一个地方。原来的文件保持不变，新文件可能保持原名或用一个不同的名字。</p><p>使用 cp 命令复制文件和目录的语法有以下几种：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 复制源文件到目标文件</span><span class="token function">cp</span> <span class="token punctuation">[</span>OPTION<span class="token punctuation">]</span> SOURCE DEST<span class="token comment" spellcheck="true"># 复制一个或多个源文件到一个目录</span><span class="token function">cp</span> <span class="token punctuation">[</span>OPTION<span class="token punctuation">]</span> SOURCE<span class="token punctuation">..</span>. DIRECTORY<span class="token comment" spellcheck="true"># 同上</span><span class="token function">cp</span> <span class="token punctuation">[</span>OPTION<span class="token punctuation">]</span> -t DIRECTORY SOURCE<span class="token punctuation">..</span>.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>常用使用示例如下：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 在当前目录下，创建一个文件 file.txt 的副本，取名为 newfile.txt</span><span class="token function">cp</span> file.txt newfile.txt<span class="token comment" spellcheck="true"># 复制当前目录下的 file.txt 文件到 /tmp 目录下</span><span class="token function">cp</span> file.txt /tmp<span class="token comment" spellcheck="true"># 复制当前目录下的所有文件到 /tmp 目录下</span><span class="token function">cp</span> * /tmp<span class="token comment" spellcheck="true"># 使用 -p 选项，可以使复制一个文件到新文件时，保留源文件的所有者、权限等信息</span><span class="token function">cp</span> -p filename /path/to/new/location/myfile<span class="token comment" spellcheck="true"># 使用 -R 或 -r 选项，恶意递归地复制一个目录</span><span class="token comment" spellcheck="true"># 即将一个目录及其下的所有文件和子目录都复制到另一个目录</span><span class="token function">cp</span> -R * /home/blinkfox/backup<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4-ln-链接文件或目录"><a href="#4-ln-链接文件或目录" class="headerlink" title="4.ln - 链接文件或目录"></a>4.ln - 链接文件或目录</h3><p><code>ln</code>命令用于创建软链接或硬链接。使用 -s 选项，可以创建一个软链接：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 在目录 lib 下创建一个软链接 library.so，链接到 /home/blinkfox/src/library.so</span><span class="token function">ln</span> -s /home/blinkfox/src/library.so /home/blinkfox/lib<span class="token comment" spellcheck="true"># 创建目录的软链接</span><span class="token function">ln</span> -s /home/blinkfox/src <span class="token function">source</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="5-mv-移动文件或目录"><a href="#5-mv-移动文件或目录" class="headerlink" title="5. mv - 移动文件或目录"></a>5. mv - 移动文件或目录</h3><p><code>mv</code>命令用于将文件和目录从一个位置移到另外一个位置。除了移动文件，<code>mv</code>命令还可用于修改文件或目录的名字。</p><p>mv 命令的基本语法如下所示：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">mv</span> SOURCE<span class="token punctuation">..</span>. DIRECTORY<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>常用命令如下：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 将当前目录下的文件 source.txt 移到目录 /tmp 下</span><span class="token function">mv</span> source.txt /tmp<span class="token comment" spellcheck="true"># 将目录 dir1、dir2 移到目录 dir_dist 下</span><span class="token function">mv</span> dir1 dir2 dir_dist<span class="token comment" spellcheck="true"># 将当前目录下的 old.txt 文件更名为 new.txt</span><span class="token function">mv</span> old.txt new.txt<span class="token comment" spellcheck="true"># 使用 -i 选项，在重写覆盖目标文件或目录之前给出提示信息</span><span class="token function">mv</span> -i old.txt new.txt<span class="token comment" spellcheck="true"># 将当前目录下的所有文件移动到目录 /tmp 下</span><span class="token function">mv</span> * /tmp/<span class="token comment" spellcheck="true"># 使用 -i 选项，从 dir1 中移动那些在目标目录中不存在的文件到目标目录</span><span class="token function">mv</span> -u dir1/* dir2/<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="6-rm-删除文件或目录"><a href="#6-rm-删除文件或目录" class="headerlink" title="6.rm - 删除文件或目录"></a>6.rm - 删除文件或目录</h3><p><code>rm</code>命令用于删除指定的文件和目录。其语法如下所示：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">rm</span> <span class="token punctuation">[</span>OPTIONS<span class="token punctuation">]</span><span class="token punctuation">..</span>. FILE<span class="token punctuation">..</span>.<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><code>rm</code>的常用命令如下：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 删除当前目录下的文件 file1.txt、file2.txt、file3.txt</span><span class="token function">rm</span> file1.txt file2.txt file3.txt<span class="token comment" spellcheck="true"># 删除当前目录下的所有文件</span><span class="token function">rm</span> *<span class="token comment" spellcheck="true"># 删除你当前帐号主目录下的 temp 目录中的所有文件</span><span class="token function">rm</span> ~/temp/*<span class="token comment" spellcheck="true"># 使用 -i 选项，可以在删除每个文件或目录前提示用户确认</span><span class="token function">rm</span> -i *<span class="token comment" spellcheck="true"># 删除当前目录下所有以".doc"结尾的文件</span><span class="token function">rm</span> *.doc<span class="token comment" spellcheck="true"># 删除当前目录下所有文件名中包含"movie"字符串的文件</span><span class="token function">rm</span> *movie*<span class="token comment" spellcheck="true"># 删除当前目录下所有以"a"开头的文件</span><span class="token function">rm</span> a*<span class="token comment" spellcheck="true"># 删除当前目录下整个文件名（包括扩展名）只有 3 个字符的所有文件</span><span class="token function">rm</span> ???<span class="token comment" spellcheck="true"># 删除当前目录下文件扩展名有两个字符的所有文件</span><span class="token function">rm</span> *.??<span class="token comment" spellcheck="true"># 删除当前目录下文件名中含有字母 a 或 b 或 c 的所有文件</span><span class="token function">rm</span> *<span class="token punctuation">[</span>abc<span class="token punctuation">]</span>*<span class="token comment" spellcheck="true"># 删除当前目录下文件名中包含 0~9 的所有文件</span><span class="token function">rm</span> *<span class="token punctuation">[</span>0-9<span class="token punctuation">]</span>*<span class="token comment" spellcheck="true"># 删除当前目录下文件扩展名是字母 c 或 h 的所有文件</span><span class="token function">rm</span> *.<span class="token punctuation">[</span>ch<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># 删除 /tmp 目录下的所有文件及其子目录</span><span class="token function">rm</span> -rf /tmp/*<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>-f 删除前不提示用户确认，并忽略不存在的文件<br>-r 递归地删除目录及其下的内容</p></blockquote><h3 id="7-ls-列出文件名和目录"><a href="#7-ls-列出文件名和目录" class="headerlink" title="7. ls - 列出文件名和目录"></a>7. ls - 列出文件名和目录</h3><p><code>ls</code>命令是<code>Linux</code>中最常用的命令之一，其作用就是列出文件名和目录。在命令行提示符下，直接输入<code>ls</code>命令，不带任何选项，将列出当前目录下所有文件和目录，但不会显示详细的信息，比如，文件类型、大小、修改日期和时间、权限等。</p><p>以下便是<code>ls</code>命令及其选项的作用说明：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 仅列出当前目录下所有文件和目录</span><span class="token function">ls</span><span class="token comment" spellcheck="true"># 每行显示一条记录，每条记录包括文件类型、大小、修改日期和时间、权限等</span><span class="token function">ls</span> -l<span class="token comment" spellcheck="true"># 将文件大小显示符合人类阅读习惯的格式</span><span class="token function">ls</span> -lh<span class="token comment" spellcheck="true"># 将使用不同的特殊字符归类不同的文件类型</span><span class="token function">ls</span> -F<span class="token comment" spellcheck="true"># 以长列表格式列出某个目录的信息</span><span class="token function">ls</span> -ld /var/log<span class="token comment" spellcheck="true"># 将递归地列出子目录的内容</span><span class="token function">ls</span> -R /etc/sysconfig/<span class="token comment" spellcheck="true"># 以长列表格式按文件或目录的修改时间倒序地列出文件和目录</span><span class="token function">ls</span> -ltr<span class="token comment" spellcheck="true"># 以长列表格式按文件大小顺序列出文件和目录</span><span class="token function">ls</span> -ls<span class="token comment" spellcheck="true"># 列出包括隐藏文件或目录在内的所有文件和目录，包括“.”（当前目录）和“..”（父目录）</span><span class="token function">ls</span> -a<span class="token comment" spellcheck="true"># 列出包括隐藏文件或目录在内的所有文件和目录，不包括“.”（当前目录）和“..”（父目录）</span><span class="token function">ls</span> -A输出的内容类似于-l选项，指示显示uid和gid，替代显示所有者和用户组<span class="token function">ls</span> -n<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="8-cat-连接显示文件内容"><a href="#8-cat-连接显示文件内容" class="headerlink" title="8. cat - 连接显示文件内容"></a>8. cat - 连接显示文件内容</h3><p><code>cat</code> 命令也是 Linux 系统中最常用的命令之一。<code>cat</code>命令让我们可以看看文件的内容、连接文件、创建一个或多个文件和重定向输出到终端或文件。</p><p><code>cat</code>命令的语法如下所示：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">cat</span> <span class="token punctuation">[</span>OPTION<span class="token punctuation">]</span> <span class="token punctuation">[</span>FILE<span class="token punctuation">]</span><span class="token punctuation">..</span>.<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><code>cat</code>常用命令如下：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 使用 cat 命令查看文件 /etc/group 的内容</span><span class="token function">cat</span> /etc/group<span class="token comment" spellcheck="true"># 显示多个文件的内容</span><span class="token function">cat</span> /etc/redhat-release /etc/issue<span class="token comment" spellcheck="true"># -n 选项，可以显示文件内容的行号</span><span class="token function">cat</span> -n /etc/fstab<span class="token comment" spellcheck="true"># -b 选项和 -n 选项类似，但只标识非空白行的行号</span><span class="token function">cat</span> -b /etc/fstab<span class="token comment" spellcheck="true"># -e 选项，将在每一行的结尾显示“$”字符</span><span class="token function">cat</span> -e /etc/fstab<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>当你只输入 cat 命令，而没有任何参数时，它只是接收标准输入的内容并在标准输出中显示。所以你在输入一行内容并回车后，会在接下来的一行显示相同的内容。你也可以重定向标准输出到一个新文件。</p></blockquote><h3 id="9-less、more-分屏显示文件"><a href="#9-less、more-分屏显示文件" class="headerlink" title="9.less、more - 分屏显示文件"></a>9.less、more - 分屏显示文件</h3><p><code>more</code>命令在你使用小的 xterm 窗口时，或是想不使用文本编辑器而只是简单地阅读一个文件时是很有用的。more 命令是一个用于一次翻阅一整屏文件的过滤器。</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 查看一个文件，自动清空屏幕并显示文件开头部分</span><span class="token function">more</span> /etc/inittab<span class="token comment" spellcheck="true"># 指定一次显示num行</span><span class="token function">more</span> -num /etc/inittab<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>与<code>more</code>命令相比，我个人更喜欢<code>less</code>命令来查看文件。<code>less</code>命令与<code>more</code>命令类似，但<code>less</code>命令向前和向后翻页都支持，而且<code>less</code>命令不需要在查看前加载整个文件，即<code>less</code>命令查看文件更快速。</p><p><code>less</code>常用命令参数如下：</p><pre class="line-numbers language-bash"><code class="language-bash">-b  <span class="token operator">&lt;</span>缓冲区大小<span class="token operator">></span> 设置缓冲区的大小-e  当文件显示结束后，自动离开-f  强迫打开特殊文件，例如外围设备代号、目录和二进制文件-g  只标志最后搜索的关键词-i  忽略搜索时的大小写-m  显示类似more命令的百分比-N  显示每行的行号-o  <span class="token operator">&lt;</span>文件名<span class="token operator">></span> 将less 输出的内容在指定文件中保存起来-Q  不使用警告音-s  显示连续空行为一行-S  行过长时间将超出部分舍弃-x  <span class="token operator">&lt;</span>数字<span class="token operator">></span> 将“tab”键显示为规定的数字空格/字符串：向下搜索“字符串”的功能?字符串：向上搜索“字符串”的功能n： 重复前一个搜索（与 / 或 ? 有关）N： 反向重复前一个搜索（与 / 或 ? 有关）b  向后翻一页d  向后翻半页h  显示帮助界面Q  退出less 命令u  向前滚动半页y  向前滚动一行空格键 滚动一行回车键 滚动一页<span class="token punctuation">[</span>pagedown<span class="token punctuation">]</span>： 向下翻动一页<span class="token punctuation">[</span>pageup<span class="token punctuation">]</span>：   向上翻动一页<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="10-head-显示文件头部"><a href="#10-head-显示文件头部" class="headerlink" title="10.head - 显示文件头部"></a>10.head - 显示文件头部</h3><p><code>head</code>命令用于打印指定输入的开头部分内容。默认情况下，打印每个指定输入的前 10 行内容。</p><p>使用<code>-n</code>选项可以指定打印文件的前 N 行：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 指定打印文件的前5行</span><span class="token function">head</span> -n 5 /etc/inittab（或）head -5 /etc/inittab<span class="token comment" spellcheck="true"># 打印文件的前N个字节的数据</span><span class="token function">head</span> -c 10 /etc/inittab<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="11-tail-显示文件尾部"><a href="#11-tail-显示文件尾部" class="headerlink" title="11.tail - 显示文件尾部"></a>11.tail - 显示文件尾部</h3><p><code>tail</code>命令和<code>head</code>命令相反，它打印指定输入的结尾部分的内容。默认情况下，它打印指定输入的最后 10 行内容。</p><p>使用<code>-n</code>选项可以指定打印文件的最后 N 行：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 指定打印文件的后10行</span><span class="token function">tail</span> -n 10 /etc/inittab<span class="token function">tail</span> -10 /etc/inittab<span class="token comment" spellcheck="true"># 即时打印文件中新写入的行</span><span class="token function">tail</span> -f /var/log/messages<span class="token comment" spellcheck="true"># --retry选项表示持续尝试打开某个文件，当你想打开一个稍后才会创建或即使不可用的文件</span><span class="token function">tail</span> -f /tmp/debug.log --retry<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="12-file-查看文件类型"><a href="#12-file-查看文件类型" class="headerlink" title="12.file - 查看文件类型"></a>12.file - 查看文件类型</h3><p><code>file</code>命令用于接收一个文件作为参数并执行某些测试，已确定正确的文件类型。</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 查看文件类型</span><span class="token function">file</span> /etc/inittab<span class="token comment" spellcheck="true"># 可以MIME类型的格式显示文件类型的信息</span><span class="token function">file</span> -i  /etc/inittab<span class="token comment" spellcheck="true"># 使用-N 选项，输出的队列可以以在文件名之后无空白填充的形式显示</span><span class="token function">file</span> -N *<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="13-wc-查看文件统计信息"><a href="#13-wc-查看文件统计信息" class="headerlink" title="13.wc - 查看文件统计信息"></a>13.wc - 查看文件统计信息</h3><p><code>wc</code>命令用于查看文件的行数、单词数和字符数等信息。语法类似如下所示：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">wc</span> filenameX Y Z /etc/inittab<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>其中 X 表示行数，Y 表示单词数，Z 表示字节数，filename 表示文件名。</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># -l选项，可以只统计文件的行数信息</span><span class="token function">wc</span> -l /etc/inittab<span class="token comment" spellcheck="true"># -w选项，可以只统计文件的单词数信息</span><span class="token function">wc</span> -w /etc/inittab<span class="token comment" spellcheck="true"># -c选项，可以只统计文件的字节数信息</span><span class="token function">wc</span> -c /etc/inittab<span class="token comment" spellcheck="true"># -L选项，可以只统计文件中最长的行的长度</span><span class="token function">wc</span> -L /etc/inittab<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="14-find-查找文件或目录"><a href="#14-find-查找文件或目录" class="headerlink" title="14.find - 查找文件或目录"></a>14.find - 查找文件或目录</h3><p><code>find</code>命令用于根据你指定的参数搜索和定位文件和目录的列表。<code>find</code>命令可以在多种情况下使用，比如你可以通过权限、用户、用户组、文件类型、日期、大小和其他可能的条件来查找文件。</p><p><code>find</code>命令常用使用和说明如下：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 查找指定目录下的某个文件</span><span class="token function">find</span> /etc/ -name inittab<span class="token comment" spellcheck="true"># 在当前目录下查找名称为 inittab 的文件</span><span class="token function">find</span> <span class="token keyword">.</span> -name inittab<span class="token comment" spellcheck="true"># 在当前目录下，文件不区分大小写是example的所有文件</span><span class="token function">find</span> <span class="token keyword">.</span> -iname example<span class="token comment" spellcheck="true"># 找出当前目录下所有以 sh 结尾的文件</span><span class="token function">find</span> <span class="token keyword">.</span> -type f -name <span class="token string">"*.sh"</span><span class="token comment" spellcheck="true"># 找出当前目录下，文件权限是 777 的所有文件</span><span class="token function">find</span> <span class="token keyword">.</span> -type f -perm 777<span class="token comment" spellcheck="true"># 找出当前目录下，文件权限不是 777 的所有文件</span><span class="token function">find</span> <span class="token keyword">.</span> -type f <span class="token operator">!</span> -perm 777<span class="token comment" spellcheck="true"># 找出当前目录下所有只读文件</span><span class="token function">find</span> <span class="token keyword">.</span> -type f <span class="token operator">!</span> -perm /a+w<span class="token comment" spellcheck="true"># 找出你帐号主目录下的所有可执行文件</span><span class="token function">find</span> ~ -type f -perm /a+w<span class="token comment" spellcheck="true"># 找出 /tmp 目录下的.log文件并将其删除：</span><span class="token function">find</span> /tmp/ -type f -name <span class="token string">"*.log"</span> -exec <span class="token function">rm</span> -f <span class="token punctuation">{</span><span class="token punctuation">}</span> \<span class="token punctuation">;</span><span class="token comment" spellcheck="true"># 找出当前目录下的所有空文件</span><span class="token function">find</span> <span class="token keyword">.</span> -type f -empty<span class="token comment" spellcheck="true"># 找出当前目录下的所有空目录</span><span class="token function">find</span> <span class="token keyword">.</span> -type d -empty<span class="token comment" spellcheck="true"># 找出 /tmp 目录下的所有隐藏文件</span><span class="token function">find</span> /tmp/ -type f -name <span class="token string">".*"</span><span class="token comment" spellcheck="true"># 找出 /tmp 目录下，所有者是 root 的文件和目录</span><span class="token function">find</span> /tmp/ -user root<span class="token comment" spellcheck="true"># 找出 /tmp 目录下，用户组是 developer 的文件和目录</span><span class="token function">find</span> /tmp/ -group root<span class="token comment" spellcheck="true"># 找出你账号的主目录下，3 天前修改的文件</span><span class="token function">find</span> ~ -type f -mtime 3<span class="token comment" spellcheck="true"># 找出你账号的主目录下，30 天以前修改的所有文件</span><span class="token function">find</span> ~ -type f -mtime +30<span class="token comment" spellcheck="true"># 找出你账号的主目录下，3 天以内修改的所有文件</span><span class="token function">find</span> ~ -type f -mtime -3<span class="token comment" spellcheck="true"># 找出你账号的主目录下，30 天以前，60 天以内修改的所有文件</span><span class="token function">find</span> ~ -type f -mtime +30 -mtime -60<span class="token comment" spellcheck="true"># 找出 /etc 目录下，一小时以内变更过的文件</span><span class="token function">find</span> /etc -type f -cmin -60<span class="token comment" spellcheck="true"># 找出 /etc 目录下，一小时以内访问过的文件</span><span class="token function">find</span> /etc -type f -amin -60<span class="token comment" spellcheck="true"># 找出你账号主目录下，大小是50MB的所有文件</span><span class="token function">find</span> ~ -type f -size 50MB<span class="token comment" spellcheck="true"># 找出你账号主目录下，大于50MB小于100MB的所有文件</span><span class="token function">find</span> ~ -type f -size +50MB -size -100MB<span class="token comment" spellcheck="true"># 找出你账号主目录下，大于100MB的文件并将其删除</span><span class="token function">find</span> ~ -type f -size +100MB -exec <span class="token function">rm</span> -rf <span class="token punctuation">{</span><span class="token punctuation">}</span> \<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="文本处理"><a href="#文本处理" class="headerlink" title="文本处理"></a>文本处理</h2><h3 id="1-sort-文本排序"><a href="#1-sort-文本排序" class="headerlink" title="1. sort - 文本排序"></a>1. sort - 文本排序</h3><p><code>sort</code>命令用于将文本文件的行排序。默认情况下，<code>sort</code>命令是按照字符串的字母顺序排序。</p><p>sort 的常用命令如下：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 将文本内容按字母顺序排序</span><span class="token function">sort</span> example.txt<span class="token comment" spellcheck="true"># 使用 -u 选项，移除所有重复行后排序</span><span class="token function">sort</span> -u example.txt<span class="token comment" spellcheck="true"># 使用 -n 选项，将令数字按数值的大小排序</span><span class="token function">sort</span> -n example.txt<span class="token comment" spellcheck="true"># 使用 -r 选项，以倒序方式排序</span><span class="token function">sort</span> -n -r example.txt<span class="token comment" spellcheck="true"># 同时将 file1、file2 的内容排序</span><span class="token function">sort</span> file1 file2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-uniq-文本去重"><a href="#2-uniq-文本去重" class="headerlink" title="2.uniq - 文本去重"></a>2.uniq - 文本去重</h3><p><code>uniq</code>命令用于移除或发现文件中重复的条目。</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 它将移除文件中重复的行并显示单一行</span><span class="token function">uniq</span> example.txt<span class="token comment" spellcheck="true"># 可以统计重复行出现的次数</span><span class="token function">uniq</span> -c example.txt<span class="token comment" spellcheck="true"># 使用 -d 选项，只显示文件中有重复的行并只显示一次</span><span class="token function">uniq</span> -d example.txt<span class="token comment" spellcheck="true"># 使用 -D 选项，显示文件中所有重复的行</span><span class="token function">uniq</span> -D example.txt<span class="token comment" spellcheck="true"># 使用 -u 选项，只显示文件中不重复的行</span><span class="token function">uniq</span> -u example.txt<span class="token comment" spellcheck="true"># 使用 -w 选项，限制 uniq 命令只比较每行的前 3 个字符是否重复</span><span class="token function">uniq</span> -w 3 example.txt<span class="token comment" spellcheck="true"># 使用 -s 选项，避免 uniq 命令比较每行的前 3 个字符，只比较后面的字符是否重复</span><span class="token function">uniq</span> -s 3 example.txt<span class="token comment" spellcheck="true"># 使用 -f 选项，避免 uniq 命令比较第一列的内容，只比较后面的字符是否重复</span><span class="token function">uniq</span> -f 1 example.txt<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-tr-替换或删除字符"><a href="#3-tr-替换或删除字符" class="headerlink" title="3.tr - 替换或删除字符"></a>3.tr - 替换或删除字符</h3><p><code>tr</code>命令主要用于删除文件中控制字符或进行字符转换。使用<code>tr</code>时要转换两个字符串：字符串 1 用于查询，字符串 2 用于处理各种转换。<code>tr</code>刚执行时，字符串 1 中的字符被映射到字符串 2 中的字符，然后转换操作开始。</p><p><code>tr</code>命令的语法如下所示：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">tr</span> <span class="token punctuation">[</span>OPTION<span class="token punctuation">]</span><span class="token punctuation">..</span>. SET1 <span class="token punctuation">[</span>SET2<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>常用命令示例：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 若要将大括号转换为小括号</span><span class="token function">tr</span> <span class="token string">'{}'</span> <span class="token string">'()'</span> <span class="token operator">&lt;</span> textfile <span class="token operator">></span> newfile<span class="token comment" spellcheck="true"># 若要将大括号转换成方括号</span><span class="token function">tr</span> <span class="token string">'{}'</span> <span class="token string">'\[]'</span> <span class="token operator">&lt;</span> textfile <span class="token operator">></span> newfile<span class="token comment" spellcheck="true"># 若要将小写字符转换成大写，请输入：</span><span class="token function">tr</span> <span class="token string">'a-z'</span> <span class="token string">'A-Z'</span> <span class="token operator">&lt;</span> textfile <span class="token operator">></span> newfile<span class="token comment" spellcheck="true"># 若要创建一个文件中的单词列表</span><span class="token function">tr</span> -cs <span class="token string">'[:lower:][:upper:]'</span> <span class="token string">'[\n*]'</span> <span class="token operator">&lt;</span> textfile <span class="token operator">></span> newfile<span class="token comment" spellcheck="true"># 若要从某个文件中删除所有空字符</span><span class="token function">tr</span> -d <span class="token string">'\0'</span> <span class="token operator">&lt;</span> textfile <span class="token operator">></span> newfile<span class="token comment" spellcheck="true"># 若要用单独的换行替换每一序列的一个或多个换行，请输入：</span><span class="token function">tr</span> -s <span class="token string">'\n'</span> <span class="token operator">&lt;</span> textfile <span class="token operator">></span> newfile<span class="token comment" spellcheck="true"># 要以单个“#”字符替换 &lt;space> 字符类中的每个字符序列</span><span class="token function">tr</span> -s <span class="token string">'[:space:]'</span> <span class="token string">'[#*]'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4-grep-查找字符串"><a href="#4-grep-查找字符串" class="headerlink" title="4.grep - 查找字符串"></a>4.grep - 查找字符串</h3><p><code>grep</code>命令用于搜索文本或指定的文件中与指定的字符串或模式相匹配的行。默认情况下，<code>grep</code>命令只显示匹配的行。</p><p><code>grep</code>命令的语法如下所示：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">grep</span> <span class="token punctuation">[</span>OPTION<span class="token punctuation">]</span><span class="token punctuation">..</span>. PATTERN <span class="token punctuation">[</span>FILE<span class="token punctuation">]</span><span class="token punctuation">..</span>.<span class="token function">grep</span> <span class="token punctuation">[</span>OPTION<span class="token punctuation">]</span><span class="token punctuation">..</span>. <span class="token punctuation">[</span>-e PATTERN <span class="token operator">|</span> -f FILE<span class="token punctuation">]</span> <span class="token punctuation">[</span>FILE<span class="token punctuation">]</span><span class="token punctuation">..</span>.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># `grep`命令查找文件/etc/passwd 中帐号 blinkfox 的信息</span><span class="token function">grep</span> blinkfox /etc/passwd<span class="token comment" spellcheck="true"># 使用 -i 选项，强制 grep 命令忽略搜索关键字的大小写</span><span class="token function">grep</span> -i blinkfox /etc/passwd<span class="token comment" spellcheck="true"># 使用 -r 选项，可以递归搜索指定目录下的所有文件</span><span class="token function">grep</span> -r blinkfox /etc/<span class="token comment" spellcheck="true"># 使用 -w 选项，只匹配包含指定单词的行</span><span class="token function">grep</span> -w blinkfox /etc/<span class="token comment" spellcheck="true"># 使用 -c 选项，报告文件或文本中模式被匹配的次数</span><span class="token function">grep</span> -c blinkfox /etc/passwd<span class="token comment" spellcheck="true"># 使用 -n 选项，显示每一个匹配的行的行号</span><span class="token function">grep</span> -n blinkfox /etc/passwd<span class="token comment" spellcheck="true"># 使用 -v 选项，可以输出除匹配指定模式的行以外的其他所有行</span><span class="token function">grep</span> -v blinkfox /etc/passwd<span class="token comment" spellcheck="true"># 使用 --color 选项，在输出中将匹配的字符串以彩色的形式标出</span><span class="token function">grep</span> --color blinkfox /etc/passwd<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="5-diff-比较两个文件"><a href="#5-diff-比较两个文件" class="headerlink" title="5.diff - 比较两个文件"></a>5.diff - 比较两个文件</h3><p><code>diff</code>命令用于比较两个文件，并找出它们之间的不同。<code>diff</code>命令的语法如下所示：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">diff</span> <span class="token punctuation">[</span>OPTION<span class="token punctuation">]</span><span class="token punctuation">..</span>. from-file to-file<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>常用使用方式如下：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 比较两个文件</span><span class="token function">diff</span> nsswitch.conf nsswitch.conf.org<span class="token comment" spellcheck="true"># 使用 -w 选项，比较时忽略空格</span><span class="token function">diff</span> -w nsswitch.conf nsswitch.conf.org<span class="token comment" spellcheck="true"># 使用 -y 选项，以并排的格式输出两个文件的比较结果</span><span class="token function">diff</span> -y nsswitch.conf nsswitch.conf.org使用 -c 选项，以上下对比的格式输出两个文件的比较结果<span class="token function">diff</span> -c nsswitch.conf nsswitch.conf.org<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>[1] <a href="https://blinkfox.github.io/2018/10/09/ruan-jian-gong-ju/linux/chang-yong-bash-ming-ling-zheng-li-zhi-cha-kan-wen-jian-he-mu-lu/" target="_blank" rel="noopener">https://blinkfox.github.io/2018/10/09/ruan-jian-gong-ju/linux/chang-yong-bash-ming-ling-zheng-li-zhi-cha-kan-wen-jian-he-mu-lu/</a></li><li>[2] <a href="https://blinkfox.github.io/2018/10/13/ruan-jian-gong-ju/linux/chang-yong-bash-ming-ling-zheng-li-zhi-qi-ta-chang-yong-ming-ling/" target="_blank" rel="noopener">https://blinkfox.github.io/2018/10/13/ruan-jian-gong-ju/linux/chang-yong-bash-ming-ling-zheng-li-zhi-qi-ta-chang-yong-ming-ling/</a></li><li>[3] <a href="https://blinkfox.github.io/2018/10/11/ruan-jian-gong-ju/linux/chang-yong-bash-ming-ling-zheng-li-zhi-wen-ben-chu-li/" target="_blank" rel="noopener">https://blinkfox.github.io/2018/10/11/ruan-jian-gong-ju/linux/chang-yong-bash-ming-ling-zheng-li-zhi-wen-ben-chu-li/</a></li><li><a href="https://blinkfox.github.io/2018/10/09/ruan-jian-gong-ju/linux/chang-yong-bash-ming-ling-zheng-li-zhi-cha-kan-wen-jian-he-mu-lu/" target="_blank" rel="noopener">https://blinkfox.github.io/2018/10/09/ruan-jian-gong-ju/linux/chang-yong-bash-ming-ling-zheng-li-zhi-cha-kan-wen-jian-he-mu-lu/</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于Pages+Jekyll+Minimal-Mistakes搭建个人博客</title>
      <link href="/2019/061036412.html"/>
      <url>/2019/061036412.html</url>
      
        <content type="html"><![CDATA[<p>Github pages官方推荐使用Jekyll生成静态网页，jekyll支持各种不同的主题。Minimal Mistakes 是一个灵活的两栏 Jekyll 简约风格主题，非常适合建立个人网站、博客和作品集。除了外观设置外，还支持文章评论、文章搜索、文章标签、文章分类等增强和定制。</p><h2 id="安装Github-pages-Jekyll"><a href="#安装Github-pages-Jekyll" class="headerlink" title="安装Github pages + Jekyll"></a>安装Github pages + Jekyll</h2><ol><li>在github上Fork<a href="https://github.com/mmistakes/minimal-mistakes" target="_blank" rel="noopener">mmistakes/minimal-mistakes</a></li><li>参考<a href="https://pages.github.com/" target="_blank" rel="noopener">github pages主页</a>, 设置Fork来的仓库名为 {username}.github.io/blog，并启用GitHub Pages</li><li>clone <code>{username}.github.io/blog</code> 到本地 $Github/lxl80/blog目录</li><li>本地安装jekyll并建立博客</li></ol><pre class="line-numbers language-bash"><code class="language-bash">gem <span class="token function">install</span> jekyll bundler//建立myblog并复制内容到根目录后删除myblog//如果直接在根目录建立，github在编译时可能会软连接错误，暂不知原因<span class="token function">cd</span> <span class="token variable">$Github</span>/lxl80/blog<span class="token function">rm</span> Gemfilejekyll new blogtemp<span class="token function">cd</span> blogtemp<span class="token function">cp</span> -r * <span class="token punctuation">..</span>/<span class="token function">cd</span> <span class="token punctuation">..</span><span class="token function">rm</span> -rf blogtemp<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="使用Minimal-Mistakes主题"><a href="#使用Minimal-Mistakes主题" class="headerlink" title="使用Minimal-Mistakes主题"></a>使用Minimal-Mistakes主题</h2><ol><li><p>修改Gemfile:<br>替换<code>gem &quot;jekyll&quot;</code> 为 <code>gem &quot;github-pages&quot;, group: :jekyll_plugins</code></p></li><li><p>修改_config.yml:<br>替换<code>theme</code>为<code>remote_theme: &quot;mmistakes/minimal-mistakes&quot;</code></p></li><li><p>运行<code>bundle update</code>更新主题</p></li><li><p>更改about.md和 _posts/0000-00-00-welcome-to-jekyll.markdown 中 layout为single。</p></li><li><p>在根目录下删除<code>index.md</code>，添加<code>index.html</code>，内容如下：</p></li></ol><pre class="line-numbers language-bash"><code class="language-bash">---layout: homeauthor_profile: <span class="token boolean">true</span>---<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ol><li>运行<code>bundle exec jekyll serve</code><br>如果碰到No GitHub API authentication could be found.的问题，参考<a href="https://link.jianshu.com/?t=http%3A%2F%2Fidratherbewriting.com%2Fdocumentation-theme-jekyll%2Fmydoc_install_jekyll_on_mac.html%23githuberror" target="_blank" rel="noopener">Resolve ERRORS</a>。</li><li>访问<code>127.0.0.1:4000</code>查看页面</li><li>push到github，访问commits页面查看部署状态。</li><li>访问<code>{username}.github.io</code>查看博客主页。</li></ol><h2 id="相关配置"><a href="#相关配置" class="headerlink" title="相关配置"></a>相关配置</h2><h3 id="修改Markdown-高亮配色"><a href="#修改Markdown-高亮配色" class="headerlink" title="修改Markdown 高亮配色"></a>修改Markdown 高亮配色</h3><p>Jekyll使用rough作为代码高亮工具，不同的皮肤设置(minimal_mistakes_skin)有不同的高亮配色，这里我使用contrast皮肤，但代码高亮希望将背景从深色改为白色。</p><ol><li>在gems目录/usr/local/lib/ruby/gems/2.4.0/gems/minimal-mistakes-jekyll-{version}下复制 _sass 到博客根目录。</li><li>修改_sass/minimal-mistakes/skins/_contrast.scss，替换 syntax highlighting (base16) 设置，参考<a href="https://link.jianshu.com/?t=https%3A%2F%2Fmmistakes.github.io%2Fminimal-mistakes%2Fdocs%2Fstylesheets%2F%23colors" target="_blank" rel="noopener">Sylesheet/Color</a>。</li></ol><pre class="line-numbers language-bash"><code class="language-bash">/* solarized light syntax highlighting <span class="token punctuation">(</span>base16<span class="token punctuation">)</span> */<span class="token variable">$base00</span><span class="token keyword">:</span> <span class="token comment" spellcheck="true">#fafafa !default;</span><span class="token variable">$base01</span><span class="token keyword">:</span> <span class="token comment" spellcheck="true">#073642 !default;</span><span class="token variable">$base02</span><span class="token keyword">:</span> <span class="token comment" spellcheck="true">#586e75 !default;</span><span class="token variable">$base03</span><span class="token keyword">:</span> <span class="token comment" spellcheck="true">#657b83 !default;</span><span class="token variable">$base04</span><span class="token keyword">:</span> <span class="token comment" spellcheck="true">#839496 !default;</span><span class="token variable">$base05</span><span class="token keyword">:</span> <span class="token comment" spellcheck="true">#586e75 !default;</span><span class="token variable">$base06</span><span class="token keyword">:</span> <span class="token comment" spellcheck="true">#eee8d5 !default;</span><span class="token variable">$base07</span><span class="token keyword">:</span> <span class="token comment" spellcheck="true">#fdf6e3 !default;</span><span class="token variable">$base08</span><span class="token keyword">:</span> <span class="token comment" spellcheck="true">#dc322f !default;</span><span class="token variable">$base09</span><span class="token keyword">:</span> <span class="token comment" spellcheck="true">#cb4b16 !default;</span><span class="token variable">$base0a</span><span class="token keyword">:</span> <span class="token comment" spellcheck="true">#b58900 !default;</span><span class="token variable">$base0b</span><span class="token keyword">:</span> <span class="token comment" spellcheck="true">#859900 !default;</span><span class="token variable">$base0c</span><span class="token keyword">:</span> <span class="token comment" spellcheck="true">#2aa198 !default;</span><span class="token variable">$base0d</span><span class="token keyword">:</span> <span class="token comment" spellcheck="true">#268bd2 !default;</span><span class="token variable">$base0e</span><span class="token keyword">:</span> <span class="token comment" spellcheck="true">#6c71c4 !default;</span><span class="token variable">$base0f</span><span class="token keyword">:</span> <span class="token comment" spellcheck="true">#d33682 !default;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行 <code>bundle update</code></p><h3 id="设置文字大小"><a href="#设置文字大小" class="headerlink" title="设置文字大小"></a>设置文字大小</h3><p>修改 _sass/minimal-mistakes/_variables.scss 对应font-size。</p><h2 id="添加Disqus评论支持"><a href="#添加Disqus评论支持" class="headerlink" title="添加Disqus评论支持"></a>添加Disqus评论支持</h2><ol><li>参考I want to install disqus on my site注册，添加网站并得到shortname。</li><li>设置_config.yml</li></ol><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token key atrule">comments</span><span class="token punctuation">:</span><span class="token key atrule">provider</span><span class="token punctuation">:</span> <span class="token string">"disqus"</span><span class="token key atrule">disqus</span><span class="token punctuation">:</span>    <span class="token key atrule">shortname</span><span class="token punctuation">:</span> <span class="token string">"your-disqus-shortname"</span>//<span class="token punctuation">...</span><span class="token punctuation">...</span><span class="token key atrule">default</span><span class="token punctuation">:</span>    <span class="token key atrule">comments</span><span class="token punctuation">:</span> <span class="token boolean important">true</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul><li><a href="https://github.com/mmistakes/minimal-mistakes" target="_blank" rel="noopener">Minimal Mistakes Jekyll theme</a></li><li><a href="https://github.com/mmistakes/minimal-mistakes" target="_blank" rel="noopener">Minimal Mistakes Quick-Start Guide</a></li><li><a href="https://jekyllrb.com/docs/" target="_blank" rel="noopener">Jekyll docs</a></li><li><a href="https://www.jianshu.com/p/d19eede28520" target="_blank" rel="noopener">Github pages + Minimal-Mistakes + Disqus建立个人博客记录</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> blog </tag>
            
            <tag> Jekyll </tag>
            
            <tag> Minimal-Mistakes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>八、升级chaincode和背书策略</title>
      <link href="/2019/06048442.html"/>
      <url>/2019/06048442.html</url>
      
        <content type="html"><![CDATA[<h2 id="八、升级chaincode和背书策略"><a href="#八、升级chaincode和背书策略" class="headerlink" title="八、升级chaincode和背书策略"></a>八、升级chaincode和背书策略</h2><h3 id="1、为新组织安装-2-0-版本的-chaincode"><a href="#1、为新组织安装-2-0-版本的-chaincode" class="headerlink" title="1、为新组织安装 2.0 版本的 chaincode"></a>1、为新组织安装 2.0 版本的 chaincode</h3><p>其他组织的 chaincode 版本号是 1，新组织需要更新此版本的 chaincode，因此为新组织直接安装版本为 2 的 chaincode，省得先安装再升级。</p><pre class="line-numbers language-bash"><code class="language-bash">peer chaincode <span class="token function">install</span> -n cfistore -v 2 -p github.com/hyperledger/fabric/chaincode/go/cfistore<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="2、为其他组织安装-2-0-版本-chaincode"><a href="#2、为其他组织安装-2-0-版本-chaincode" class="headerlink" title="2、为其他组织安装 2.0 版本 chaincode"></a>2、为其他组织安装 2.0 版本 chaincode</h3><p>登录每个联盟原有组织 cli，逐一进行更新。</p><pre class="line-numbers language-bash"><code class="language-bash">docker <span class="token function">exec</span> -it cli <span class="token function">bash</span>peer chaincode <span class="token function">install</span> -n cfistore -v 2 -p github.com/hyperledger/fabric/chaincode/go/cfistorepeer chaincode upgrade -n cfistore -v 7 -c <span class="token string">'{"Args":["init"]}'</span> -o orderer0.fabric.mbfa.cn:7050 -C cfichannel -P <span class="token string">"OR ('MbfaMSP.member','MscMSP.member','CfecMSP.member','VteamMSP.member')"</span>// 查看channel中已经实例化的链码peer chaincode list --instantiated -C cfichannel<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3、升级背书策略"><a href="#3、升级背书策略" class="headerlink" title="3、升级背书策略"></a>3、升级背书策略</h3><p>升级背书策略，-v 2 指明版本号，-P “AND (‘MbfaMSP.peer’,’CfecMSP.peer’)”指明新的背书策略（添加了 CfecOrg）。</p><pre class="line-numbers language-bash"><code class="language-bash"> peer chaincode upgrade -n cfistore -v 2 -c <span class="token string">'{"Args":["init"]}'</span> -o orderer0.fabric.mbfa.cn:7050 -C cfichannel -P <span class="token string">"AND ('MbfaMSP.peer','CfecMSP.peer')"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>peer chaincode upgrade 命令将为区块链新增一个块，可以在其他的 peer 的输出中查看。</p><p>查询链码</p><pre class="line-numbers language-bash"><code class="language-bash">peer chaincode query -C cfichannel -n cfistore -c <span class="token string">'{"Args":["query","a"]}'</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 区块链 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Fabric </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>七、新组织加入channel</title>
      <link href="/2019/060442290.html"/>
      <url>/2019/060442290.html</url>
      
        <content type="html"><![CDATA[<h2 id="七、新组织申请添加到channel中"><a href="#七、新组织申请添加到channel中" class="headerlink" title="七、新组织申请添加到channel中"></a>七、新组织申请添加到channel中</h2><p>启动新组织节点，登录cli，加入到新channel：</p><pre class="line-numbers language-bash"><code class="language-bash">docker-compose -f cfi.yaml updocker <span class="token function">exec</span> -it cli <span class="token function">bash</span><span class="token function">export</span> ORDERER_CA<span class="token operator">=</span>/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/fabric.mbfa.cn/orderers/orderer0.fabric.mbfa.cn/msp/tlscacerts/tlsca.fabric.mbfa.cn-cert.pem<span class="token function">export</span> CHANNEL_NAME<span class="token operator">=</span>cfitestchannel//从 orderer 中获取 channel 创世块配置peer channel fetch 0 cfitestchannel.block -o orderer0.fabric.mbfa.cn:7050 -c <span class="token variable">$CHANNEL_NAME</span> --cafile <span class="token variable">$ORDERER_CA</span>peer channel <span class="token function">join</span> -b cfitestchannel.block<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 区块链 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Fabric </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>六、新组织加入联盟审核</title>
      <link href="/2019/060416039.html"/>
      <url>/2019/060416039.html</url>
      
        <content type="html"><![CDATA[<h2 id="六、联盟组织生成和提交新-org-配置"><a href="#六、联盟组织生成和提交新-org-配置" class="headerlink" title="六、联盟组织生成和提交新 org 配置"></a>六、联盟组织生成和提交新 org 配置</h2><p>通过 step 3~4，已经生成了 Sy 的证书和配置，但这仅仅是在本地文件系统，还未于区块链网络产生关联。为 channel 新加 Org，对 Fabric而言，是以一笔交易的形式提交的。因此要使得这笔交易能顺利完成，需要提交Sy的配置，到channel中，获得权限认证；然后于网络中发起更新的交易。</p><h3 id="1、登录联盟管理组织的cli"><a href="#1、登录联盟管理组织的cli" class="headerlink" title="1、登录联盟管理组织的cli"></a>1、登录联盟管理组织的cli</h3><pre class="line-numbers language-bash"><code class="language-bash">docker <span class="token function">exec</span> -it cli <span class="token function">bash</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="2、安装-jq-工具"><a href="#2、安装-jq-工具" class="headerlink" title="2、安装 jq 工具"></a>2、安装 jq 工具</h3><p>jq 是 Linux 下命令行处理 JSON 的工具，可以对 JSON 进行过滤、格式化、修改等等操作。</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">apt-get</span> -y update <span class="token operator">&amp;&amp;</span> <span class="token function">apt-get</span> -y <span class="token function">install</span> jq<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="3、设置orderer-TLS-CA环境变量（注意：peer对应的节点上需要有orderer节点的证书）"><a href="#3、设置orderer-TLS-CA环境变量（注意：peer对应的节点上需要有orderer节点的证书）" class="headerlink" title="3、设置orderer TLS CA环境变量（注意：peer对应的节点上需要有orderer节点的证书）"></a>3、设置orderer TLS CA环境变量（注意：peer对应的节点上需要有orderer节点的证书）</h3><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">export</span> ORDERER_CA<span class="token operator">=</span>/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/fabric.mbfa.cn/orderers/orderer0.fabric.mbfa.cn/msp/tlscacerts/tlsca.fabric.mbfa.cn-cert.pem<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="4、获取准备加入channel的配置"><a href="#4、获取准备加入channel的配置" class="headerlink" title="4、获取准备加入channel的配置"></a>4、获取准备加入channel的配置</h3><pre class="line-numbers language-bash"><code class="language-bash">peer channel fetch config vtm_config_block.pb -o orderer0.fabric.mbfa.cn:7050 -c cfitestchannel --cafile <span class="token variable">$ORDERER_CA</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="5、联盟管理组织修改原channel配置文件-增加新组织"><a href="#5、联盟管理组织修改原channel配置文件-增加新组织" class="headerlink" title="5、联盟管理组织修改原channel配置文件, 增加新组织"></a>5、联盟管理组织修改原channel配置文件, 增加新组织</h3><h4 id="5-1、解码原有网络的配置文件"><a href="#5-1、解码原有网络的配置文件" class="headerlink" title="5.1、解码原有网络的配置文件"></a>5.1、解码原有网络的配置文件</h4><pre class="line-numbers language-bash"><code class="language-bash">将准备加入channel的pb格式配置信息转换成json格式configtxlator proto_decode --input vtm_config_block.pb --type common.Block <span class="token operator">|</span> jq .data.data<span class="token punctuation">[</span>0<span class="token punctuation">]</span>.payload.data.config <span class="token operator">></span> vtm_config.json<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>生成文件内容类似set2中syorg.json内容</p><h4 id="5-2、使用jq工具，合并cfiorg-json与cfi-config-json-形成增加新组织后的完整json格式的配置更新文件"><a href="#5-2、使用jq工具，合并cfiorg-json与cfi-config-json-形成增加新组织后的完整json格式的配置更新文件" class="headerlink" title="5.2、使用jq工具，合并cfiorg.json与cfi_config.json, 形成增加新组织后的完整json格式的配置更新文件"></a>5.2、使用jq工具，合并cfiorg.json与cfi_config.json, 形成增加新组织后的完整json格式的配置更新文件</h4><pre class="line-numbers language-bash"><code class="language-bash">jq -s <span class="token string">'.[0] * {"channel_group":{"groups":{"Application":{"groups": {"VtmMSP":.[1]}}}}}'</span> vtm_config.json ./channel-artifacts/vtmorg.json <span class="token operator">></span> vtm_modified_config.json<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="5-3、将-config-json-和-modified-config-json-转为-protobuf-格式"><a href="#5-3、将-config-json-和-modified-config-json-转为-protobuf-格式" class="headerlink" title="5.3、将 config.json 和 modified_config.json 转为 protobuf 格式"></a>5.3、将 config.json 和 modified_config.json 转为 protobuf 格式</h4><pre class="line-numbers language-bash"><code class="language-bash">configtxlator proto_encode --input vtm_config.json --type common.Config <span class="token operator">></span> vtm_config.pbconfigtxlator proto_encode --input vtm_modified_config.json --type common.Config <span class="token operator">></span> vtm_modified_config.pb<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="5-4、根据-config-pb-和-modified-config-pb-计算出-org3-update-pb-，计算出增量更新内容。-类似于-diff-操作，但是针对-protobuf-格式，因此会多出好多操作。"><a href="#5-4、根据-config-pb-和-modified-config-pb-计算出-org3-update-pb-，计算出增量更新内容。-类似于-diff-操作，但是针对-protobuf-格式，因此会多出好多操作。" class="headerlink" title="5.4、根据 config.pb 和 modified_config.pb 计算出 org3_update.pb ，计算出增量更新内容。 (类似于 diff 操作，但是针对 protobuf 格式，因此会多出好多操作。)"></a>5.4、根据 config.pb 和 modified_config.pb 计算出 org3_update.pb ，计算出增量更新内容。 (类似于 diff 操作，但是针对 protobuf 格式，因此会多出好多操作。)</h4><pre class="line-numbers language-bash"><code class="language-bash">configtxlator compute_update --channel_id cfitestchannel --original vtm_config.pb --updated vtm_modified_config.pb <span class="token operator">></span> vtm_config_update.pb<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="5-5、解码-config-update-pb-为-json，然后用-jq-修改，然后在编码为-protobuf-格式，最终输出-syorg-update-in-envelope-pb"><a href="#5-5、解码-config-update-pb-为-json，然后用-jq-修改，然后在编码为-protobuf-格式，最终输出-syorg-update-in-envelope-pb" class="headerlink" title="5.5、解码 config_update.pb 为 json，然后用 jq 修改，然后在编码为 protobuf 格式，最终输出 syorg_update_in_envelope.pb"></a>5.5、解码 config_update.pb 为 json，然后用 jq 修改，然后在编码为 protobuf 格式，最终输出 syorg_update_in_envelope.pb</h4><pre class="line-numbers language-bash"><code class="language-bash">configtxlator proto_decode --input cfi_config_update.pb  --type common.ConfigUpdate <span class="token operator">></span> cfi_config_update.json<span class="token keyword">echo</span> <span class="token string">'{"payload":{"header":{"channel_header":{"channel_id":"cfitestchannel", "type":2}},"data":{"config_update":'</span><span class="token variable"><span class="token variable">$(</span><span class="token function">cat</span> cfi_config_update.json<span class="token variable">)</span></span><span class="token string">'}}}'</span> <span class="token operator">|</span> jq <span class="token keyword">.</span> <span class="token operator">></span> cfi_config_update_in_envelope.jsonconfigtxlator proto_encode --input cfi_config_update_in_envelope.json --type common.Envelope <span class="token operator">></span> cfiorg_update_in_envelope.pb<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="6、为新组织配置签名"><a href="#6、为新组织配置签名" class="headerlink" title="6、为新组织配置签名"></a>6、为新组织配置签名</h3><p>为配置交易签名，需要 channel 中的大多数 Org 对其进行签名。<br>对于 mychannel 而言，已有了 org1，org2，因此新增 org3 时需要 org1、org2 都签名。<br>签名操作于 cli 中完成，需采用 Anchor Peer，可通过更改环境变量，改变签名者的身份。</p><h4 id="6-1、MBFA组织签名"><a href="#6-1、MBFA组织签名" class="headerlink" title="6.1、MBFA组织签名"></a>6.1、MBFA组织签名</h4><pre class="line-numbers language-bash"><code class="language-bash">docker <span class="token function">exec</span> -it cli <span class="token function">bash</span>组织签名peer channel signconfigtx -f cfiorg_update_in_envelope.pb<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="6-2、登录MSC组织CLI继续签名"><a href="#6-2、登录MSC组织CLI继续签名" class="headerlink" title="6.2、登录MSC组织CLI继续签名"></a>6.2、登录MSC组织CLI继续签名</h4><p>（下载MBFA签名后的syorg_update_in_envelope.pb上传到msc组织CLI中，参照MBFA将syorg_update_in_envelope.pb进行签名。）</p><h3 id="7、提交签名后的配置交易至orderer"><a href="#7、提交签名后的配置交易至orderer" class="headerlink" title="7、提交签名后的配置交易至orderer"></a>7、提交签名后的配置交易至orderer</h3><p>注意：需要将syorg_update_in_envelope.pb注意上传到老组织，并逐一叠加签名。然后由生产此pb文件的组织提交更新。</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">export</span> ORDERER_CA<span class="token operator">=</span>/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/fabric.mbfa.cn/orderers/orderer0.fabric.mbfa.cn/msp/tlscacerts/tlsca.fabric.mbfa.cn-cert.pempeer channel update -f cfiorg_update_in_envelope.pb -c cfitestchannel -o orderer0.fabric.mbfa.cn:7050 --cafile <span class="token variable">$ORDERER_CA</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>若成功入链，可以看到以下输出：</p><pre class="line-numbers language-bash"><code class="language-bash">2018-11-01 13:45:17.982 UTC <span class="token punctuation">[</span>kvledger<span class="token punctuation">]</span> CommitWithPvtData -<span class="token operator">></span> INFO 066 <span class="token punctuation">[</span>mbfastorechannel<span class="token punctuation">]</span> Committed block <span class="token punctuation">[</span>2<span class="token punctuation">]</span> with 1 transaction<span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token keyword">in</span> 19ms <span class="token punctuation">(</span>state_validation<span class="token operator">=</span>0ms block_commit<span class="token operator">=</span>13ms state_commit<span class="token operator">=</span>3ms<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>输出显示，当前提交的块号是 6。块 0 是创世块；1<del>2 是一些初始化；3</del>4 是实例化与调用 chaincode ，更新配置。</p>]]></content>
      
      
      <categories>
          
          <category> 区块链 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Fabric </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>五、配置新组织节点</title>
      <link href="/2019/060441103.html"/>
      <url>/2019/060441103.html</url>
      
        <content type="html"><![CDATA[<h2 id="五、在新组织节点使用configtxgen生成SyOrg配置JSON文件"><a href="#五、在新组织节点使用configtxgen生成SyOrg配置JSON文件" class="headerlink" title="五、在新组织节点使用configtxgen生成SyOrg配置JSON文件"></a>五、在新组织节点使用configtxgen生成SyOrg配置JSON文件</h2><h3 id="1、生成组织配置文件"><a href="#1、生成组织配置文件" class="headerlink" title="1、生成组织配置文件"></a>1、生成组织配置文件</h3><p>configtx会在当前目录中寻找configtx.yaml配置文件并从中读取SyOrg相关配置。</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">cd</span> org3-artifacts./configtxgen -printOrg SyOrg -profile ./configtx.yaml <span class="token operator">></span> <span class="token punctuation">..</span>/channel-artifacts/syorg.json<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="configtx-yaml配置文件如下"><a href="#configtx-yaml配置文件如下" class="headerlink" title="configtx.yaml配置文件如下"></a>configtx.yaml配置文件如下</h4><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token key atrule">Organizations</span><span class="token punctuation">:</span>    <span class="token punctuation">-</span> <span class="token important">&amp;SyOrg</span>        <span class="token key atrule">Name</span><span class="token punctuation">:</span> SyOrg        <span class="token key atrule">ID</span><span class="token punctuation">:</span> SyMSP        <span class="token key atrule">MSPDir</span><span class="token punctuation">:</span> crypto<span class="token punctuation">-</span>config/peerOrganizations/sy.fabric.mbfa.cn/msp        <span class="token key atrule">Policies</span><span class="token punctuation">:</span> <span class="token important">&amp;SyOrgPolicies</span>            <span class="token key atrule">Readers</span><span class="token punctuation">:</span>                <span class="token key atrule">Type</span><span class="token punctuation">:</span> Signature                <span class="token key atrule">Rule</span><span class="token punctuation">:</span> <span class="token string">"OR('SyMSP.member')"</span>            <span class="token key atrule">Writers</span><span class="token punctuation">:</span>                <span class="token key atrule">Type</span><span class="token punctuation">:</span> Signature                <span class="token key atrule">Rule</span><span class="token punctuation">:</span> <span class="token string">"OR('SyMSP.member')"</span>            <span class="token key atrule">Admins</span><span class="token punctuation">:</span>                <span class="token key atrule">Type</span><span class="token punctuation">:</span> Signature                <span class="token key atrule">Rule</span><span class="token punctuation">:</span> <span class="token string">"OR('SyMSP.admin')"</span>        <span class="token key atrule">AnchorPeers</span><span class="token punctuation">:</span>            <span class="token punctuation">-</span> <span class="token key atrule">Host</span><span class="token punctuation">:</span> peer.sy.fabric.mbfa.cn              <span class="token key atrule">Port</span><span class="token punctuation">:</span> <span class="token number">7051</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2、配置新组织节点"><a href="#2、配置新组织节点" class="headerlink" title="2、配置新组织节点"></a>2、配置新组织节点</h3><p>修改cfi.yaml配置文件，需要检查环境差异。需要注意docker配置文件中对应的fabric链镜像版本号。</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">mv</span> org3-artifacts/crypto-config <span class="token keyword">.</span><span class="token function">cat</span> /etc/resolv.conf//此为正常配置    nameserver 127.0.0.11    options ndots:0//如果输出结果如下，需要在docker compose yaml模板增加环境变量，GODEBUG<span class="token operator">=</span>netdns<span class="token operator">=</span>go以强制使用pure Go resolver    nameserver 127.0.0.11    options timeout:2 attempts:3 rotate single-request-reopen ndots:0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 区块链 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Fabric </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>四、在新组织节点生成证书</title>
      <link href="/2019/060422060.html"/>
      <url>/2019/060422060.html</url>
      
        <content type="html"><![CDATA[<h2 id="四、在新组织节点（ORG）生成证书"><a href="#四、在新组织节点（ORG）生成证书" class="headerlink" title="四、在新组织节点（ORG）生成证书"></a>四、在新组织节点（ORG）生成证书</h2><h3 id="1、生成证书命令"><a href="#1、生成证书命令" class="headerlink" title="1、生成证书命令"></a>1、生成证书命令</h3><p>(依据 crypto-config.yaml 生成，生成后的文件位于 org3-artifacts/crypto-config/ 下)：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">cd</span> org3-artifacts./cryptogen generate --config<span class="token operator">=</span>./crypto-config.yaml --output ./crypto-config<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="2、crypto-config-yamll-文件如下"><a href="#2、crypto-config-yamll-文件如下" class="headerlink" title="2、crypto-config.yamll 文件如下"></a>2、crypto-config.yamll 文件如下</h3><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token key atrule">PeerOrgs</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token key atrule">Name</span><span class="token punctuation">:</span> SyOrg    <span class="token key atrule">Domain</span><span class="token punctuation">:</span> sy.fabric.mbfa.cn    <span class="token key atrule">CA</span><span class="token punctuation">:</span>        <span class="token key atrule">Country</span><span class="token punctuation">:</span> CN        <span class="token key atrule">Province</span><span class="token punctuation">:</span> Beijing        <span class="token key atrule">Locality</span><span class="token punctuation">:</span> Beijing    <span class="token key atrule">Specs</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> <span class="token key atrule">Hostname</span><span class="token punctuation">:</span> peer    <span class="token key atrule">Users</span><span class="token punctuation">:</span>      <span class="token key atrule">Count</span><span class="token punctuation">:</span> <span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 区块链 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Fabric </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>三、新建channel</title>
      <link href="/2019/060423381.html"/>
      <url>/2019/060423381.html</url>
      
        <content type="html"><![CDATA[<h2 id="三、新建channel"><a href="#三、新建channel" class="headerlink" title="三、新建channel"></a>三、新建channel</h2><p>（MBFA组织任意节点上执行）</p><h3 id="1、创建交易文件"><a href="#1、创建交易文件" class="headerlink" title="1、创建交易文件"></a>1、创建交易文件</h3><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">export</span> PATH<span class="token operator">=</span><span class="token variable">$PATH</span>:/data/fabric/bin<span class="token function">export</span> ORDERER_GENERAL_GENESISPROFILE<span class="token operator">=</span>MbfaGenesisconfigtxgen -profile MbfaChannel -outputCreateChannelTx ./channel-artifacts/sycfinchannel.tx -channelID syfinchannel<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="2、为新组织创建channel"><a href="#2、为新组织创建channel" class="headerlink" title="2、为新组织创建channel"></a>2、为新组织创建channel</h3><p>登录docker cli</p><pre class="line-numbers language-bash"><code class="language-bash">docker <span class="token function">exec</span> -it cli <span class="token function">bash</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="3、发起创建channel交易"><a href="#3、发起创建channel交易" class="headerlink" title="3、发起创建channel交易"></a>3、发起创建channel交易</h3><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">export</span> CORE_PEER_ADDRESS<span class="token operator">=</span>am.mbfa.fabric.mbfa.cn:7051<span class="token function">export</span> CORE_PEER_LOCALMSPID<span class="token operator">=</span>MbfaMSP<span class="token function">export</span> CORE_PEER_TLS_ENABLED<span class="token operator">=</span>false<span class="token function">export</span> CORE_PEER_TLS_CERT_FILE<span class="token operator">=</span>/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/mbfa.fabric.mbfa.cn/peers/am.mbfa.fabric.mbfa.cn/tls/server.crt<span class="token function">export</span> CORE_PEER_TLS_KEY_FILE<span class="token operator">=</span>/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/mbfa.fabric.mbfa.cn/peers/am.mbfa.fabric.mbfa.cn/tls/server.key<span class="token function">export</span> CORE_PEER_TLS_ROOTCERT_FILE<span class="token operator">=</span>/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/mbfa.fabric.mbfa.cn/peers/am.mbfa.fabric.mbfa.cn/tls/ca.crt<span class="token function">export</span> CORE_PEER_MSPCONFIGPATH<span class="token operator">=</span>/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/mbfa.fabric.mbfa.cn/users/Admin@mbfa.fabric.mbfa.cn/msppeer channel create -o orderer0.fabric.mbfa.cn:7050 -c syfinchannel -f ./channel-artifacts/syfinchannel.tx<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 区块链 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Fabric </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二、新组织基础环境安装</title>
      <link href="/2019/060413766.html"/>
      <url>/2019/060413766.html</url>
      
        <content type="html"><![CDATA[<h2 id="二、新组织基础环境安装"><a href="#二、新组织基础环境安装" class="headerlink" title="二、新组织基础环境安装"></a>二、新组织基础环境安装</h2><h3 id="1、安装epel源"><a href="#1、安装epel源" class="headerlink" title="1、安装epel源"></a>1、安装epel源</h3><pre class="line-numbers language-bash"><code class="language-bash">yum <span class="token function">install</span> epel-release<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="2、安装依赖包"><a href="#2、安装依赖包" class="headerlink" title="2、安装依赖包"></a>2、安装依赖包</h3><pre class="line-numbers language-bash"><code class="language-bash">yum <span class="token function">install</span> snappy-devel.x86_64 zlib-devel.x86_64 bzip2-devel.x86_64 libtool-ltdl-devel.x86_64 libtool <span class="token function">git</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="3、安装docker"><a href="#3、安装docker" class="headerlink" title="3、安装docker"></a>3、安装docker</h3><pre class="line-numbers language-bash"><code class="language-bash">yum localinstall docker-ce-18.05.0.ce-3.el7.centos.x86_64.rpm <span class="token punctuation">(</span>安装包见附件<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="4、安装docker-compose"><a href="#4、安装docker-compose" class="headerlink" title="4、安装docker-compose"></a>4、安装docker-compose</h3><pre class="line-numbers language-bash"><code class="language-bash">curl -L https://github.com/docker/compose/releases/download/1.21.0/docker-compose-<span class="token variable"><span class="token variable">`</span><span class="token function">uname</span> -s<span class="token variable">`</span></span>-<span class="token variable"><span class="token variable">`</span><span class="token function">uname</span> -m<span class="token variable">`</span></span> <span class="token operator">></span> /usr/local/bin/docker-compose<span class="token function">chmod</span> +x /usr/local/bin/docker-compose<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="5、配置docker源（如果不配置拉取的是国外的镜像源）"><a href="#5、配置docker源（如果不配置拉取的是国外的镜像源）" class="headerlink" title="5、配置docker源（如果不配置拉取的是国外的镜像源）"></a>5、配置docker源（如果不配置拉取的是国外的镜像源）</h3><pre class="line-numbers language-bash"><code class="language-bash"><span class="token punctuation">[</span> -d /etc/docker <span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> <span class="token keyword">echo</span> <span class="token string">"docker dir Already exist"</span> <span class="token operator">||</span> <span class="token function">mkdir</span> /etc/docker<span class="token function">tee</span> /etc/docker/daemon.json <span class="token operator">&lt;&lt;</span>-<span class="token string">'EOF'</span><span class="token punctuation">{</span>  <span class="token string">"registry-mirrors"</span><span class="token keyword">:</span> <span class="token punctuation">[</span><span class="token string">"https://k03hynjl.mirror.aliyuncs.com"</span><span class="token punctuation">]</span><span class="token punctuation">}</span>EOF<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="6、拷贝fabric网络相关组件到当前用户目录（非root用户），内容如下"><a href="#6、拷贝fabric网络相关组件到当前用户目录（非root用户），内容如下" class="headerlink" title="6、拷贝fabric网络相关组件到当前用户目录（非root用户），内容如下"></a>6、拷贝fabric网络相关组件到当前用户目录（非root用户），内容如下</h3><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">scp</span> -r cfichain@xxx.xxx.xxx.xxx:/home/cfichain/cfi_network <span class="token keyword">.</span><span class="token function">sudo</span> <span class="token function">scp</span> -r cfichain@xxx.xxx.xxx.xxx:/home/cfichain/bin <span class="token keyword">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="7、清理数据"><a href="#7、清理数据" class="headerlink" title="7、清理数据"></a>7、清理数据</h3><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">rm</span> -fr /data/fabric/bin/channel-artifacts/*<span class="token function">rm</span> -fr /data/fabric/bin/crypto-config/*<span class="token function">rm</span> -fr /data/fabric/bin/chaindata/*/*/*<span class="token function">rm</span> -fr /data/fabric/bin/chainData/*/*/*<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 区块链 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Fabric </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一、文章摘要</title>
      <link href="/2019/060448940.html"/>
      <url>/2019/060448940.html</url>
      
        <content type="html"><![CDATA[<p>一个商用的区块链网络，随着业务的发展变化，经常需要动态的新增/移除组织，以满足业务/安全等管理需要。本文在既有组织/节点的基础上，新增一个组织两个节点。</p><p>Fabric 是联盟链，一个 Channel 就好比一个子链，如果有新的机构需要加入，则必须得到联盟内的成员的认可。基于这样的场景，Fabric 在为 channel 新增 org 时，会涉及诸多的权限和证书操作。</p><h2 id="Fabric-动态新增组织步骤"><a href="#Fabric-动态新增组织步骤" class="headerlink" title="Fabric 动态新增组织步骤"></a>Fabric 动态新增组织步骤</h2><ol><li>为新 org 生成证书</li><li>为新 org 生成配置文件</li><li>生成和提交新 org 的配置<ol><li>peer channel fetch config 创建添加新 org 的配置交易，为网络新增 org</li><li>peer channel signconfigtx 为配置交易签名，需网络中 MAJORITY 的 org 都签名</li><li>peer channel update 提交签名后的配置交易至 orderer</li></ol></li><li>将新 org 添加入 channel<ol><li>启动新 org 集群，一般会有一个 cli 和多个 peer</li><li>peer channel fetch 于 cli 中从 orderer 中获取 channel 创世块</li><li>peer channel join 将新 org 下的 peer 加入 channel</li></ol></li><li>升级chaincode和背书策略<ol><li>peer chaincode install 为新 org 的 peer 安装 chaincode，于新 org 的 cli 中完成</li><li>peer chaincode install, 为其他 org 升级 chaincode，于原 org 的 cli 中完成</li><li>peer chaincode upgrade 升级背书策略，于原 org 的 cli 中完成<br>此文通过 fabric-samples 下的 first-network 样例为基础，在其区块链网络上，为通道 cfichannel 新增一个组织Cfec，CfecOrg 包含个 peer。</li></ol></li></ol>]]></content>
      
      
      <categories>
          
          <category> 区块链 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Fabric </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>桥接模式（Bridge Pattern）</title>
      <link href="/2018/121928602.html"/>
      <url>/2018/121928602.html</url>
      
        <content type="html"><![CDATA[<h2 id="模式动机"><a href="#模式动机" class="headerlink" title="模式动机"></a>模式动机</h2><p>设想如果要绘制矩形、圆形、椭圆、正方形，我们至少需要 4 个形状类，但是如果绘制的图形需要具有不同的颜色，如红色、绿色、蓝色等，此时至少有如下两种设计方案：</p><ul><li>第一种设计方案是为每一种形状都提供一套各种颜色的版本。</li><li>第二种设计方案是根据实际需要对形状和颜色进行组合</li></ul><p>对于有两个变化维度（即两个变化的原因）的系统，采用方案二来进行设计系统中类的个数更少，且系统扩展更为方便。设计方案二即是桥接模式的应用。桥接模式将继承关系转换为关联关系，从而降低了类与类之间的耦合，减少了代码编写量。</p><h2 id="模式定义"><a href="#模式定义" class="headerlink" title="模式定义"></a>模式定义</h2><blockquote><p><strong>桥接模式</strong>(<code>Bridge Pattern</code>)：将抽象和实现解耦，使得两者可以独立地变化。它是一种对象结构型模式，又称为桥梁模式。</p></blockquote><h3 id="模式角色"><a href="#模式角色" class="headerlink" title="模式角色"></a>模式角色</h3><p>桥接模式包含如下角色：</p><ul><li><code>Abstraction</code>：抽象类角色</li><li><code>RefinedAbstraction</code>：扩充抽象类</li><li><code>Implementor</code>：实现化角色</li><li><code>ConcreteImplementor</code>：具体实现化角色的实现类</li></ul><h3 id="UML-类图"><a href="#UML-类图" class="headerlink" title="UML 类图"></a>UML 类图</h3><p><img src="https://pic.lixl.cn/2019/java-design-bridge.jpg" alt="桥接模式UML"></p><h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h2><p>首先，是实现化角色<code>Abstraction</code>类：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 实现化角色 Implementor. */</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Implementor</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 基本方法1.     */</span>    <span class="token keyword">void</span> <span class="token function">doSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * 基本方法2.     */</span>    <span class="token keyword">void</span> <span class="token function">doAnything</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后，是各个具体的实现化角色类：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * ConcreteImplementor1. */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConcreteImplementor1</span> <span class="token keyword">implements</span> <span class="token class-name">Implementor</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 基本方法1.     */</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">doSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"ConcreteImplementor1 的业务逻辑 doSomething."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 基本方法2.     */</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">doAnything</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"ConcreteImplementor1 的业务逻辑 doAnything."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * ConcreteImplementor2. */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConcreteImplementor2</span> <span class="token keyword">implements</span> <span class="token class-name">Implementor</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 基本方法1.     */</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">doSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"ConcreteImplementor2 的业务逻辑 doSomething."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 基本方法2.     */</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">doAnything</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"ConcreteImplementor2 的业务逻辑 doAnything."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>接下来，是抽象类角色<code>Abstraction</code>类：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>blinkfox<span class="token punctuation">.</span>patterns<span class="token punctuation">.</span>bridge<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * 抽象化角色 Abstraction. */</span><span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">Abstraction</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/** 定义对实现化角色的引用. */</span>    <span class="token keyword">private</span> Implementor impl<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * 构造方法.     *     * @param impl 实现类的实例     */</span>    <span class="token keyword">public</span> <span class="token function">Abstraction</span><span class="token punctuation">(</span>Implementor impl<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>impl <span class="token operator">=</span> impl<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * impl 的 getter方法.     *     * @return impl     */</span>    <span class="token keyword">public</span> Implementor <span class="token function">getImpl</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> impl<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 自身的请求处理方法.     */</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">request</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>impl<span class="token punctuation">.</span><span class="token function">doSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>再次，是扩展的具体抽象化角色类<code>RefinedAbstraction</code>：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * RefinedAbstraction. */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">RefinedAbstraction</span> <span class="token keyword">extends</span> <span class="token class-name">Abstraction</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 构造方法.     *     * @param impl 实现类的实例     */</span>    <span class="token keyword">public</span> <span class="token function">RefinedAbstraction</span><span class="token punctuation">(</span>Implementor impl<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">super</span><span class="token punctuation">(</span>impl<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 覆盖后的请求处理方法.     */</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">request</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"RefinedAbstraction 开始做业务处理."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">request</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">getImpl</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">doAnything</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>最后，是客户端场景类：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * Client. */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Client</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * main方法.     *     * @param args 数组参数     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 定义一个实现化角色和抽象化角色,并执行请求方法.</span>        Implementor impl <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcreteImplementor1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Abstraction abs <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">RefinedAbstraction</span><span class="token punctuation">(</span>impl<span class="token punctuation">)</span><span class="token punctuation">;</span>        abs<span class="token punctuation">.</span><span class="token function">request</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="模式分析"><a href="#模式分析" class="headerlink" title="模式分析"></a>模式分析</h2><p>理解桥接模式，重点需要理解如何将抽象化(<code>Abstraction</code>)与实现化(<code>Implementation</code>)脱耦，使得二者可以独立地变化。</p><ul><li><strong>抽象化</strong>：抽象化就是忽略一些信息，把不同的实体当作同样的实体对待。在面向对象中，将对象的共同性质抽取出来形成类的过程即为抽象化的过程。</li><li><strong>实现化</strong>：针对抽象化给出的具体实现，就是实现化，抽象化与实现化是一对互逆的概念，实现化产生的对象比抽象化更具体，是对抽象化事物的进一步具体化的产物。</li><li><strong>脱耦</strong>：脱耦就是将抽象化和实现化之间的耦合解脱开，或者说是将它们之间的强关联改换成弱关联，将两个角色之间的继承关系改为关联关系。<strong>桥接模式中的所谓脱耦，就是指在一个软件系统的抽象化和实现化之间使用关联关系（组合或者聚合关系）而不是继承关系，从而使两者可以相对独立地变化，这就是桥接模式的用意。</strong></li></ul><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p>桥接模式的优点:</p><ul><li>分离抽象接口及其实现部分。</li><li>桥接模式有时类似于多继承方案，但是多继承方案违背了类的单一职责原则（即一个类只有一个变化的原因），复用性比较差，而且多继承结构中类的个数非常庞大，桥接模式是比多继承方案更好的解决方法。</li><li>桥接模式提高了系统的可扩充性，在两个变化维度中任意扩展一个维度，都不需要修改原有系统。</li><li>实现细节对客户透明，可以对用户隐藏实现细节。</li></ul><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>桥接模式的缺点:</p><ul><li>桥接模式的引入会增加系统的理解与设计难度，由于聚合关联关系建立在抽象层，要求开发者针对抽象进行设计与编程。</li><li>桥接模式要求正确识别出系统中两个独立变化的维度，因此其使用范围具有一定的局限性。</li></ul><h3 id="适用环境"><a href="#适用环境" class="headerlink" title="适用环境"></a>适用环境</h3><p>在以下情况下可以使用桥接模式：</p><ul><li>如果一个系统需要在构件的抽象化角色和具体化角色之间增加更多的灵活性，避免在两个层次之间建立静态的继承联系，通过桥接模式可以使它们在抽象层建立一个关联关系。</li><li>抽象化角色和实现化角色可以以继承的方式独立扩展而互不影响，在程序运行时可以动态将一个抽象化子类的对象和一个实现化子类的对象进行组合，即系统需要对抽象化角色和实现化角色进行动态耦合。</li><li>一个类存在两个独立变化的维度，且这两个维度都需要进行扩展。</li><li>虽然在系统中使用继承是没有问题的，但是由于抽象化角色和具体化角色需要独立变化，设计要求需要独立管理这两者。</li><li>对于那些不希望使用继承或因为多层次继承导致系统类的个数急剧增加的系统，桥接模式尤为适用。</li></ul><h3 id="模式应用"><a href="#模式应用" class="headerlink" title="模式应用"></a>模式应用</h3><p>一个 Java 桌面软件总是带有所在操作系统的视感(<code>LookAndFeel</code>)，如果一个 Java 软件是在 Unix 系统上开发的，那么开发人员看到的是<code>Motif</code>用户界面的视感；在 Windows 上面使用这个系统的用户看到的是 Windows 用户界面的视感；而一个在<code>Macintosh</code>上面使用的用户看到的则是<code>Macintosh</code>用户界面的视感，Java 语言是通过所谓的 Peer 架构做到这一点的。Java 为 AWT 中的每一个 GUI 构件都提供了一个 Peer 构件，在 AWT 中的 Peer 架构就使用了桥接模式。</p><h3 id="模式扩展"><a href="#模式扩展" class="headerlink" title="模式扩展"></a>模式扩展</h3><p>适配器模式与桥接模式的联用:</p><p>桥接模式和适配器模式用于设计的不同阶段，<strong>桥接模式用于系统的初步设计</strong>，对于存在两个独立变化维度的类可以将其分为抽象化和实现化两个角色，使它们可以分别进行变化；而在初步设计完成之后，<strong>当发现系统与已有类无法协同工作时，可以采用适配器模式</strong>。但有时候在设计初期也需要考虑适配器模式，特别是那些涉及到大量第三方应用接口的情况。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>桥接模式将抽象部分与它的实现部分分离，使它们都可以独立地变化。它是一种对象结构型模式。</li><li>桥接模式包含如下四个角色：抽象类中定义了一个实现类接口类型的对象并可以维护该对象；扩充抽象类扩充由抽象类定义的接口，它实现了在抽象类中定义的抽象业务方法，在扩充抽象类中可以调用在实现类接口中定义的业务方法；实现类接口定义了实现类的接口，实现类接口仅提供基本操作，而抽象类定义的接口可能会做更多更复杂的操作；具体实现类实现了实现类接口并且具体实现它，在不同的具体实现类中提供基本操作的不同实现，在程序运行时，具体实现类对象将替换其父类对象，提供给客户端具体的业务操作方法。</li><li>在桥接模式中，抽象化(<code>Abstraction</code>)与实现化(<code>Implementation</code>)脱耦，它们可以沿着各自的维度独立变化。</li><li>桥接模式的主要优点是分离抽象接口及其实现部分，是比多继承方案更好的解决方法，桥接模式还提高了系统的可扩充性，在两个变化维度中任意扩展一个维度，都不需要修改原有系统，实现细节对客户透明，可以对用户隐藏实现细节；其主要缺点是增加系统的理解与设计难度，且识别出系统中两个独立变化的维度并不是一件容易的事情。</li><li>桥接模式适用情况包括：需要在构件的抽象化角色和具体化角色之间增加更多的灵活性，避免在两个层次之间建立静态的继承联系；抽象化角色和实现化角色可以以继承的方式独立扩展而互不影响；一个类存在两个独立变化的维度，且这两个维度都需要进行扩展；设计要求需要独立管理抽象化角色和具体化角色；不希望使用继承或因为多层次继承导致系统类的个数急剧增加的系统。</li></ul><p>参考自：<a href="https://design-patterns.readthedocs.io/zh_CN/latest/structural_patterns/bridge.html" target="_blank" rel="noopener">桥接模式</a></p>]]></content>
      
      
      <categories>
          
          <category> 软件设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 设计原则与模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>适配器模式（Adapter Pattern）</title>
      <link href="/2018/12121265.html"/>
      <url>/2018/12121265.html</url>
      
        <content type="html"><![CDATA[<h2 id="模式动机"><a href="#模式动机" class="headerlink" title="模式动机"></a>模式动机</h2><ul><li>在软件开发中采用类似于电源适配器的设计和编码技巧被称为适配器模式。</li><li>通常情况下，客户端可以通过目标类的接口访问它所提供的服务。有时，现有的类可以满足客户类的功能需要，但是它所提供的接口不一定是客户类所期望的，这可能是因为现有类中方法名与目标类中定义的方法名不一致等原因所导致的。</li><li>在这种情况下，现有的接口需要转化为客户类期望的接口，这样保证了对现有类的重用。如果不进行这样的转化，客户类就不能利用现有类所提供的功能，适配器模式可以完成这样的转化。</li><li>在适配器模式中可以定义一个包装类，包装不兼容接口的对象，这个包装类指的就是适配器(<code>Adapter</code>)，它所包装的对象就是适配者(<code>Adaptee</code>)，即被适配的类。</li><li>适配器提供客户类需要的接口，适配器的实现就是把客户类的请求转化为对适配者的相应接口的调用。也就是说：当客户类调用适配器的方法时，在适配器类的内部将调用适配者类的方法，而这个过程对客户类是透明的，客户类并不直接访问适配者类。因此，适配器可以使由于接口不兼容而不能交互的类可以一起工作。这就是适配器模式的模式动机。</li></ul><h2 id="模式定义"><a href="#模式定义" class="headerlink" title="模式定义"></a>模式定义</h2><blockquote><p><strong>适配器模式</strong>(<code>Adapter Pattern</code>) ：将一个接口转换成客户希望的另一个接口，使接口不兼容的那些类可以一起工作，其别名为包装器(<code>Wrapper</code>)。适配器模式既可以作为类结构型模式，也可以作为对象结构型模式。适配器模式是一种<strong>结构型模式</strong>。</p></blockquote><h2 id="模式结构"><a href="#模式结构" class="headerlink" title="模式结构"></a>模式结构</h2><h3 id="参与角色"><a href="#参与角色" class="headerlink" title="参与角色"></a>参与角色</h3><p>适配器模式包含如下角色：</p><ul><li><code>Target</code>：目标抽象类</li><li><code>Adapter</code>：适配器类</li><li><code>Adaptee</code>：适配者类</li><li><code>Client</code>：客户类</li></ul><h3 id="UML-类图"><a href="#UML-类图" class="headerlink" title="UML 类图"></a>UML 类图</h3><p><img src="https://pic.lixl.cn/2019/java-design-adapter.jpg" alt="适配器模式UML"></p><h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h2><p>首先，是目标角色接口和具体目标实现类：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * Target 目标角色类. */</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Target</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 目标角色自己的方法.     */</span>    <span class="token keyword">void</span> <span class="token function">request</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 具体的目标角色实现类. */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConcreteTarget</span> <span class="token keyword">implements</span> <span class="token class-name">Target</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 目标角色自己的方法.     */</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">request</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"hello, I'm concrete target method."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其次，是适配者类：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 适配者类. */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Adaptee</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 这是原有的业务逻辑方法.     */</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">doSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Hello, I'm Adaptee method."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后，是适配器角色类：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 适配器类. */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Adapter</span> <span class="token keyword">extends</span> <span class="token class-name">Adaptee</span> <span class="token keyword">implements</span> <span class="token class-name">Target</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 适配了目标角色自己的方法.     */</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">request</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">doSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"适配器适配了目标角色方法."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>最后，是客户端场景类：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 客户端场景类. */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Client</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * main方法.     *     * @param args 数组参数     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 原有业务逻辑.</span>        Target target <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcreteTarget</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        target<span class="token punctuation">.</span><span class="token function">request</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 增加了适配器角色后的业务逻辑.</span>        Target adaptTarget <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Adapter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        adaptTarget<span class="token punctuation">.</span><span class="token function">request</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="模式分析"><a href="#模式分析" class="headerlink" title="模式分析"></a>模式分析</h2><h3 id="适用环境"><a href="#适用环境" class="headerlink" title="适用环境"></a>适用环境</h3><p>在以下情况下可以使用适配器模式：</p><ul><li>系统需要使用现有的类，而这些类的接口不符合系统的需要。</li><li>想要建立一个可以重复使用的类，用于与一些彼此之间没有太大关联的一些类，包括一些可能在将来引进的类一起工作。</li></ul><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul><li>将目标类和适配者类解耦，通过引入一个适配器类来重用现有的适配者类，而无须修改原有代码。</li><li>增加了类的透明性和复用性，将具体的实现封装在适配者类中，对于客户端类来说是透明的，而且提高了适配者的复用性。</li><li>灵活性和扩展性都非常好，通过使用配置文件，可以很方便地更换适配器，也可以在不修改原有代码的基础上增加新的适配器类，完全符合“开闭原则”。</li></ul><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>如果一定要置换掉适配者类的一个或多个方法，就只好先做一个适配者类的子类，将适配者类的方法置换掉，然后再把适配者类的子类当做真正的适配者进行适配，实现过程较为复杂。</p><h3 id="模式应用"><a href="#模式应用" class="headerlink" title="模式应用"></a>模式应用</h3><p>Sun 公司在 1996 年公开了 Java 语言的数据库连接工具 JDBC，JDBC 使得 Java 语言程序能够与数据库连接，并使用 SQL 语言来查询和操作数据。JDBC 给出一个客户端通用的抽象接口，每一个具体数据库引擎（如 SQL Server、Oracle、MySQL 等）的 JDBC 驱动软件都是一个介于 JDBC 接口和数据库引擎接口之间的适配器软件。抽象的 JDBC 接口和各个数据库引擎 API 之间都需要相应的适配器软件，这就是为各个不同数据库引擎准备的驱动程序。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>结构型模式描述如何将类或者对象结合在一起形成更大的结构。</li><li>适配器模式用于将一个接口转换成客户希望的另一个接口，适配器模式使接口不兼容的那些类可以一起工作，其别名为包装器。适配器模式既可以作为类结构型模式，也可以作为对象结构型模式。</li><li>适配器模式包含四个角色：目标抽象类定义客户要用的特定领域的接口；适配器类可以调用另一个接口，作为一个转换器，对适配者和抽象目标类进行适配，它是适配器模式的核心；适配者类是被适配的角色，它定义了一个已经存在的接口，这个接口需要适配；在客户类中针对目标抽象类进行编程，调用在目标抽象类中定义的业务方法。</li><li>在类适配器模式中，适配器类实现了目标抽象类接口并继承了适配者类，并在目标抽象类的实现方法中调用所继承的适配者类的方法；在对象适配器模式中，适配器类继承了目标抽象类并定义了一个适配者类的对象实例，在所继承的目标抽象类方法中调用适配者类的相应业务方法。</li><li>适配器模式的主要优点是将目标类和适配者类解耦，增加了类的透明性和复用性，同时系统的灵活性和扩展性都非常好，更换适配器或者增加新的适配器都非常方便，符合“开闭原则”；类适配器模式的缺点是适配器类在很多编程语言中不能同时适配多个适配者类，对象适配器模式的缺点是很难置换适配者类的方法。</li><li>适配器模式适用情况包括：系统需要使用现有的类，而这些类的接口不符合系统的需要；想要建立一个可以重复使用的类，用于与一些彼此之间没有太大关联的一些类一起工作。</li></ul><p>参考自：<a href="https://design-patterns.readthedocs.io/zh_CN/latest/structural_patterns/adapter.html" target="_blank" rel="noopener">适配器模式</a></p>]]></content>
      
      
      <categories>
          
          <category> 软件设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 设计原则与模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软件程序设计原则</title>
      <link href="/2018/112425424.html"/>
      <url>/2018/112425424.html</url>
      
        <content type="html"><![CDATA[<h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>软件也像人一样，具有生命力，从出生到死亡，会经历多种变化。软件架构设计也不是一蹴而就的，是不断地演进发展。每个程序员都可以从理解编程原则和模式中受益。</p><p>软件设计原则是一组帮助我们避开不良设计的指导方针。根据 <code>Robert Martin</code> 的理论，应该避免不良设计的以下三个重要特点：</p><ul><li><strong>僵化</strong>：很难做改动，因为每一个细微的改动都会影响到系统大量的其他功能</li><li><strong>脆弱</strong>：每当你做一次改动，总会引起系统中预期之外的部分出现故障</li><li><strong>死板</strong>：代码很难在其他应用中重用，因其不能从当前应用中单独抽离出来</li></ul><p>下面这些软件设计原则是我从一些书籍和网络中收集而来，并不完整，而且你也需要在一些有“冲突的原则”之间进行权衡和取舍。本文或许会对你的编程、程序设计、讨论或评审工作有所帮助。</p><h2 id="二、面向对象设计原则"><a href="#二、面向对象设计原则" class="headerlink" title="二、面向对象设计原则"></a>二、面向对象设计原则</h2><h3 id="1-单一职责原则（SRP）"><a href="#1-单一职责原则（SRP）" class="headerlink" title="1. 单一职责原则（SRP）"></a>1. 单一职责原则（SRP）</h3><p>所谓<code>SRP</code>原则，即：<code>Single Responsibility Principle</code>，<strong>单一职责原则</strong>。原始定义如下：</p><blockquote><p>There should never be more than one reason for a class to change.(<strong>只有一个引起类改变的原因</strong>)</p></blockquote><p>在面向对象编程领域中，单一职责原则（<code>Single responsibility principle</code>）规定每个类都应该有一个单一的职责或者叫功能，并且该功能应该由这个类完全封装起来。所有它的（这个类的）服务都应该严密的和该功能平行（功能平行，意味着没有依赖）。一个类或者模块应该有且只有一个改变的原因。</p><p>如果一个类承担的职责过多，就等于把这些职责耦合在一起了。一个职责的变化可能会削弱或者抑制这个类完成其他职责的能力。这种耦合会导致脆弱的设计，当发生变化时，设计会遭受到意想不到的破坏。而如果想要避免这种现象的发生，就要尽可能的遵守单一职责原则。此原则的核心就是 <strong>解耦</strong> 和 <strong>增强内聚性</strong>。</p><h4 id="单一职责的好处"><a href="#单一职责的好处" class="headerlink" title="单一职责的好处"></a>单一职责的好处</h4><ul><li>类的复杂性降低，实现什么职责都有清晰明确的定义;</li><li>可读性提高，复杂性降低，可维护性提高;</li><li>变更引起的风险降低。</li></ul><h4 id="单一职责原则的注意点"><a href="#单一职责原则的注意点" class="headerlink" title="单一职责原则的注意点"></a>单一职责原则的注意点</h4><ul><li>单一职责最难划分的是<strong>职责</strong>。</li><li>单一职责原则提出标准：用职责和变化原因来衡量接口或类设计的是否优良，但是职责和变化原因都是不可度量的，因项目、环境而异。</li><li>接口一定要做到单一职责，类的设计尽量做到只有一个原因引起它变化。</li></ul><h3 id="2-里氏替换原则（LSP）"><a href="#2-里氏替换原则（LSP）" class="headerlink" title="2. 里氏替换原则（LSP）"></a>2. 里氏替换原则（LSP）</h3><p>所谓<code>LSP</code>原则，即：<code>Liskov Substitution principle</code>，<strong>里氏替换原则</strong>。原始定义如下：</p><blockquote><p>Functions that use pointers of references to base classes must be able to use objects of derived classes without knowing it.（<strong>所有引用基类的地方必须能透明地使用其子类的对象</strong>）</p></blockquote><p>更通俗的定义即为：<strong>子类可以扩展父类的功能，但不能改变父类原有的功能</strong>。里氏替换原则包含了一下 4 层含义：</p><ul><li>子类必须完全实现父类的方法。在类中调用其他类是务必要使用父类或接口，如果不能使用父类或接口，则说明类的设计已经违背了<code>LSP</code>原则。</li><li>子类可以有自己的个性。子类当然可以有自己的行为和外观了，也就是方法和属性。</li><li>覆盖或实现父类的方法时输入参数可以被放大。即子类可以覆盖父类的方法，但输入参数应比父类方法中的大，这样在子类代替父类的时候，调用的仍然是父类的方法。即以子类中方法的前置条件必须与超类中被覆盖的方法的前置条件相同或者更宽松。</li><li>覆盖或实现父类的方法时输出结果可以被缩小。</li></ul><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul><li>提高代码的重用性，子类拥有父类的方法和属性；</li><li>提高代码的可扩展性，子类可形似于父类，但异于父类，保留自我的特性；</li></ul><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul><li>继承是侵入性的，只要继承就必须拥有父类的所有方法和属性，在一定程度上约束了子类，降低了代码的灵活性；</li><li>增加了耦合，当父类的常量、变量或者方法被修改了，需要考虑子类的修改，所以一旦父类有了变动，很可能会造成非常糟糕的结果，要重构大量的代码。</li></ul><h3 id="3-接口隔离原则（ISP）"><a href="#3-接口隔离原则（ISP）" class="headerlink" title="3. 接口隔离原则（ISP）"></a>3. 接口隔离原则（ISP）</h3><p>所谓<code>ISP</code>原则，即：<code>Interface Segregation Principle</code>，<strong>接口隔离原则</strong>。原始定义如下：</p><blockquote><p>Clients should not be forced to depend upon interfaces that they do not use.(客户端只依赖于它所需要的接口；它需要什么接口就提供什么接口，把不需要的接口剔除掉。)<br>The dependency of one class to another one should depend on the smallest possible interface.(类间的依赖关系应建立在最小的接口上。)</p></blockquote><p>即，<strong>接口尽量细化，接口中的方法尽量少</strong>。接口隔离原则与单一职责原则的审视角度是不同的，单一职责原则要求的是类和接口职责单一，注重的是职责，这是业务逻辑上的划分，而接口隔离原则要求接口的方法尽量少。根据接口隔离原则拆分接口时，首先必须满足单一职责原则。</p><p>采用接口隔离原则对接口进行约束时，要注意以下几点：</p><ul><li>接口尽量小，但是要有限度。对接口进行细化可以提高程序设计灵活性是不挣的事实，但是如果过小，则会造成接口数量过多，使设计复杂化。所以一定要适度。</li><li>为依赖接口的类定制服务，只暴露给调用的类它需要的方法，它不需要的方法则隐藏起来。只有专注地为一个模块提供定制服务，才能建立最小的依赖关系。</li><li>提高内聚，减少对外交互。使接口用最少的方法去完成最多的事情。</li></ul><p>运用接口隔离原则，一定要适度，接口设计的过大或过小都不好。设计接口的时候，只有多花些时间去思考和筹划，才能准确地实践这一原则。</p><h3 id="4-开闭原则（OCP）"><a href="#4-开闭原则（OCP）" class="headerlink" title="4. 开闭原则（OCP）"></a>4. 开闭原则（OCP）</h3><p>所谓<code>OCP</code>原则，即：<code>Open Closed Principle</code>，<strong>开闭原则</strong>。原始定义如下：</p><blockquote><p>software entities (classes, modules, functions, etc.) should be open for extension, but closed for modification.(对扩展开放，对修改关闭)</p></blockquote><p>开闭原则（<code>OCP</code>）是面向对象设计中“可复用设计”的基石，是面向对象设计中最重要的原则之一，其它很多的设计原则和设计模式都是实现开闭原则的一种手段。核心就是：<strong>对扩展开放，对修改关闭</strong>。其含义是说一个软件应该通过扩展来实现变化，而不是通过修改已有的代码来实现变化的。</p><p>软件系统中包含的各种组件，例如模块（<code>Module</code>）、类（<code>Class</code>）以及功能（<code>Function</code>）等等，应该在不修改现有代码的基础上，引入新功能。开闭原则中“开”，是指对于组件功能的扩展是开放的，是允许对其进行功能扩展的；开闭原则中“闭”，是指对于原有代码的修改是封闭的。</p><p>实现开闭原则的关键就在于“<strong>抽象</strong>”。把系统的所有可能的行为抽象成一个抽象底层，这个抽象底层规定出所有的具体实现必须提供的方法的特征。作为系统设计的抽象层，要预见所有可能的扩展，从而使得在任何扩展情况下，系统的抽象底层不需修改；同时，由于可以从抽象底层导出一个或多个新的具体实现，可以改变系统的行为，因此系统设计对扩展是开放的。在实际开发过程的设计开始阶段，就要罗列出来系统所有可能的行为，并把这些行为加入到抽象底层，根本就是不可能的，这么去做也是不经济的。因此我们应该现实的接受修改拥抱变化，使我们的代码可以对扩展开放，对修改关闭。</p><p>开闭原则的好处：</p><ul><li>可复用性好;</li><li>可维护性好。</li></ul><h3 id="5-依赖倒置原则（DIP）"><a href="#5-依赖倒置原则（DIP）" class="headerlink" title="5. 依赖倒置原则（DIP）"></a>5. 依赖倒置原则（DIP）</h3><p>所谓 <code>DIP</code> 原则，即：<code>Dependency Inversion Principle</code>，<strong>依赖倒置原则</strong>。原始定义如下：</p><blockquote><p>High-level modules should not depend on low-level modules. Both should depend on abstractions.(<strong>高层模块不应该依赖低层模块，两者都应该依赖其抽象</strong>)<br>Abstractions should not depend on details. Details should depend on abstractions.(<strong>抽象不应该依赖细节；细节应该依赖抽象</strong>)</p></blockquote><p>面向过程的开发，上层调用下层，上层依赖于下层，当下层剧烈变动时上层也要跟着变动，这就会导致模块的复用性降低而且大大提高了开发的成本。面向对象的开发很好的解决了这个问题，一般情况下抽象的变化概率很小，让用户程序依赖于抽象，实现的细节也依赖于抽象。即使实现细节不断变动，只要抽象不变，客户程序就不需要变化。这大大降低了客户程序与实现细节的耦合度。</p><p>依赖倒置原则主要有以下三层含义：</p><ul><li>高层模块不应该依赖低层模块，两者都应该依赖其抽象（抽象类或接口）；</li><li>抽象不应该依赖细节（具体实现）；</li><li>细节（具体实现）应该依赖抽象。</li></ul><p>依赖倒置原则基于这样一个事实：<strong>相对于细节的多变性，抽象的东西要稳定的多</strong>。以抽象为基础搭建起来的架构比以细节为基础搭建起来的架构要稳定的多。在 Java 中，抽象指的是接口或者抽象类，细节就是具体的实现类，使用接口或者抽象类的目的是制定好规范和契约，而不去涉及任何具体的操作，把展现细节的任务交给他们的实现类去完成。<strong>依赖倒置原则的核心思想就是面向接口编程</strong>。</p><h3 id="6-迪米特法则（LOD-LKP）"><a href="#6-迪米特法则（LOD-LKP）" class="headerlink" title="6. 迪米特法则（LOD | LKP）"></a>6. 迪米特法则（LOD | LKP）</h3><p>所谓 <code>LOD</code> 原则，即：<code>Law of Demeter</code>，<strong>迪米特法则</strong>，又叫<strong>最少知识原则</strong>（<code>Least Knowledge Principle</code>，简写<code>LKP</code>），就是说一个对象应当对其他对象有尽可能少的了解。通俗的讲，一个类应该对自己需要耦合或调用的类知道得最少，被耦合的类是如何的复杂都和我没关系，即为“不和陌生人说话”。迪米特法则的英文解释如下：</p><blockquote><p>talk only to your immediate friends.(<strong>只与直接的朋友通信</strong>)</p></blockquote><p><strong>迪米特法则的初衷在于降低类之间的耦合</strong>。由于每个类尽量减少对其他类的依赖，因此，很容易使得系统的功能模块功能独立，相互之间不存在（或很少有）依赖关系。</p><p>迪米特法则不希望类之间建立直接的联系。如果真的有需要建立联系，也希望能通过它的“朋友”类来转达。因此，应用迪米特法则有可能造成的一个后果就是：系统中存在大量的中介类，这些类之所以存在完全是为了传递类之间的相互调用关系——这在一定程度上增加了系统的复杂度,同时也为系统的维护带来了难度。所以，在采用迪米特法则时需要反复权衡，不遵循不对，严格执行又会“过犹不及”。既要做到让结构清晰，又要做到高内聚低耦合。</p><h3 id="7-组合复用原则（CRP）"><a href="#7-组合复用原则（CRP）" class="headerlink" title="7. 组合复用原则（CRP）"></a>7. 组合复用原则（CRP）</h3><p>所谓<code>CRP</code>原则，即：<code>Composite Reuse Principle</code>，<strong>组合复用原则</strong>。</p><p>组合复用原则的核心思想是：<strong>尽量使用对象组合，而不是继承来达到复用的目的</strong>。该原则就是在一个新的对象里面使用一些已有的对象，使之成为新对象的一部分：新的对象通过向这些对象的委派达到复用已有功能的目的。</p><p>继承的缺点主要有以下几点：</p><ul><li>继承复用破坏数据封装性，将基类的实现细节全部暴露给了派生类，基类的内部细节常常对派生类是透明的，白箱复用。虽然简单，但不安全，不能在程序的运行过程中随便改变。</li><li>基类的实现发生了改变，派生类的实现也不得不改变。</li><li>从基类继承而来的派生类是静态的，不可能在运行时间内发生改变，因此没有足够的灵活性。</li></ul><p>由于组合可以将已有的对象纳入到新对象中，使之成为新对象的一部分，因此新对象可以调用已有对象的功能，这样做有下面的好处：</p><ul><li>新对象存取<code>组成对象</code>的唯一方法是通过<code>组成对象</code>的<code>getter/setter</code>方法。</li><li>组合复用是黑箱复用，因为组成对象的内部细节是新对象所看不见的。</li><li>组合复用所需要的依赖较少。</li><li>每一个新的类可以将焦点集中到一个任务上。</li><li>组合复用可以在运行时间动态进行，新对象可以动态的引用与成分对象类型相同的对象。</li></ul><p>组合复用的缺点：就是用组合复用建造的系统会有较多的对象需要管理。</p><p>组合复用原则可以使系统更加灵活，类与类之间的耦合度降低，一个类的变化对其他类造成的影响相对较少，因此一般首选使用组合来实现复用；其次才考虑继承。在使用继承时，需要严格遵循里氏代换原则，有效使用继承会有助于对问题的理解，降低复杂度，而滥用继承反而会增加系统构建和维护的难度以及系统的复杂度，因此需要慎重使用继承复用。</p><p>使用继承时必须满足<code>Is-A</code>的关系是才能使用继承，而组合却是一种<code>Has-A</code>的关系。导致错误的使用继承而不是使用组合的一个重要原因可能就是错误的把<code>Has-A</code>当成了<code>Is-A</code>。</p><h2 id="三、通用设计原则"><a href="#三、通用设计原则" class="headerlink" title="三、通用设计原则"></a>三、通用设计原则</h2><h3 id="1-保持简单（KISS）"><a href="#1-保持简单（KISS）" class="headerlink" title="1. 保持简单（KISS）"></a>1. 保持简单（KISS）</h3><p>所谓<code>KISS</code>原则，即：<code>Keep It Simple,Stupid</code>，指<strong>设计时要坚持简约原则，避免不必要的复杂化，并且易于修改</strong>。</p><blockquote><p>Everything should be made as simple as possible, but not simpler. - Albert Einstein</p></blockquote><p>简单清晰、功能强大是软件设计最重要的原则和目标。但是软件工程天然错综复杂，而“简单”却没有一个衡量标准，判断和实现一个东西是不是简单，可以通过以下方式来参考。</p><ul><li>让别的软件工程师以一种最容易的方式使用你的方案。</li><li>简单不是走捷径，不是为手边的问题找一个最快的方案。</li><li>当系统变得更庞大更复杂的时候依然能够被理解。</li><li>如果系统无法保持简单，那么我们能做的就是保持各个局部简单，即任何单个的类、模块、应用的设计目标及工作原理都能被快速理解。</li></ul><blockquote><p><strong>我的理解</strong>：保持简单但不能掩盖软件丰富的内涵。即<strong>简约而不简单</strong>！简约是对复杂的事物抽丝剥茧、去除细枝末节显露主要逻辑的过程。就像小时候老师教写文章，要求尽可能用朴实的语言，言简意赅的写出来，但却又要避免语言过于贫乏。软件的“抽象”和它的“直观性”，其实是一对矛盾的关系，软件设计就要保证这两者的平衡。代码抽象过于复杂会陷入“过度设计”不易理解的困境；为了“直观性”缺乏抽象，长此以往又会出现大量的重复、不易于扩展和难维护的困境。</p></blockquote><h3 id="2-不要重复（-DRY）"><a href="#2-不要重复（-DRY）" class="headerlink" title="2. 不要重复（ DRY）"></a>2. 不要重复（ DRY）</h3><p>所谓<code>DRY</code>原则，即：<code>Don&#39;t Repeat Yourself</code>，<strong>不要让自己重复</strong>。</p><p><strong>重复代码是软件程序变烂的万恶之首</strong>。<code>DRY</code>并不是指你不能复制代码，而是你复制的代码不能包含重复的“信息”。复制的东西并不仅仅是复制了代码，而是由于你把同一个信息散播在了代码的各个部分导致了有很多相近的代码也散播在各个地方。代码之所以要写的好，不要重复某些“信息”，因为需求人员总是要改需求，不改代码你就要“死”，改代码你就要加班，所以为了减少修改代码的痛苦，我们不能重复任何信息。举个例子，有一天需求人员说，要把分隔符从分号改成顿号！一下子就要改多个地方了。</p><p>所以，<strong>去掉重复的信息会让你的代码结构发生本质的变化</strong>。</p><p>“重复代码”有很多变体：</p><ul><li>魔法数字、魔法字符串等</li><li>相同代码块</li><li>相似的代码逻辑及操作</li></ul><p>对于消除重复的代码有<strong>事不过三</strong>法则。</p><ul><li>第一次先写了一段代码。</li><li>第二次在另一个地方写了一段相同或相似逻辑的代码，你已经有消除和提取重复代码的冲动了。</li><li>再次在另一个地方写了同样的代码，你已忍无可忍，现在可以考虑抽取和消除重复代码了。</li></ul><blockquote><p><strong>我的理解</strong>：解决重复的最佳的方式是通过培养良好的编码习惯来避免重复，通过重构的手段来消除重复。发现和解决重复并不困难，通过提取抽象、提取方法等措施就能消除重复，但困难的是<strong>立即行动</strong>去解决重复，从而不断的磨砺和提升自己的编程技艺，不断将私人代码变成公共代码，这才是自我提升的过程。解决了重复，经过一段时间，你就会发现，你对整个系统的理解程度在不知不觉中提高了不少。</p></blockquote><h3 id="3-高内聚低耦合"><a href="#3-高内聚低耦合" class="headerlink" title="3. 高内聚低耦合"></a>3. 高内聚低耦合</h3><p>所谓<code>Maximize Cohesion,Minimize Coupling</code>原则，即：<strong>高内聚低耦合</strong>。这是判断设计好坏的标准，主要是看<strong>模块内的内聚性是否高，模块间的耦合度是否低。</strong></p><ul><li><strong>耦合性</strong>：也称块间联系。指软件系统结构中各模块间相互联系紧密程度的一种度量。模块之间联系越紧密，其耦合性就越强，模块的独立性则越差。模块间耦合高低取决于模块间接口的复杂性、调用的方式及传递的信息。耦合是软件结构中各模块之间相互连接的一种度量，耦合强弱取决于模块间接口的复杂程度、进入或访问一个模块的点以及通过接口的数据。</li><li><strong>内聚性</strong>：又称块内联系。指模块的功能强度的度量，即一个模块内部各个元素彼此结合的紧密程度的度量。若一个模块内各元素（语名之间、程序段之间）联系的越紧密，则它的内聚性就越高。内聚是从功能角度来度量模块内的联系，一个好的内聚模块应当恰好做一件事。它描述的是模块内的功能联系。</li></ul><p>内聚和耦合是密切相关的，同其他模块存在高耦合的模块意味着低内聚，而高内聚的模块意味着该模块同其他模块之间是低耦合。在进行软件设计时，应力争做到高内聚，低耦合。</p><p>Java 中实现高内聚低耦合的常用方式：</p><ul><li>少使用类的继承，多用接口隐藏实现的细节。</li><li>模块的功能化分尽可能的单一，道理也很简单，功能单一的模块供其它模块调用的机会就少。</li><li>遵循一个定义只在一个地方出现。</li><li>少使用全局变量。</li><li>类属性和方法的声明少用<code>public</code>，多用<code>private</code>关键字，</li><li>多用设计模式，比如采用<code>MVC</code>的设计模式就可以降低界面与业务逻辑的耦合度。</li><li>尽量不用“硬编码”的方式写程序。</li><li>最后当然就是避免直接操作或调用其它模块或类（内容耦合）。</li></ul><h3 id="4-关注点分离（SOC）"><a href="#4-关注点分离（SOC）" class="headerlink" title="4. 关注点分离（SOC）"></a>4. 关注点分离（SOC）</h3><p>所谓<code>SOC</code>原则，即：<strong>关注点分离</strong>（<code>Separation of Concerns</code>）。<strong>不同领域的功能，应该由不同的代码和最小重迭的模块组成。</strong>关注点分离是处理复杂性的一个原则。由于关注点混杂在一起会导致软件程序复杂性大大增加，所以能够把不同的关注点分离开来，分别处理就是处理复杂性的一个原则，一种方法。关注点分离原则不仅体现在软件程序设计等设计方法中，同时也体现在架构设计、问题求解、软件开发过程、软件项目管理以及软件开发方法学等诸多方面。</p><p><code>MVC</code>就是关注点分离的一个体现，把业务逻辑、数据、界面分离，这也是组织代码结构的一个形式。<code>MVC</code>的基本结构：</p><ul><li><code>Model</code>层表示应用程序的数据核心，通常负责在数据库中存取数据。</li><li><code>View</code>是应用程序的显示层，通常是依据模型的数据而建立。</li><li><code>Controller</code>是用来控制和处理输入输出的，是处理用户交互的部分，也负责向模型（<code>Model</code>层）发送数据。</li></ul><p><code>MVC</code>的这个设计各个关注点是分开的，这样有助于我们管理和开发复杂的应用程序，我们可以在某个时间点只集中精力在其中的某一个关注点，而不是所有的部分。</p><blockquote><p>好的架构必须使每个关注点相互分离，也就是说系统中的一个部分发生了变化，不会影响其他部分。即使需要改变，也能够清晰地识别出那些部分需要改变。如果需要扩展架构，影响将会最小化，已经可以工作的每个部分都将继续工作。——Ivar Jacobson(《AOSD 中文版》)</p></blockquote><h4 id="分离方式"><a href="#分离方式" class="headerlink" title="分离方式"></a>分离方式</h4><p>下面将介绍一些分层的思想和方式:</p><ul><li><strong>纵向分离</strong>: 如常见的三层架构（逻辑控制层、业务处理层和数据持久化层）。</li><li><strong>横向分离</strong>: 如把我们的软件拆分成模块或子系统。从左到右是模块 1、模块 2、模块 3，这是一种水平方向的切割。这跟纵向的分离是两个不同的方向，横向分离大多是模块化的过程。</li><li><strong>切面分离</strong>: 有些内容是多个层之间都需要的，比如日志（<code>log</code>），在你的系统里面，界面层、逻辑层、数据访问层可能都需要写日志，这种跨到多层同样逻辑就可以考虑切面分离。</li><li><strong>依赖方向分离</strong>: 按依赖方向考虑，决定某个类应该放在哪个层次里面，或者考虑将某一层切割成多层。</li><li><strong>关注数据分离</strong>: 在组织数据时，应该尽量考虑数据本身的固有属性，如果不是它们的固有属性，那么应该分离出来。比如产品的类就不应该关联<code>customer</code>类，应该是用订单类来把他们联系在一起。</li><li><strong>关注行为分离</strong>: 行为也应该是事物或对象的固有的本身的行为，明显偏离原来行为的，应该考虑成另外的关注点儿分离开。比如有一个函数叫做<code>CreateNewCustomer()</code>，那么<code>CreateNewCustomer()</code>的行为就应该限定在创建一个新客户上面，给新客户自动发优惠券的动作就不能放到这个函数里面。</li><li><strong>扩展分离</strong>: 如果基于某种设计，原先不具有某些行为需要增加，可以考虑通过扩展或插件的形式来完成，将这些功能放入到插件或扩展中。</li><li><strong>反转分离</strong>: 很多依赖注入的框架，如<code>Spring</code>、<code>Guice</code>等等，这些帮助我们做依赖反转，从而倒置依赖关系。</li></ul><h3 id="5-你不需要它（YAGNI）"><a href="#5-你不需要它（YAGNI）" class="headerlink" title="5. 你不需要它（YAGNI）"></a>5. 你不需要它（YAGNI）</h3><p>所谓<code>YAGNI</code>原则，即：<code>You Ain’t Gonna Need It</code>，<strong>你不需要它</strong>。它是一种极限编程（XP）实践，表示程序员不应为目前还不需要的功能编写代码。<code>YAGNI</code>很像<code>KISS</code>原则，因为它也是致力于构建简单的方案。然而，<code>KISS</code>是通过尽可能容易的完成某件事情来实现精简方案；但<code>YAGNI</code>是通过根本就不实现它来达到精简。<code>YAGNI</code>的观点是你应该<strong>为了眼前的需求做设计而不是未来</strong>。</p><blockquote><p>只在真正需要某些功能的时候才去实现它，而不是仅仅因为你预见到它将出现。- XP 的联合创始人 Ron Jeffries</p></blockquote><p>即使你非常确信将来你需要某个特性，也不要现在就去实现它。在很多情况下，你会发现或许最终你不需要它了，或者是你真正所需的特性与你之前预计的有很大的出入。遵循 YAGNI 实践有两个主要原因：</p><ul><li>你节约了时间，因为你避免了编写最终证明不必要的代码。</li><li>你的代码质量更高了，因为你使代码不必为你的“推测”所污染，而这些“推测”最终可能或多或少有些错误，但此时这些错误已牢牢地依附在你的代码中了。</li></ul><blockquote><p><strong>我的理解</strong>：YAGNI 原则，本质上是告诫我们<strong>写代码不要画蛇添足，否则就会弄巧成拙了</strong>。编写业务代码时，不要去假想一些需求或者场景，因为大多数你所设想的场景都不会发生，而你所多写的那些代码也将会长期滞留在你的系统中，收效甚微，但却让你和团队花费了更多的时间和精力去书写和维护，更可怕的是可能会对将来新的代码维护人造成困惑。另外对于没有被使用到的代码，我认为也都应该立即删除，从而保持系统的精简，如果将来需要时再去书写或恢复，而且那时侯写出的代码也绝对比之前的更为契合。</p></blockquote><h3 id="6-童子军规则（Boy-Scout-Rule）"><a href="#6-童子军规则（Boy-Scout-Rule）" class="headerlink" title="6. 童子军规则（Boy-Scout Rule）"></a>6. 童子军规则（Boy-Scout Rule）</h3><p><code>Boy-Scout Rule</code>，译为：<strong>童子军规则</strong>。美国童子军有一个简单的规则：“让营地比你刚来时更干净(<code>Always leave the campground cleaner than you found it</code>)”。如果看到地上有垃圾，不管是谁扔的，都要清理。这样你就有意地为下一批来宿营的人改善了环境。</p><p>童子军规则告诉我们在对现有代码库进行更改时，代码质量往往会降低，从而积累技术债务。所以需要<strong>始终保持代码整洁</strong>。不管原作者是谁，如果我们努力去改进代码模块，不管是多么小的改进，我们的软件系统就再也不会持续变坏了。取而代之的是，系统在发展的同时会逐渐变得更好。我们也会看到团队们关心整体的系统，而不是各自只关心自己负责的一小部分。而且团队成员要互助，互相清理代码，他们遵从童子军规则，因为那对每个人都很好，而不仅仅是对自己好。</p><p>代码坏味道或者糟糕的程序代码就像隐形的“疾病”一样潜伏在项目中，也因此形成了技术债务。如果这些“疾病”在项目初期不引起注关注、不把疾病扼杀在萌芽之中，那么后期修复它的代价也就越大，也必然会使得项目的软件程序越来越难以维护，这个项目也最终会像蔡桓公一样无药可治、“无奈何也”。</p><blockquote><p>所以，请记住童子军规则对我们的启示：<strong>始终保持代码整洁，勿以善小而不为，勿以恶小而为之，有病早治</strong>。</p></blockquote><h3 id="7-其他原则"><a href="#7-其他原则" class="headerlink" title="7.其他原则"></a>7.其他原则</h3><ul><li><strong>避免过早优化</strong>（<code>Avoid Premature Optimization</code>）: 除非你的代码运行的比你想像中的要慢，否则别去优化。假如你真的想优化，就必须先想好如何用数据证明，它的速度变快了。“<strong>过早的优化是一切罪恶之源</strong>。”——Donald Knuth</li><li><strong>最小惊讶原则</strong>(<code>Principle of least astonishment</code>): 代码应该尽可能减少让读者惊喜。也就是说，你编写的代码只需按照项目的要求来编写。其他华丽的功能就不必了，以免弄巧成拙。</li><li><strong>代码重用原则</strong>（<code>Code Reuse is Good</code>）: 重用代码能提高代码的可读性，缩短开发时间。</li><li><strong>别让我思考</strong>(<code>Don’t Make Me Think</code>): 所编写的代码一定要易于读易于理解，这样别人才会欣赏，也能够给你提出合理化的建议。相反，若是繁杂难解的程序，其他人总是会避而远之的。</li><li><strong>为维护者写代码</strong>(<code>Write Code for the Maintainer</code>): 优秀的代码，应当使本人或是他人在将来都能够对它继续编写或维护。代码维护时，或许本人会比较容易，但对他人却比较麻烦。因此你写的代码要尽可能保证他人能够容易维护。“如果一个维护者不再继续维护你的代码，很可能他就有了想杀你的冲动。”</li><li><strong>正交原则(Orthogonality)</strong>: 正交性的基本思想是，在概念上不相关的事物不应该与系统相关。设计越正交，异常越少。 这使得用编程语言更容易学习，读写程序。(反例：<code>CSS</code>)。</li><li><strong>做最简单的事儿就让代码可运行</strong>（<code>Do the simplest thing that could possibly work</code>）: 尽可能做最简单的事就可以让代码可运行。在编程中，一定要保持简单原则。作为一名程序员不断的反思“如何在工作中做到简化呢？”这将有助于在设计中保持简单的路径。</li><li><strong>隐藏实现细节</strong>（<code>Hide Implementation Details</code>）: 软件模块通过提供接口隐藏信息（即实现细节），而不泄漏任何不必要的信息。</li><li><strong>科里定律</strong>(<code>Curly&#39;s Law</code>): 是为任何特定的代码选择一个明确定义的目标：<strong>只做一件事</strong>。</li><li><strong>墨菲定律</strong>（<code>Murphy&#39;s Law</code>）:根本内容是：<strong>如果事情有变坏的可能，不管这种可能性有多小，它总会发生</strong>。主要内容如下：<ul><li>任何事都没有表面看起来那么简单；</li><li>所有的事都会比你预计的时间长；</li><li>会出错的事总会出错；</li><li>如果你担心某种情况发生，那么它就更有可能发生。</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 软件设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计原则与模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>责任链模式（Chain of Responsibility Pattern）</title>
      <link href="/2018/110429724.html"/>
      <url>/2018/110429724.html</url>
      
        <content type="html"><![CDATA[<h2 id="模式动机"><a href="#模式动机" class="headerlink" title="模式动机"></a>模式动机</h2><p>很多情况下，在一个软件系统中可以处理某个请求的对象不止一个。例如审批工作流等，他们可以构成一条处理采购单的链式结构，采购单(可以看作是要处理的信息)沿着这条链进行传递，这条链就称为责任链。责任链可以是一条直线、一个环或者一个树形结构，最常见的职责链是直线型，即沿着一条单向的链来传递请求。链上的每一个对象都是请求处理者，责任链模式可以将请求的处理者组织成一条链，并让请求沿着链传递，由链上的处理者对请求进行相应的处理。在此过程中，客户端实际上无须关心请求的处理细节以及请求的传递，只需将请求发送到链上即可，从而实现请求发送者和请求处理者解耦。</p><h2 id="模式定义"><a href="#模式定义" class="headerlink" title="模式定义"></a>模式定义</h2><blockquote><p><strong>定义</strong>：责任链模式(<code>Chain of Responsibility Pattern</code>)是使多个对象都有机会处理请求，从而避免请求的发送者与请求处理者耦合在一起。将这些对象连接成一条链，并且沿着这条链传递请求，直到有对象处理它为止。它是一种对象行为型模式。</p></blockquote><p><strong>实质</strong>：责任链上的处理者负责处理请求，客户只需要将请求发送到职责链上即可，无须关心请求的处理细节和请求的传递，从而实现请求发送者与请求处理者的解耦。</p><h2 id="模式结构"><a href="#模式结构" class="headerlink" title="模式结构"></a>模式结构</h2><h3 id="参与角色"><a href="#参与角色" class="headerlink" title="参与角色"></a>参与角色</h3><ul><li><code>Handler</code>（抽象处理者）：处理请求的接口，一般设计为具有抽象请求处理方法的抽象类，以便于不同的具体处理者进行继承，从而实现具体的请求处理方法。此外，由于每一个请求处理者的下家还是一个处理者，因此抽象处理者本身还包含了一个本身的引用(<code>nextHandler</code>)作为其对下家的引用，以便将处理者链成一条链；</li><li><code>ConcreteHandler</code>（具体处理者）：抽象处理者的子类，可以处理用户请求，其实现了抽象处理者中定义的请求处理方法。在具体处理请求时需要进行判断，若其具有相应的处理权限，那么就处理它；否则，其将请求转发给后继者，以便让后面的处理者进行处理。</li></ul><p>在责任链模式里，由每一个请求处理者对象对其下家的引用而连接起来形成一条请求处理链。请求将在这条链上一直传递，直到链上的某一个请求处理者能够处理此请求。<strong>发出这个请求的客户端并不知道链上的哪一个请求处理者将处理这个请求，这使得系统可以在不影响客户端的情况下动态地重新组织链和分配责任</strong>。</p><h3 id="UML类图"><a href="#UML类图" class="headerlink" title="UML类图"></a>UML类图</h3><p><img src="https://pic.lixl.cn/2019/chain_of_responsibility.png" alt="责任链模式UML类图"></p><h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h2><p>首先，责任链模式的核心在于对请求处理者的抽象。在实现过程中，抽象处理者一般会被设定为<strong>抽象类</strong>，其典型实现代码如下所示：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 责任连模式的抽象处理者角色. */</span><span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">Handler</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/** 后继处理者角色. */</span>    <span class="token keyword">protected</span> Handler nextHandler<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * 处理请求的抽象方法.     *     * @param condition 条件     */</span>    <span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">void</span> <span class="token function">handle</span><span class="token punctuation">(</span>String condition<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * nextHandler的Setter方法.     *     * @param nextHandler 后继处理器     */</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setNextHandler</span><span class="token punctuation">(</span>Handler nextHandler<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>nextHandler <span class="token operator">=</span> nextHandler<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其次，是若干个具体的处理角色类。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 具体处理角色1. */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConcreteHandler1</span> <span class="token keyword">extends</span> <span class="token class-name">Handler</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 具体处理角色1的处理方法.     *     * @param condition 条件     */</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">handle</span><span class="token punctuation">(</span>String condition<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 如果是自己的责任，就自己处理，负责传给下家处理</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token string">"ConcreteHandler1"</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>condition<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span> <span class="token string">"具体处理角色1的处理方法handled1..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span> <span class="token string">"具体处理角色1 通过..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            nextHandler<span class="token punctuation">.</span><span class="token function">handle</span><span class="token punctuation">(</span>condition<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 具体处理角色2. */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConcreteHandler2</span> <span class="token keyword">extends</span> <span class="token class-name">Handler</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 具体处理角色2的处理方法.     *     * @param condition 条件     */</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">handle</span><span class="token punctuation">(</span>String condition<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 如果是自己的责任，就自己处理，负责传给下家处理</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token string">"ConcreteHandler2"</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>condition<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span> <span class="token string">"具体处理角色2的处理方法handled1..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span> <span class="token string">"具体处理角色2 通过..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            nextHandler<span class="token punctuation">.</span><span class="token function">handle</span><span class="token punctuation">(</span>condition<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 具体处理角色n. */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConcreteHandlerN</span> <span class="token keyword">extends</span> <span class="token class-name">Handler</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 这里假设n是链的最后一个节点必须处理掉.     * 在实际情况下，可能出现环，或者是树形，这里并不一定是最后一个节点.     *     * @param condition 参数条件     */</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">handle</span><span class="token punctuation">(</span>String condition<span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span> <span class="token string">"具体处理角色n的处理方法 结束..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>最后，是客户端场景类，代码调用示例如下：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 责任连模式的客户端场景类. */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ChainClient</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 主入口方法.     *     * @param args 数组参数     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Handler handler1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcreteHandler1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Handler handler2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcreteHandler2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Handler handlern <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcreteHandlerN</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        handler1<span class="token punctuation">.</span><span class="token function">setNextHandler</span><span class="token punctuation">(</span>handler2<span class="token punctuation">)</span><span class="token punctuation">;</span>        handler2<span class="token punctuation">.</span><span class="token function">setNextHandler</span><span class="token punctuation">(</span>handlern<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//假设这个请求是ConcreteHandler2的责任</span>        handler1<span class="token punctuation">.</span><span class="token function">handle</span><span class="token punctuation">(</span><span class="token string">"ConcreteHandler2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><strong>注</strong>：责任链模式并不创建职责链，职责链的创建工作必须由系统的其他部分来完成，一般由使用该责任链的客户端创建。职责链模式降低了请求的发送者和请求处理者之间的耦合，从而使得多个请求处理者都有机会处理这个请求。</p></blockquote><h2 id="模式分析"><a href="#模式分析" class="headerlink" title="模式分析"></a>模式分析</h2><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p>在实际软件开发中，如果遇到有多个对象可以处理同一请求时可以考虑使用职责链模式，最常见的例子包括在 Java Web 应用开发中创建一个过滤器（Filter）链来对请求数据进行过滤（中文字符乱码的处理）、在工作流系统中实现公文的分级审批、在Struts应用中添加不同的拦截器(常用的有类型转化、异常处理，数据校验…)以增强Struts2的功能等。</p><h3 id="纯与不纯的责任链模式"><a href="#纯与不纯的责任链模式" class="headerlink" title="纯与不纯的责任链模式"></a>纯与不纯的责任链模式</h3><ul><li><strong>纯的责任链模式</strong>要求一个具体的处理者对象只能在两个行为中选择一个：一是承担责任，而是把责任推给下家。不允许出现某一个具体处理者对象在承担了一部分责任后又把责任向下传的情况；</li><li>在纯责任链模式里面，一个请求必须被某一个处理者对象所接收；</li><li>在不纯的责任链模式里面，一个请求可以最终不被任何接收端对象所接收。</li></ul><p>纯的责任链模式的实际例子很难找到，一般看到的例子均是不纯的责任链模式的实现。</p><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul><li>降低耦合度，使请求的发送者和接收者解耦，便于灵活的、可插拔的定义请求处理过程；</li><li>简化、封装了请求的处理过程，并且这个过程对客户端而言是透明的，以便于动态地重新组织链以及分配责任，增强请求处理的灵活性；</li><li>可以从职责链任何一个节点开始，也可以随时改变内部的请求处理规则，每个请求处理者都可以去动态地指定他的继任者；</li><li>职责链可简化对象间的相互连接。它们仅需保持一个指向其后继者的引用，而不需保持它所有的候选接受者的引用；</li><li>增加新的请求处理类很方便。</li></ul><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul><li>不能保证请求一定被接收。既然一个请求没有明确的接收者，那么就不能保证它一定会被处理；</li><li>该请求可能一直到链的末端都得不到处理。一个请求也可能因该链没有被正确配置而得不到处理；</li><li>系统性能将受到一定影响，而且在进行代码调试时不太方便；可能会造成循环调用。</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>在职责链模式里，很多对象由每一个对象对其下家的引用而连接起来形成一条链。请求在这个链上传递，直到链上的某一个对象决定处理此请求。发出这个请求的客户端并不知道链上的哪一个对象最终处理这个请求，这使得系统可以在不影响客户端的情况下动态地重新组织链和分配责任。</li><li>职责链模式的主要优点在于可以降低系统的耦合度，简化对象的相互连接，同时增强给对象指派职责的灵活性，增加新的请求处理类也很方便；其主要缺点在于不能保证请求一定被接收，且对于比较长的职责链，请求的处理可能涉及到多个处理对象，系统性能将受到一定影响，而且在进行代码调试时不太方便。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 软件设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 设计原则与模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单例模式（Singleton Pattern）</title>
      <link href="/2018/102929438.html"/>
      <url>/2018/102929438.html</url>
      
        <content type="html"><![CDATA[<h2 id="模式动机"><a href="#模式动机" class="headerlink" title="模式动机"></a>模式动机</h2><p>对于系统中的某些类来说，只有一个实例很重要，例如，一个系统中可以存在多个打印任务，但是只能有一个正在工作的任务；一个系统只能有一个窗口管理器或文件系统；一个系统只能有一个计时工具或 ID（序号）生成器。</p><p>如何保证一个类只有一个实例并且这个实例易于被访问呢？定义一个全局变量可以确保对象随时都可以被访问，但不能防止我们实例化多个对象。</p><p>一个更好的解决办法是让类自身负责保存它的唯一实例。这个类可以保证没有其他实例被创建，并且它可以提供一个访问该实例的方法。这就是单例模式的模式动机。</p><h2 id="模式定义"><a href="#模式定义" class="headerlink" title="模式定义"></a>模式定义</h2><blockquote><p><strong>单例模式(<code>Singleton Pattern</code>)</strong>：单例模式确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例，这个类称为单例类，它提供全局访问的方法。单例模式是一种 <strong>对象创建型模式</strong>。单例模式又名单件模式或单态模式。</p></blockquote><p>单例模式的要点有三个：</p><ul><li>一是某个类只能有一个实例；</li><li>二是它必须自行创建这个实例；</li><li>三是它必须自行向整个系统提供这个实例。</li></ul><h2 id="模式结构"><a href="#模式结构" class="headerlink" title="模式结构"></a>模式结构</h2><h3 id="参与角色"><a href="#参与角色" class="headerlink" title="参与角色"></a>参与角色</h3><ul><li><code>Singleton</code>: 单例</li></ul><h3 id="UML-类图"><a href="#UML-类图" class="headerlink" title="UML 类图"></a>UML 类图</h3><p><img src="https://pic.lixl.cn/2019/Java_design_singleton_uml.jpg" alt="单例模式UML类图"></p><h3 id="时序图"><a href="#时序图" class="headerlink" title="时序图"></a>时序图</h3><p><img src="https://pic.lixl.cn/2019/Java_design_singleton_seq.jpg" alt="单例模式时序图"></p><h2 id="代码实现方式"><a href="#代码实现方式" class="headerlink" title="代码实现方式"></a>代码实现方式</h2><h3 id="1-饿汉式（推荐使用）"><a href="#1-饿汉式（推荐使用）" class="headerlink" title="1. 饿汉式（推荐使用）"></a>1. 饿汉式（推荐使用）</h3><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 饿汉式单例模式. */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Singleton</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/** 全局唯一实例. */</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> Singleton singleton <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token function">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> Singleton <span class="token function">getSingleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> singleton<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><strong>注</strong>：这种方式避免了多线程的同步问题，但不是懒加载。如果不需要懒加载的方式，推荐使用。</p></blockquote><h3 id="2-非线程安全懒汉式（不推荐使用）"><a href="#2-非线程安全懒汉式（不推荐使用）" class="headerlink" title="2. 非线程安全懒汉式（不推荐使用）"></a>2. 非线程安全懒汉式（不推荐使用）</h3><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 非线程安全的懒汉式. */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Singleton</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> Singleton singleton<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token function">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 通过懒加载的方式获取实例，但是非线程安全.     * @return Singleton实例     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> Singleton <span class="token function">getSingleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>singleton <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            singleton <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> singleton<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><strong>注</strong>：是懒加载的方式，但非线程安全。不推荐使用。</p></blockquote><h3 id="3-低效的线程安全懒汉式（不推荐使用）"><a href="#3-低效的线程安全懒汉式（不推荐使用）" class="headerlink" title="3. 低效的线程安全懒汉式（不推荐使用）"></a>3. 低效的线程安全懒汉式（不推荐使用）</h3><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 低效的线程安全的懒汉式. */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Singleton</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> Singleton singleton<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token function">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 通过 synchronized 关键字来保证线程安全，也是懒加载的方式来获取实例.     * @return Singleton实例     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">synchronized</span> Singleton <span class="token function">getSingleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>singleton <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            singleton <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> singleton<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><strong>注</strong>：是懒加载的方式，也线程安全，但是效率很低。因为 99%的情况下是不需要去同步的。不推荐使用。</p></blockquote><h3 id="4-双重校验锁线程安全懒汉式（不推荐使用）"><a href="#4-双重校验锁线程安全懒汉式（不推荐使用）" class="headerlink" title="4. 双重校验锁线程安全懒汉式（不推荐使用）"></a>4. 双重校验锁线程安全懒汉式（不推荐使用）</h3><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 双重校验锁线程安全懒汉式. */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Singleton</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> Singleton singleton<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token function">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 通过'双重校验锁'来更高效的保证线程安全，也是懒加载的方式来获取实例.     * @return Singleton实例     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> Singleton <span class="token function">getSingleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>singleton <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>Singleton<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>singleton <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    singleton <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> singleton<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><strong>注</strong>：是懒加载的方式，也线程安全，效率也不错。但受限于 Jdk5 以前的 Java 内存模型，仍然会有 bug，Java5 及之后才能正常达到单例效果。</p></blockquote><h3 id="5-枚举式（强烈推荐使用）"><a href="#5-枚举式（强烈推荐使用）" class="headerlink" title="5. 枚举式（强烈推荐使用）"></a>5. 枚举式（强烈推荐使用）</h3><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 枚举方式的单例. */</span><span class="token keyword">public</span> <span class="token keyword">enum</span> Singleton <span class="token punctuation">{</span>    INSTANCE<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><strong>注</strong>：在<code>《Effective Java》</code>一书中强烈推荐使用枚举来实现单例模式，该方式简单可自由序列化；保证只有一个实例（即使使用反射机制也无法多次实例化一个枚举量）；线程安全。唯一的缺点是非懒加载方式。</p></blockquote><h3 id="6-静态内部类（推荐使用）"><a href="#6-静态内部类（推荐使用）" class="headerlink" title="6. 静态内部类（推荐使用）"></a>6. 静态内部类（推荐使用）</h3><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 通过使用静态内部类的方式来实现懒加载且线程安全的创建单例. */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Singleton</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token function">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 静态内部类.     */</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">SingletonHolder</span> <span class="token punctuation">{</span>        <span class="token keyword">private</span> <span class="token function">SingletonHolder</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>        <span class="token keyword">private</span> <span class="token keyword">static</span> Singleton4 instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 通过懒加载的方式获取Singleton唯一实例的方法.     * @return Singleton实例     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> Singleton <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> SingletonHolder<span class="token punctuation">.</span>instance<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><strong>注</strong>：这种方式利用了<code>ClassLoader</code>的机制保证初始化<code>instance</code>时只有一个线程，其只有显示通过调用<code>getInstance</code>方法时，才会显示装载<code>SingletonHolder</code>类，从而实例化<code>instance</code>。</p></blockquote><h2 id="模式分析"><a href="#模式分析" class="headerlink" title="模式分析"></a>模式分析</h2><p>单例模式的目的是保证一个类仅有一个实例，并提供一个访问它的全局访问点。单例模式包含的角色只有一个，就是单例类——<code>Singleton</code>。</p><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul><li>提供了对唯一实例的受控访问。因为单例类封装了它的唯一实例，所以它可以严格控制客户怎样以及何时访问它，并为设计及开发团队提供了共享的概念。</li><li>由于在系统内存中只存在一个对象，因此可以节约系统资源，对于一些需要频繁创建和销毁的对象，单例模式无疑可以提高系统的性能。</li><li>允许可变数目的实例。我们可以基于单例模式进行扩展，使用与单例控制相似的方法来获得指定个数的对象实例。</li></ul><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul><li>由于单例模式中没有抽象层，因此单例类的扩展有很大的困难。</li><li>单例类的职责过重，在一定程度上违背了“单一职责原则”。因为单例类既充当了工厂角色，提供了工厂方法，同时又充当了产品角色，包含一些业务方法，将产品的创建和产品的本身的功能融合到一起。</li><li>滥用单例将带来一些负面问题，如为了节省资源将数据库连接池对象设计为单例类，可能会导致共享连接池对象的程序过多而出现连接池溢出；现在很多面向对象语言(如<code>Java</code>、<code>C#</code>)的运行环境都提供了自动垃圾回收的技术，因此，如果实例化的对象长时间不被利用，系统会认为它是垃圾，会自动销毁并回收资源，下次利用时又将重新实例化，这将导致对象状态的丢失。</li></ul><h3 id="适用环境"><a href="#适用环境" class="headerlink" title="适用环境"></a>适用环境</h3><p>在以下情况下可以使用单例模式：</p><ul><li>系统只需要一个实例对象，如系统要求提供一个唯一的序列号生成器，或者需要考虑资源消耗太大而只允许创建一个对象。</li><li>客户调用类的单个实例只允许使用一个公共访问点，除了该公共访问点，不能通过其他途径访问该实例。</li><li>在一个系统中要求一个类只有一个实例时才应当使用单例模式。反过来，如果一个类可以有几个实例共存，就需要对单例模式进行改进，使之成为多例模式。</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>单例模式确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例，这个类称为单例类，它提供全局访问的方法。单例模式的要点有三个：一是某个类只能有一个实例；二是它必须自行创建这个实例；三是它必须自行向整个系统提供这个实例。单例模式是一种对象创建型模式。</li><li>单例模式只包含一个单例角色：在单例类的内部实现只生成一个实例，同时它提供一个静态的工厂方法，让客户可以使用它的唯一实例；为了防止在外部对其实例化，将其构造函数设计为私有。</li><li>实现单例模式，如果不需要懒加载的效果，则推荐使用枚举和饿汉式的方式；如果需要懒加载的效果，则推荐使用静态内部类来实现更好。</li><li>单例模式的主要优点在于提供了对唯一实例的受控访问并可以节约系统资源；其主要缺点在于因为缺少抽象层而难以扩展，且单例类职责过重。</li><li>单例模式适用情况包括：系统只需要一个实例对象；客户调用类的单个实例只允许使用一个公共访问点。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 软件设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 设计原则与模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>建造者模式（Builder Pattern）</title>
      <link href="/2018/102060028.html"/>
      <url>/2018/102060028.html</url>
      
        <content type="html"><![CDATA[<h2 id="一、模式动机"><a href="#一、模式动机" class="headerlink" title="一、模式动机"></a>一、模式动机</h2><p>无论是在现实世界中还是在软件系统中，都存在一些复杂的对象，它们拥有多个组成部分，如汽车，它包括车轮、方向盘、发动机等各种部件。而对于大多数用户而言，无须知道这些部件的装配细节，也几乎不会使用单独某个部件，而是使用一辆完整的汽车，可以通过建造者模式对其进行设计与描述，建造者模式可以将部件和其组装过程分开，一步一步创建一个复杂的对象。用户只需要指定复杂对象的类型就可以得到该对象，而无须知道其内部的具体构造细节。</p><p>在软件开发中，也存在大量类似汽车一样的复杂对象，它们拥有一系列成员属性，这些成员属性中有些是引用类型的成员对象。而且在这些复杂对象中，还可能存在一些限制条件，如某些属性没有赋值则复杂对象不能作为一个完整的产品使用；有些属性的赋值必须按照某个顺序，一个属性没有赋值之前，另一个属性可能无法赋值等。</p><p>复杂对象相当于一辆有待建造的汽车，而对象的属性相当于汽车的部件，建造产品的过程就相当于组合部件的过程。由于组合部件的过程很复杂，因此，这些部件的组合过程往往被“外部化”到一个称作建造者的对象里，建造者返还给客户端的是一个已经建造完毕的完整产品对象，而用户无须关心该对象所包含的属性以及它们的组装方式，这就是建造者模式的模式动机。</p><h2 id="二、模式定义"><a href="#二、模式定义" class="headerlink" title="二、模式定义"></a>二、模式定义</h2><blockquote><p>造者模式(<code>Builder Pattern</code>)：将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。建造者模式属于<strong>对象创建型模式</strong>。建造者模式又可以称为<strong>生成器模式</strong>。</p></blockquote><p>建造者模式是一步一步创建一个复杂的对象，它允许用户只通过指定复杂对象的类型和内容就可以构建它们，用户不需要知道内部的具体构建细节。</p><h2 id="三、模式结构"><a href="#三、模式结构" class="headerlink" title="三、模式结构"></a>三、模式结构</h2><h3 id="1-角色组成"><a href="#1-角色组成" class="headerlink" title="1. 角色组成"></a>1. 角色组成</h3><p>建造者模式包含如下角色：</p><ul><li><code>Builder</code>：抽象建造者</li><li><code>ConcreteBuilder</code>：具体建造者</li><li><code>Director</code>：导演者</li><li><code>Product</code>：产品角色</li></ul><h3 id="2-结构图"><a href="#2-结构图" class="headerlink" title="2. 结构图"></a>2. 结构图</h3><p><img src="https://pic.lixl.cn/2019/Builder.jpg" alt="建造者模式结构图"></p><h2 id="四、示例代码"><a href="#四、示例代码" class="headerlink" title="四、示例代码"></a>四、示例代码</h2><p>首先，是产品类：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 产品类. */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Product</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> String part1<span class="token punctuation">;</span>    <span class="token keyword">private</span> String part2<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* getter 和 setter方法. */</span>    <span class="token keyword">public</span> String <span class="token function">getPart1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> part1<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setPart1</span><span class="token punctuation">(</span>String part1<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>part1 <span class="token operator">=</span> part1<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> String <span class="token function">getPart2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> part2<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setPart2</span><span class="token punctuation">(</span>String part2<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>part2 <span class="token operator">=</span> part2<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其实，是抽象的建造者<code>Builder</code>接口和具体的建造者<code>ConcreteBuilder</code>类：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 抽象的建造者. */</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Builder</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 产品建造部分1.     */</span>    <span class="token keyword">void</span> <span class="token function">buildPart1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * 产品建造部分2.     */</span>    <span class="token keyword">void</span> <span class="token function">buildPart2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * 得到建造的产品.     *     * @return 产品     */</span>    Product <span class="token function">getResult</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 具体的建造者实现类. */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConcreteBuilder</span> <span class="token keyword">implements</span> <span class="token class-name">Builder</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/** 产品. */</span>    <span class="token keyword">private</span> Product product <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Product</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * 产品建造部分1.     */</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">buildPart1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        product<span class="token punctuation">.</span><span class="token function">setPart1</span><span class="token punctuation">(</span><span class="token string">"编号：95757"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 产品建造部分2.     */</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">buildPart2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        product<span class="token punctuation">.</span><span class="token function">setPart2</span><span class="token punctuation">(</span><span class="token string">"名称：小机器人"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 得到建造的产品.     *     * @return 产品     */</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> Product <span class="token function">getResult</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> product<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>最后，导演者<code>Director</code>类：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 导演者类. */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Director</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/** 当前需要的建造者对象. */</span>    <span class="token keyword">private</span> Builder builder<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * 构造方法.     *     * @param builder     */</span>    <span class="token keyword">public</span> <span class="token function">Director</span><span class="token punctuation">(</span>Builder builder<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>builder <span class="token operator">=</span> builder<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 产品构造方法，负责调用各个零件建造方法.     */</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">construct</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        builder<span class="token punctuation">.</span><span class="token function">buildPart1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        builder<span class="token punctuation">.</span><span class="token function">buildPart2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>以下是建造者模式的客户端场景类：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 建造者模式的客户端场景类. */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">BuilderClient</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 主入口方法.     *     * @param args 数组参数     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Builder builder <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcreteBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Director director <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Director</span><span class="token punctuation">(</span>builder<span class="token punctuation">)</span><span class="token punctuation">;</span>        director<span class="token punctuation">.</span><span class="token function">construct</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Product product <span class="token operator">=</span> builder<span class="token punctuation">.</span><span class="token function">getResult</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>product<span class="token punctuation">.</span><span class="token function">getPart1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>product<span class="token punctuation">.</span><span class="token function">getPart2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="五、模式分析"><a href="#五、模式分析" class="headerlink" title="五、模式分析"></a>五、模式分析</h2><p>抽象建造者类中定义了产品的创建方法和返回方法;</p><p>建造者模式的结构中还引入了一个导演者类<code>Director</code>，该类的作用主要有两个：一方面它隔离了客户与生产过程；另一方面它负责控制产品的生成过程。导演者针对抽象建造者编程，客户端只需要知道具体建造者的类型，即可通过导演者类调用建造者的相关方法，返回一个完整的产品对象</p><p>在客户端代码中，无须关心产品对象的具体组装过程，只需确定具体建造者的类型即可，建造者模式将复杂对象的构建与对象的表现分离开来，这样使得同样的构建过程可以创建出不同的表现。</p><h3 id="1-优点"><a href="#1-优点" class="headerlink" title="1. 优点"></a>1. 优点</h3><p>建造者模式的优点：</p><ul><li>在建造者模式中， 客户端不必知道产品内部组成的细节，将产品本身与产品的创建过程解耦，使得相同的创建过程可以创建不同的产品对象。</li><li>每一个具体建造者都相对独立，而与其他的具体建造者无关，因此可以很方便地替换具体建造者或增加新的具体建造者， 用户使用不同的具体建造者即可得到不同的产品对象 。</li><li>可以更加精细地控制产品的创建过程 。将复杂产品的创建步骤分解在不同的方法中，使得创建过程更加清晰，也更方便使用程序来控制创建过程。</li><li>增加新的具体建造者无须修改原有类库的代码，指挥者类针对抽象建造者类编程，系统扩展方便，符合“开闭原则”。</li></ul><h3 id="2-缺点"><a href="#2-缺点" class="headerlink" title="2. 缺点"></a>2. 缺点</h3><p>建造者模式的缺点：</p><ul><li>建造者模式所创建的产品一般具有较多的共同点，其组成部分相似，如果产品之间的差异性很大，则不适合使用建造者模式，因此其使用范围受到一定的限制。</li><li>如果产品的内部变化复杂，可能会导致需要定义很多具体建造者类来实现这种变化，导致系统变得很庞大。</li></ul><h3 id="3-适用环境"><a href="#3-适用环境" class="headerlink" title="3. 适用环境"></a>3. 适用环境</h3><p>在以下情况下可以使用建造者模式：</p><ul><li>需要生成的产品对象有复杂的内部结构，这些产品对象通常包含多个成员属性。</li><li>需要生成的产品对象的属性相互依赖，需要指定其生成顺序。</li><li>对象的创建过程独立于创建该对象的类。在建造者模式中引入了指挥者类，将创建过程封装在指挥者类中，而不在建造者类中。</li><li>隔离复杂对象的创建和使用，并使得相同的创建过程可以创建不同的产品。</li></ul><h3 id="4-建造者模式与抽象工厂模式的比较"><a href="#4-建造者模式与抽象工厂模式的比较" class="headerlink" title="4. 建造者模式与抽象工厂模式的比较"></a>4. 建造者模式与抽象工厂模式的比较</h3><ul><li>与抽象工厂模式相比，建造者模式返回一个组装好的完整产品，而抽象工厂模式返回一系列相关的产品，这些产品位于不同的产品等级结构，构成了一个产品族。</li><li>在抽象工厂模式中，客户端实例化工厂类，然后调用工厂方法获取所需产品对象，而在建造者模式中，客户端可以不直接调用建造者的相关方法，而是通过指挥者类来指导如何生成对象，包括对象的组装过程和建造步骤，它侧重于一步步构造一个复杂对象，返回一个完整的对象。</li><li>如果将抽象工厂模式看成汽车配件生产工厂，生产一个产品族的产品，那么建造者模式就是一个汽车组装工厂，通过对部件的组装可以返回一辆完整的汽车。</li></ul><h2 id="六、模式总结"><a href="#六、模式总结" class="headerlink" title="六、模式总结"></a>六、模式总结</h2><ul><li>建造者模式将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。建造者模式是一步一步创建一个复杂的对象，它允许用户只通过指定复杂对象的类型和内容就可以构建它们，用户不需要知道内部的具体构建细节。建造者模式属于对象创建型模式。</li><li>建造者模式包含如下四个角色：抽象建造者为创建一个产品对象的各个部件指定抽象接口；具体建造者实现了抽象建造者接口，实现各个部件的构造和装配方法，定义并明确它所创建的复杂对象，也可以提供一个方法返回创建好的复杂产品对象；产品角色是被构建的复杂对象，包含多个组成部件；指挥者负责安排复杂对象的建造次序，指挥者与抽象建造者之间存在关联关系，可以在其<code>construct()</code>建造方法中调用建造者对象的部件构造与装配方法，完成复杂对象的建造</li><li>在建造者模式的结构中引入了一个导演者类，该类的作用主要有两个：一方面它隔离了客户与生产过程；另一方面它负责控制产品的生成过程。指挥者针对抽象建造者编程，客户端只需要知道具体建造者的类型，即可通过指挥者类调用建造者的相关方法，返回一个完整的产品对象。</li><li>建造者模式的主要优点在于客户端不必知道产品内部组成的细节，将产品本身与产品的创建过程解耦，使得相同的创建过程可以创建不同的产品对象，每一个具体建造者都相对独立，而与其他的具体建造者无关，因此可以很方便地替换具体建造者或增加新的具体建造者，符合“开闭原则”，还可以更加精细地控制产品的创建过程；其主要缺点在于由于建造者模式所创建的产品一般具有较多的共同点，其组成部分相似，因此其使用范围受到一定的限制，如果产品的内部变化复杂，可能会导致需要定义很多具体建造者类来实现这种变化，导致系统变得很庞大。</li><li>建造者模式适用情况包括：需要生成的产品对象有复杂的内部结构，这些产品对象通常包含多个成员属性；需要生成的产品对象的属性相互依赖，需要指定其生成顺序；对象的创建过程独立于创建该对象的类；隔离复杂对象的创建和使用，并使得相同的创建过程可以创建不同类型的产品。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 软件设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 设计原则与模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>外观模式（Facade Pattern）</title>
      <link href="/2018/101818310.html"/>
      <url>/2018/101818310.html</url>
      
        <content type="html"><![CDATA[<h2 id="一、模式定义"><a href="#一、模式定义" class="headerlink" title="一、模式定义"></a>一、模式定义</h2><blockquote><p><strong>外观模式</strong>(<code>Facade Pattern</code>)：外部与一个子系统的通信必须通过一个统一的外观对象进行，为子系统中的一组接口提供一个一致的界面，外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。外观模式又称为<strong>门面模式</strong>，它是一种对象结构型模式。</p></blockquote><h2 id="二、模式结构"><a href="#二、模式结构" class="headerlink" title="二、模式结构"></a>二、模式结构</h2><h3 id="1-角色组成"><a href="#1-角色组成" class="headerlink" title="1. 角色组成"></a>1. 角色组成</h3><p>外观模式包含如下角色：</p><ul><li><code>Facade</code>: 外观角色</li><li><code>SubSystem</code>: 子系统角色</li></ul><h3 id="2-结构图"><a href="#2-结构图" class="headerlink" title="2. 结构图"></a>2. 结构图</h3><p><img src="https://pic.lixl.cn/2019/Facade.jpg" alt="命令模式结构图"></p><h2 id="三、示例代码"><a href="#三、示例代码" class="headerlink" title="三、示例代码"></a>三、示例代码</h2><p>首先，是各个子系统角色类，分别如下：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 子系统类A. */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ClassA</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">doSomethingA</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"----业务方法A..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 子系统类B. */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ClassB</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">doSomethingB</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"----业务方法B..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 子系统类C. */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ClassC</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">doSomethingC</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"----业务方法C..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>以下是外观模式的外观类：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 外观门面类. */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Facade</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> ClassA a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ClassA</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> ClassB b <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ClassB</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> ClassC c <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ClassC</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 以下是提供给外部访问的方法.</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">methodA</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>a<span class="token punctuation">.</span><span class="token function">doSomethingA</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">methodB</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>b<span class="token punctuation">.</span><span class="token function">doSomethingB</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">methodC</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>c<span class="token punctuation">.</span><span class="token function">doSomethingC</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="四、模式分析"><a href="#四、模式分析" class="headerlink" title="四、模式分析"></a>四、模式分析</h2><p>根据“单一职责原则”，在软件中将一个系统划分为若干个子系统有利于降低整个系统的复杂性，一个常见的设计目标是使子系统间的通信和相互依赖关系达到最小，而达到该目标的途径之一就是引入一个外观对象，它为子系统的访问提供了一个简单而单一的入口。 外观模式也是“<strong>迪米特法则</strong>”的体现，通过引入一个新的外观类可以降低原有系统的复杂度，同时降低客户类与子系统类的耦合度。</p><ul><li>外观模式要求一个子系统的外部与其内部的通信通过一个统一的外观对象进行，外观类将客户端与子系统的内部复杂性分隔开，使得客户端只需要与外观对象打交道，而不需要与子系统内部的很多对象打交道。</li><li>外观模式的目的在于降低系统的复杂程度。</li><li>外观模式从很大程度上提高了客户端使用的便捷性，使得客户端无须关心子系统的工作细节，通过外观角色即可调用相关功能。</li></ul><h3 id="1-优点"><a href="#1-优点" class="headerlink" title="1. 优点"></a>1. 优点</h3><p>外观模式的优点 k：</p><ul><li>对客户屏蔽子系统组件，减少了客户处理的对象数目并使得子系统使用起来更加容易。通过引入外观模式，客户代码将变得很简单，与之关联的对象也很少。</li><li>实现了子系统与客户之间的松耦合关系，这使得子系统的组件变化不会影响到调用它的客户类，只需要调整外观类即可。</li><li>降低了大型软件系统中的编译依赖性，并简化了系统在不同平台之间的移植过程，因为编译一个子系统一般不需要编译所有其他的子系统。一个子系统的修改对其他子系统没有任何影响，而且子系统内部变化也不会影响到外观对象。</li><li>只是提供了一个访问子系统的统一入口，并不影响用户直接使用子系统类。</li></ul><h3 id="2-缺点"><a href="#2-缺点" class="headerlink" title="2. 缺点"></a>2. 缺点</h3><p>外观模式的缺点：</p><ul><li>不能很好地限制客户使用子系统类，如果对客户访问子系统类做太多的限制则减少了可变性和灵活性。</li><li>在不引入抽象外观类的情况下，增加新的子系统可能需要修改外观类或客户端的源代码，违背了“<strong>开闭原则</strong>”。</li></ul><h3 id="3-适用环境"><a href="#3-适用环境" class="headerlink" title="3. 适用环境"></a>3. 适用环境</h3><p>在以下情况下可以使用外观模式：</p><ul><li>当要为一个复杂子系统提供一个简单接口时可以使用外观模式。该接口可以满足大多数用户的需求，而且用户也可以越过外观类直接访问子系统。</li><li>客户程序与多个子系统之间存在很大的依赖性。引入外观类将子系统与客户以及其他子系统解耦，可以提高子系统的独立性和可移植性。</li><li>在层次化结构中，可以使用外观模式定义系统中每一层的入口，层与层之间不直接产生联系，而通过外观类建立联系，降低层之间的耦合度。</li></ul><h2 id="五、模式总结"><a href="#五、模式总结" class="headerlink" title="五、模式总结"></a>五、模式总结</h2><ul><li>在外观模式中，外部与一个子系统的通信必须通过一个统一的外观对象进行，为子系统中的一组接口提供一个一致的界面，外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。外观模式又称为门面模式，它是一种对象结构型模式。</li><li>外观模式包含两个角色：外观角色是在客户端直接调用的角色，在外观角色中可以知道相关的(一个或者多个)子系统的功能和责任，它将所有从客户端发来的请求委派到相应的子系统去，传递给相应的子系统对象处理；在软件系统中可以同时有一个或者多个子系统角色，每一个子系统可以不是一个单独的类，而是一个类的集合，它实现子系统的功能。</li><li>外观模式要求一个子系统的外部与其内部的通信通过一个统一的外观对象进行，外观类将客户端与子系统的内部复杂性分隔开，使得客户端只需要与外观对象打交道，而不需要与子系统内部的很多对象打交道。</li><li>外观模式主要优点在于对客户屏蔽子系统组件，减少了客户处理的对象数目并使得子系统使用起来更加容易，它实现了子系统与客户之间的松耦合关系，并降低了大型软件系统中的编译依赖性，简化了系统在不同平台之间的移植过程；其缺点在于不能很好地限制客户使用子系统类，而且在不引入抽象外观类的情况下，增加新的子系统可能需要修改外观类或客户端的源代码，违背了“开闭原则”。</li><li>外观模式适用情况包括：要为一个复杂子系统提供一个简单接口；客户程序与多个子系统之间存在很大的依赖性；在层次化结构中，需要定义系统中每一层的入口，使得层与层之间不直接产生联系。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 软件设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 设计原则与模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>中介者模式（Mediator Pattern）</title>
      <link href="/2018/101718124.html"/>
      <url>/2018/101718124.html</url>
      
        <content type="html"><![CDATA[<h2 id="一、模式动机"><a href="#一、模式动机" class="headerlink" title="一、模式动机"></a>一、模式动机</h2><p>在用户与用户直接聊天的设计方案中，用户对象之间存在很强的关联性，将导致系统出现如下问题：</p><ul><li>系统结构复杂：对象之间存在大量的相互关联和调用，若有一个对象发生变化，则需要跟踪和该对象关联的其他所有对象，并进行适当处理。</li><li>对象可重用性差：由于一个对象和其他对象具有很强的关联，若没有其他对象的支持，一个对象很难被另一个系统或模块重用，这些对象表现出来更像一个不可分割的整体，职责较为混乱。</li><li>系统扩展性低：增加一个新的对象需要在原有相关对象上增加引用，增加新的引用关系也需要调整原有对象，系统耦合度很高，对象操作很不灵活，扩展性差。</li><li>在面向对象的软件设计与开发过程中，根据“单一职责原则”，我们应该尽量将对象细化，使其只负责或呈现单一的职责。</li><li>对于一个模块，可能由很多对象构成，而且这些对象之间可能存在相互的引用，为了减少对象两两之间复杂的引用关系，使之成为一个松耦合的系统，我们需要使用中介者模式，这就是中介者模式的模式动机。</li></ul><h2 id="二、模式定义"><a href="#二、模式定义" class="headerlink" title="二、模式定义"></a>二、模式定义</h2><blockquote><p><strong>中介者模式(<code>Mediator Pattern</code>)</strong>：用一个中介对象来封装一系列的对象交互，中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。中介者模式又称为<strong>调停者模式</strong>，它是一种对象行为型模式。</p></blockquote><h2 id="三、模式结构"><a href="#三、模式结构" class="headerlink" title="三、模式结构"></a>三、模式结构</h2><h3 id="1-角色组成"><a href="#1-角色组成" class="headerlink" title="1. 角色组成"></a>1. 角色组成</h3><p>中介者模式包含如下角色：</p><ul><li><code>Mediator</code>: 抽象中介者</li><li><code>ConcreteMediator</code>: 具体中介者</li><li><code>Colleague</code>: 抽象同事类</li><li><code>ConcreteColleague</code>: 具体同事类</li></ul><h3 id="2-结构图"><a href="#2-结构图" class="headerlink" title="2. 结构图"></a>2. 结构图</h3><p><img src="https://pic.lixl.cn/2019/Mediator.jpg" alt="中介者模式结构图"></p><h2 id="四、示例代码"><a href="#四、示例代码" class="headerlink" title="四、示例代码"></a>四、示例代码</h2><p>首先，是抽象的<code>Mediator</code>类和具体的<code>ConcreteMediator</code>类：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 通用抽象中介者类. */</span><span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">Mediator</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/** 定义同事类1. */</span>    <span class="token keyword">protected</span> ConcreteColleague1 colleague1<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/** 定义同事类2. */</span>    <span class="token keyword">protected</span> ConcreteColleague2 colleague2<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* getter 和 setter 方法 */</span>    <span class="token keyword">public</span> ConcreteColleague1 <span class="token function">getColleague1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> colleague1<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setColleague1</span><span class="token punctuation">(</span>ConcreteColleague1 colleague1<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>colleague1 <span class="token operator">=</span> colleague1<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> ConcreteColleague2 <span class="token function">getColleague2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> colleague2<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setColleague2</span><span class="token punctuation">(</span>ConcreteColleague2 colleague2<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>colleague2 <span class="token operator">=</span> colleague2<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 中介者模式的抽象业务逻辑1.     */</span>    <span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">void</span> <span class="token function">doSomething1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * 中介者模式的抽象业务逻辑2.     */</span>    <span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">void</span> <span class="token function">doSomething2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 具体的通用中介者类. */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConcreteMediator</span> <span class="token keyword">extends</span> <span class="token class-name">Mediator</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 中介者模式的具体业务逻辑1.     */</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">doSomething1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">super</span><span class="token punctuation">.</span>colleague1<span class="token punctuation">.</span><span class="token function">selfMethod1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">super</span><span class="token punctuation">.</span>colleague2<span class="token punctuation">.</span><span class="token function">selfMethod2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 中介者模式的具体业务逻辑2.     */</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">doSomething2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">super</span><span class="token punctuation">.</span>colleague1<span class="token punctuation">.</span><span class="token function">selfMethod1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">super</span><span class="token punctuation">.</span>colleague2<span class="token punctuation">.</span><span class="token function">selfMethod2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其实，是抽象的<code>Colleague</code>类和具体的<code>ConcreteColleague</code>类：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 抽象的同事类. */</span><span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">Colleague</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/** 中介者. */</span>    <span class="token keyword">protected</span> Mediator mediator<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">Colleague</span><span class="token punctuation">(</span>Mediator mediator<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>mediator <span class="token operator">=</span> mediator<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 具体的同事类1. */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConcreteColleague1</span> <span class="token keyword">extends</span> <span class="token class-name">Colleague</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token function">ConcreteColleague1</span><span class="token punctuation">(</span>Mediator mediator<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">super</span><span class="token punctuation">(</span>mediator<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 自有方法.     */</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">selfMethod1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"------ConcreteColleague1-处理自己的业务逻辑1--------"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 依赖方法.     */</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">depMethod1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"------ConcreteColleague1-委托给中介者的业务逻辑1--------"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">super</span><span class="token punctuation">.</span>mediator<span class="token punctuation">.</span><span class="token function">doSomething1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 具体的同事类2. */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConcreteColleague2</span> <span class="token keyword">extends</span> <span class="token class-name">Colleague</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token function">ConcreteColleague2</span><span class="token punctuation">(</span>Mediator mediator<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">super</span><span class="token punctuation">(</span>mediator<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 自有方法2.     */</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">selfMethod2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"------ConcreteColleague2-处理自己的业务逻辑2--------"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 依赖方法2.     */</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">depMethod2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"------ConcreteColleague2-委托给中介者的业务逻辑2--------"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">super</span><span class="token punctuation">.</span>mediator<span class="token punctuation">.</span><span class="token function">doSomething2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>以下是中介者模式的客户端场景类：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 中介者模式的场景类 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MediatorClient</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Mediator mediator <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcreteMediator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ConcreteColleague1 colleague1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcreteColleague1</span><span class="token punctuation">(</span>mediator<span class="token punctuation">)</span><span class="token punctuation">;</span>        ConcreteColleague2 colleague2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcreteColleague2</span><span class="token punctuation">(</span>mediator<span class="token punctuation">)</span><span class="token punctuation">;</span>        mediator<span class="token punctuation">.</span><span class="token function">setColleague1</span><span class="token punctuation">(</span>colleague1<span class="token punctuation">)</span><span class="token punctuation">;</span>        mediator<span class="token punctuation">.</span><span class="token function">setColleague2</span><span class="token punctuation">(</span>colleague2<span class="token punctuation">)</span><span class="token punctuation">;</span>        colleague1<span class="token punctuation">.</span><span class="token function">depMethod1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        colleague2<span class="token punctuation">.</span><span class="token function">depMethod2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        mediator<span class="token punctuation">.</span><span class="token function">doSomething1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        mediator<span class="token punctuation">.</span><span class="token function">doSomething2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="五、模式分析"><a href="#五、模式分析" class="headerlink" title="五、模式分析"></a>五、模式分析</h2><p>中介者模式可以使对象之间的关系数量急剧减少。</p><p>中介者承担两方面的职责：</p><ul><li><strong>中转作用（结构性）</strong>：通过中介者提供的中转作用，各个同事对象就不再需要显式引用其他同事，当需要和其他同事进行通信时，通过中介者即可。该中转作用属于中介者在结构上的支持。</li><li><strong>协调作用（行为性）</strong>：中介者可以更进一步的对同事之间的关系进行封装，同事可以一致地和中介者进行交互，而不需要指明中介者需要具体怎么做，中介者根据封装在自身内部的协调逻辑，对同事的请求进行进一步处理，将同事成员之间的关系行为进行分离和封装。该协调作用属于中介者在行为上的支持。</li></ul><h3 id="1-优点"><a href="#1-优点" class="headerlink" title="1. 优点"></a>1. 优点</h3><p>中介者模式的优点：</p><ul><li>简化了对象之间的交互。</li><li>将各同事解耦。</li><li>减少子类生成。</li><li>可以简化各同事类的设计和实现。</li></ul><h3 id="2-缺点"><a href="#2-缺点" class="headerlink" title="2. 缺点"></a>2. 缺点</h3><p>中介者模式的缺点：</p><ul><li>在具体中介者类中包含了同事之间的交互细节，<strong>可能会导致具体中介者类非常复杂，使得系统难以维护</strong>。</li></ul><h3 id="3-适用环境"><a href="#3-适用环境" class="headerlink" title="3. 适用环境"></a>3. 适用环境</h3><p>在以下情况下可以使用中介者模式：</p><ul><li>系统中对象之间存在复杂的引用关系，产生的相互依赖关系结构混乱且难以理解。</li><li>一个对象由于引用了其他很多对象并且直接和这些对象通信，导致难以复用该对象。</li><li>想通过一个中间类来封装多个类中的行为，而又不想生成太多的子类。可以通过引入中介者类来实现，在中介者中定义对象。</li><li>交互的公共行为，如果需要改变行为则可以增加新的中介者类。</li></ul><h2 id="六、模式总结"><a href="#六、模式总结" class="headerlink" title="六、模式总结"></a>六、模式总结</h2><ul><li>中介者模式用一个中介对象来封装一系列的对象交互，中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。中介者模式又称为调停者模式，它是一种对象行为型模式。</li><li>中介者模式包含四个角色：抽象中介者用于定义一个接口，该接口用于与各同事对象之间的通信；具体中介者是抽象中介者的子类，通过协调各个同事对象来实现协作行为，了解并维护它的各个同事对象的引用；抽象同事类定义各同事的公有方法；具体同事类是抽象同事类的子类，每一个同事对象都引用一个中介者对象；每一个同事对象在需要和其他同事对象通信时，先与中介者通信，通过中介者来间接完成与其他同事类的通信；在具体同事类中实现了在抽象同事类中定义的方法。</li><li>通过引入中介者对象，可以将系统的网状结构变成以中介者为中心的星形结构，中介者承担了中转作用和协调作用。中介者类是中介者模式的核心，它对整个系统进行控制和协调，简化了对象之间的交互，还可以对对象间的交互进行进一步的控制。</li><li>中介者模式的主要优点在于简化了对象之间的交互，将各同事解耦，还可以减少子类生成，对于复杂的对象之间的交互，通过引入中介者，可以简化各同事类的设计和实现；中介者模式主要缺点在于具体中介者类中包含了同事之间的交互细节，可能会导致具体中介者类非常复杂，使得系统难以维护。</li><li>中介者模式适用情况包括：系统中对象之间存在复杂的引用关系，产生的相互依赖关系结构混乱且难以理解；一个对象由于引用了其他很多对象并且直接和这些对象通信，导致难以复用该对象；想通过一个中间类来封装多个类中的行为，而又不想生成太多的子类。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 软件设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 设计原则与模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>命令模式（Command Pattern）</title>
      <link href="/2018/101640715.html"/>
      <url>/2018/101640715.html</url>
      
        <content type="html"><![CDATA[<h2 id="一、模式动机"><a href="#一、模式动机" class="headerlink" title="一、模式动机"></a>一、模式动机</h2><p>在软件设计中，我们经常需要向某些对象发送请求，但是并不知道请求的接收者是谁，也不知道被请求的操作是哪个，我们只需在程序运行时指定具体的请求接收者即可，此时，可以使用命令模式来进行设计，使得请求发送者与请求接收者消除彼此之间的耦合，让对象之间的调用关系更加灵活。</p><p>命令模式可以对发送者和接收者完全解耦，发送者与接收者之间没有直接引用关系，发送请求的对象只需要知道如何发送请求，而不必知道如何完成请求。这就是命令模式的模式动机。</p><h2 id="二、模式定义"><a href="#二、模式定义" class="headerlink" title="二、模式定义"></a>二、模式定义</h2><blockquote><p><strong>命令模式(<code>Command Pattern</code>)</strong>：将一个请求封装为一个对象，从而使我们可用不同的请求对客户进行参数化；对请求排队或者记录请求日志，以及支持可撤销的操作。命令模式是一种对象行为型模式，其别名为动作(<code>Action</code>)模式或事务(<code>Transaction</code>)模式。</p></blockquote><h2 id="三、模式结构"><a href="#三、模式结构" class="headerlink" title="三、模式结构"></a>三、模式结构</h2><h3 id="1-角色组成"><a href="#1-角色组成" class="headerlink" title="1. 角色组成"></a>1. 角色组成</h3><p>命令模式包含如下角色：</p><ul><li><code>Command</code>: 抽象命令类</li><li><code>ConcreteCommand</code>: 具体命令类</li><li><code>Invoker</code>: 调用者</li><li><code>Receiver</code>: 接收者</li><li><code>Client</code>: 客户类</li></ul><h3 id="2-结构图"><a href="#2-结构图" class="headerlink" title="2. 结构图"></a>2. 结构图</h3><p><img src="https://pic.lixl.cn/2019/Command.jpg" alt="命令模式结构图"></p><h2 id="四、示例代码"><a href="#四、示例代码" class="headerlink" title="四、示例代码"></a>四、示例代码</h2><p>首先，是抽象的<code>Receiver</code>类和具体的<code>Receiver</code>类：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 通用的抽象 Receiver 接收者. */</span><span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">Receiver</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 定义每个接收者都必须完成的业务.     */</span>    <span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">void</span> <span class="token function">doSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 具体的 Receiver 类1. */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConcreteReceiver1</span> <span class="token keyword">extends</span> <span class="token class-name">Receiver</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">doSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"ConcreteReceiver1 处理的业务逻辑..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 具体的 Receiver 类2. */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConcreteReceiver2</span> <span class="token keyword">extends</span> <span class="token class-name">Receiver</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">doSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"ConcreteReceiver2 处理的业务逻辑..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其实，是抽象的<code>Command</code>类和具体的<code>Command</code>类：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 抽象的 Command 类. */</span><span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">Command</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 命令的抽象执行命令的方法.     */</span>    <span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">void</span> <span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 具体的 Command 命令类1. */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConcreteCommand1</span> <span class="token keyword">extends</span> <span class="token class-name">Command</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/** 对哪个receiver类进行处理. */</span>    <span class="token keyword">private</span> Receiver receiver<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">ConcreteCommand1</span><span class="token punctuation">(</span>Receiver receiver<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>receiver <span class="token operator">=</span> receiver<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 必须实现的一个命令.     */</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>receiver<span class="token punctuation">.</span><span class="token function">doSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 具体的 Command 命令类2. */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConcreteCommand2</span> <span class="token keyword">extends</span> <span class="token class-name">Command</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/** 对哪个receiver类进行处理. */</span>    <span class="token keyword">private</span> Receiver receiver<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">ConcreteCommand2</span><span class="token punctuation">(</span>Receiver receiver<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>receiver <span class="token operator">=</span> receiver<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 必须实现的命令.     */</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>receiver<span class="token punctuation">.</span><span class="token function">doSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>最后，调用者<code>Invoker</code>类：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 调用者 Invoker 类. */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Invoker</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> Command command<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setCommand</span><span class="token punctuation">(</span>Command command<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>command <span class="token operator">=</span> command<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 执行命令.     */</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">action</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>command<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>以下是命令模式的客户端场景类：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 命令模式的场景类. */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">CommandClient</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Invoker invoker <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Invoker</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Receiver receiver <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcreteReceiver1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Command command <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcreteCommand1</span><span class="token punctuation">(</span>receiver<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 把命令交给调用者执行</span>        invoker<span class="token punctuation">.</span><span class="token function">setCommand</span><span class="token punctuation">(</span>command<span class="token punctuation">)</span><span class="token punctuation">;</span>        invoker<span class="token punctuation">.</span><span class="token function">action</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="五、模式分析"><a href="#五、模式分析" class="headerlink" title="五、模式分析"></a>五、模式分析</h2><p><strong>命令模式的本质是对命令进行封装，将发出命令的责任和执行命令的责任分割开</strong>。</p><ul><li>每一个命令都是一个操作：请求的一方发出请求，要求执行一个操作；接收的一方收到请求，并执行操作。</li><li>命令模式允许请求的一方和接收的一方独立开来，使得请求的一方不必知道接收请求的一方的接口，更不必知道请求是怎么被接收，以及操作是否被执行、何时被执行，以及是怎么被执行的。</li><li>命令模式使请求本身成为一个对象，这个对象和其他对象一样可以被存储和传递。</li><li>命令模式的关键在于引入了抽象命令接口，且发送者针对抽象命令接口编程，只有实现了抽象命令接口的具体命令才能与接收者相关联。</li></ul><h3 id="1-优点"><a href="#1-优点" class="headerlink" title="1. 优点"></a>1. 优点</h3><p>命令模式的优点：</p><ul><li>降低系统的耦合度。</li><li>新的命令可以很容易地加入到系统中。</li><li>可以比较容易地设计一个命令队列和宏命令（组合命令）。</li><li>可以方便地实现对请求的<code>Undo</code>和<code>Redo</code>。</li></ul><h3 id="2-缺点"><a href="#2-缺点" class="headerlink" title="2. 缺点"></a>2. 缺点</h3><p>命令模式的缺点：</p><ul><li>使用命令模式可能会导致某些系统有过多的具体命令类。因为针对每一个命令都需要设计一个具体命令类，因此某些系统可能需要大量具体命令类，这将影响命令模式的使用。</li></ul><h3 id="3-适用环境"><a href="#3-适用环境" class="headerlink" title="3. 适用环境"></a>3. 适用环境</h3><p>在以下情况下可以使用命令模式：</p><ul><li>系统需要将请求调用者和请求接收者解耦，使得调用者和接收者不直接交互。</li><li>系统需要在不同的时间指定请求、将请求排队和执行请求。</li><li>系统需要支持命令的撤销(Undo)操作和恢复(Redo)操作。</li><li>系统需要将一组操作组合在一起，即支持宏命令</li></ul><h2 id="六、模式总结"><a href="#六、模式总结" class="headerlink" title="六、模式总结"></a>六、模式总结</h2><ul><li>在命令模式中，将一个请求封装为一个对象，从而使我们可用不同的请求对客户进行参数化；对请求排队或者记录请求日志，以及支持可撤销的操作。命令模式是一种对象行为型模式，其别名为动作模式或事务模式。</li><li>命令模式包含四个角色：抽象命令类中声明了用于执行请求的<code>execute()</code>等方法，通过这些方法可以调用请求接收者的相关操作；具体命令类是抽象命令类的子类，实现了在抽象命令类中声明的方法，它对应具体的接收者对象，将接收者对象的动作绑定其中；调用者即请求的发送者，又称为请求者，它通过命令对象来执行请求；接收者执行与请求相关的操作，它具体实现对请求的业务处理。</li><li>命令模式的本质是对命令进行封装，将发出命令的责任和执行命令的责任分割开。命令模式使请求本身成为一个对象，这个对象和其他对象一样可以被存储和传递。</li><li>命令模式的主要优点在于降低系统的耦合度，增加新的命令很方便，而且可以比较容易地设计一个命令队列和宏命令，并方便地实现对请求的撤销和恢复；其主要缺点在于可能会导致某些系统有过多的具体命令类。</li><li>命令模式适用情况包括：需要将请求调用者和请求接收者解耦，使得调用者和接收者不直接交互；需要在不同的时间指定请求、将请求排队和执行请求；需要支持命令的撤销操作和恢复操作，需要将一组操作组合在一起，即支持宏命令。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 软件设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 设计原则与模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>观察者模式（Observer Pattern）</title>
      <link href="/2018/101432841.html"/>
      <url>/2018/101432841.html</url>
      
        <content type="html"><![CDATA[<h2 id="一、模式动机"><a href="#一、模式动机" class="headerlink" title="一、模式动机"></a>一、模式动机</h2><p>建立一种对象与对象之间的依赖关系，一个对象发生改变时将自动通知其他对象，其他对象将相应做出反应。在此，发生改变的对象称为观察目标，而被通知的对象称为观察者，一个观察目标可以对应多个观察者，而且这些观察者之间没有相互联系，可以根据需要增加和删除观察者，使得系统更易于扩展，这就是观察者模式的模式动机。</p><h2 id="二、模式定义"><a href="#二、模式定义" class="headerlink" title="二、模式定义"></a>二、模式定义</h2><blockquote><p>观察者模式(<code>Observer Pattern</code>)：定义对象间的一种一对多依赖关系，使得每当一个对象状态发生改变时，其相关依赖对象皆得到通知并被自动更新。观察者模式又叫做发布-订阅（<code>Publish</code>/<code>Subscribe</code>）模式、模型-视图（<code>Model</code>/<code>View</code>）模式、源-监听器（<code>Source</code>/<code>Listener</code>）模式或从属者（<code>Dependents</code>）模式。</p></blockquote><p>观察者模式是一种<strong>对象行为型模式</strong>。</p><h2 id="三、模式结构"><a href="#三、模式结构" class="headerlink" title="三、模式结构"></a>三、模式结构</h2><h3 id="1-角色组成"><a href="#1-角色组成" class="headerlink" title="1. 角色组成"></a>1. 角色组成</h3><p>观察者模式包含如下角色：</p><ul><li><code>Subject</code>: 目标（抽象的被观察着）</li><li><code>ConcreteSubject</code>: 具体目标（具体的被观察者）</li><li><code>Observer</code>: 观察者</li><li><code>ConcreteObserver</code>: 具体观察者</li></ul><h3 id="2-结构图"><a href="#2-结构图" class="headerlink" title="2. 结构图"></a>2. 结构图</h3><p><img src="https://pic.lixl.cn/2019/Obeserver.jpg" alt="观察者模式结构图"></p><h3 id="3-时序图"><a href="#3-时序图" class="headerlink" title="3. 时序图"></a>3. 时序图</h3><p><img src="https://pic.lixl.cn/2019/seq_Obeserver.jpg" alt="观察者模式时序图"></p><h2 id="四、示例代码"><a href="#四、示例代码" class="headerlink" title="四、示例代码"></a>四、示例代码</h2><p>首先，是观察者接口：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 观察者接口 * */</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Observer</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 更新的方法</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">update</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>接下来，是具体的观察者类：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 具体的观察者. */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConcreteObserver</span> <span class="token keyword">implements</span> <span class="token class-name">Observer</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 实现更新方法.     */</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">update</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"接收到信息,并进行处理..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后，是被观察者的抽象类：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 被观察者的抽象类. */</span><span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">Subject</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/** 定义一个观察者的集合. */</span>    <span class="token keyword">private</span> List<span class="token operator">&lt;</span>Observer<span class="token operator">></span> observers <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span>Observer<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * 增加一个观察者.     *     * @param o     */</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">addObserver</span><span class="token punctuation">(</span>Observer o<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>observers<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>o<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 删除一个观察者.     *     * @param o     */</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">delObserver</span><span class="token punctuation">(</span>Observer o<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>observers<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>o<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 通知所有观察者.     */</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">notifyObservers</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>Observer o<span class="token operator">:</span> observers<span class="token punctuation">)</span> <span class="token punctuation">{</span>            o<span class="token punctuation">.</span><span class="token function">update</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>具体的被观察者：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 具体的被观察者. */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConcreteSubject</span> <span class="token keyword">extends</span> <span class="token class-name">Subject</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 具体的业务.     */</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">doSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">notifyObservers</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>最后，是用于测试观察者模式的客户端场景类：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 观察者模式客户端场景类. */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ObserverClient</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 创建一个被观察者和观察者.</span>        ConcreteSubject sub <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcreteSubject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Observer obs <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcreteObserver</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 观察者观察被观察者.</span>        sub<span class="token punctuation">.</span><span class="token function">addObserver</span><span class="token punctuation">(</span>obs<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 观察者开始活动了.</span>        sub<span class="token punctuation">.</span><span class="token function">doSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="五、模式分析"><a href="#五、模式分析" class="headerlink" title="五、模式分析"></a>五、模式分析</h2><ul><li>观察者模式描述了如何建立对象与对象之间的依赖关系，如何构造满足这种需求的系统。</li><li>这一模式中的关键对象是观察目标和观察者，一个目标可以有任意数目的与之相依赖的观察者，一旦目标的状态发生改变，所有的观察者都将得到通知。</li><li>作为对这个通知的响应，每个观察者都将即时更新自己的状态，以与目标状态同步，这种交互也称为<strong>发布-订阅</strong>(<code>publish-subscribe</code>)。目标是通知的发布者，它发出通知时并不需要知道谁是它的观察者，可以有任意数目的观察者订阅它并接收通。</li></ul><h3 id="1-优点"><a href="#1-优点" class="headerlink" title="1. 优点"></a>1. 优点</h3><p>观察者模式的优点：</p><ul><li>观察者模式可以实现表示层和数据逻辑层的分离，并定义了稳定的消息更新传递机制，抽象了更新接口，使得可以有各种各样不同的表示层作为具体观察者角色。</li><li>观察者模式在观察目标和观察者之间建立一个抽象的耦合。</li><li>观察者模式支持广播通信。</li><li>观察者模式符合“开闭原则”的要求。</li></ul><h3 id="2-缺点"><a href="#2-缺点" class="headerlink" title="2. 缺点"></a>2. 缺点</h3><p>观察者模式的缺点：</p><ul><li>如果一个观察目标对象有很多直接和间接的观察者的话，将所有的观察者都通知到会花费很多时间。</li><li>如果在观察者和观察目标之间有循环依赖的话，观察目标会触发它们之间进行循环调用，可能导致系统崩溃。</li><li>观察者模式没有相应的机制让观察者知道所观察的目标对象是怎么发生变化的，而仅仅只是知道观察目标发生了变化。</li></ul><h3 id="3-适用环境"><a href="#3-适用环境" class="headerlink" title="3.适用环境"></a>3.适用环境</h3><p>在以下情况下可以使用观察者模式：</p><ul><li>一个抽象模型有两个方面，其中一个方面依赖于另一个方面。将这些方面封装在独立的对象中使它们可以各自独立地改变和复用。</li><li>一个对象的改变将导致其他一个或多个对象也发生改变，而不知道具体有多少对象将发生改变，可以降低对象之间的耦合度。</li><li>一个对象必须通知其他对象，而并不知道这些对象是谁。</li><li>需要在系统中创建一个触发链，A 对象的行为将影响 B 对象，B 对象的行为将影响 C 对象……，可以使用观察者模式创建一种链式触发机制。</li></ul><blockquote><p>观察者模式在软件开发中应用非常广泛，如某电子商务网站可以在执行发送操作后给用户多个发送商品打折信息，某团队战斗游戏中某队友牺牲将给所有成员提示等等，凡是涉及到一对一或者一对多的对象交互场景都可以使用观察者模式。</p></blockquote><h2 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h2><ul><li>观察者模式定义对象间的一种一对多依赖关系，使得每当一个对象状态发生改变时，其相关依赖对象皆得到通知并被自动更新。观察者模式又叫做发布-订阅模式、模型-视图模式、源-监听器模式或从属者模式。观察者模式是一种对象行为型模式。</li><li>观察者模式包含四个角色：目标又称为主题，它是指被观察的对象；具体目标是目标类的子类，通常它包含有经常发生改变的数据，当它的状态发生改变时，向它的各个观察者发出通知；观察者将对观察目标的改变做出反应；在具体观察者中维护一个指向具体目标对象的引用，它存储具体观察者的有关状态，这些状态需要和具体目标的状态保持一致。</li><li>观察者模式定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个目标对象，当这个目标对象的状态发生变化时，会通知所有观察者对象，使它们能够自动更新。</li><li>观察者模式的主要优点在于可以实现表示层和数据逻辑层的分离，并在观察目标和观察者之间建立一个抽象的耦合，支持广播通信；其主要缺点在于如果一个观察目标对象有很多直接和间接的观察者的话，将所有的观察者都通知到会花费很多时间，而且如果在观察者和观察目标之间有循环依赖的话，观察目标会触发它们之间进行循环调用，可能导致系统崩溃。</li><li>观察者模式适用情况包括：一个抽象模型有两个方面，其中一个方面依赖于另一个方面；一个对象的改变将导致其他一个或多个对象也发生改变，而不知道具体有多少对象将发生改变；一个对象必须通知其他对象，而并不知道这些对象是谁；需要在系统中创建一个触发链。</li><li>在 JDK 的<code>java.util</code>包中，提供了<code>Observable</code>类以及<code>Observer</code>接口，它们构成了 Java 语言对观察者模式的支持。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 软件设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 设计原则与模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Google Java编程风格指南</title>
      <link href="/2018/10056920.html"/>
      <url>/2018/10056920.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1 前言"></a>1 前言</h2><p>这份文档是<code>Google Java</code>编程风格规范的完整定义。当且仅当一个<code>Java</code>源文件符合此文档中的规则，我们才认为它符合<code>Google</code>的<code>Java</code>编程风格。</p><p>与其它的编程风格指南一样，这里所讨论的不仅仅是编码格式美不美观的问题，同时也讨论一些约定及编码标准。然而，这份文档主要侧重于我们所普遍遵循的规则，对于那些不是明确强制要求的，我们尽量避免提供意见。</p><h3 id="1-1-术语说明"><a href="#1-1-术语说明" class="headerlink" title="1.1 术语说明"></a>1.1 术语说明</h3><p>本文档中除非特殊说明，否则：</p><ul><li>术语<code>class</code>可表示一个普通类、枚举类、接口或者注解。</li><li>术语<code>comment</code>只用来指代实现的注释(<code>implementation comments</code>)，我们不使用文档注释(<code>documentation comments</code>)一词，而是用<code>Javadoc</code>。</li></ul><p>其他术语说明，将在文档中需要说明的地方单独说明。</p><h3 id="1-2-指南说明"><a href="#1-2-指南说明" class="headerlink" title="1.2 指南说明"></a>1.2 指南说明</h3><p>本文档中的示例代码并不作为规范。也就是说，虽然示例代码是遵循Google编程风格，但并不意味着这是展现这些代码的唯一方式。示例中的格式选择不应该被强制定为规则。</p><h2 id="2-源文件基础"><a href="#2-源文件基础" class="headerlink" title="2 源文件基础"></a>2 源文件基础</h2><h3 id="2-1-文件名"><a href="#2-1-文件名" class="headerlink" title="2.1 文件名"></a>2.1 文件名</h3><p>源文件以其最顶层的类名（其中只有一个）来命名，大小写敏感，文件扩展名为<code>.java</code>。</p><h3 id="2-2-文件编码：UTF-8"><a href="#2-2-文件编码：UTF-8" class="headerlink" title="2.2 文件编码：UTF-8"></a>2.2 文件编码：UTF-8</h3><p>源文件编码格式使用<code>UTF-8</code>。</p><h3 id="2-3-特殊字符"><a href="#2-3-特殊字符" class="headerlink" title="2.3 特殊字符"></a>2.3 特殊字符</h3><h4 id="2-3-1-空格字符"><a href="#2-3-1-空格字符" class="headerlink" title="2.3.1 空格字符"></a>2.3.1 空格字符</h4><p>除了换行符外，<code>ASCII</code>水平空白字符（0x20）是源码文件中唯一支持的空格字符。这意味着：</p><ul><li>所有其他空白字符将被转义。</li><li><code>Tab</code>字符不被用作缩进控制。</li></ul><h4 id="2-3-2-特殊转义字符串"><a href="#2-3-2-特殊转义字符串" class="headerlink" title="2.3.2 特殊转义字符串"></a>2.3.2 特殊转义字符串</h4><p>任何需要转义字符串表示的字符（例如：<code>\b</code>, <code>\t</code>, <code>\n</code>, <code>\f</code>, <code>\r</code>, <code>\&#39;</code>, <code>\\</code>等），采用这种转义字符串的方式表示，而不采用对应字符的八进制数（例如 <code>\012</code>）或<code>Unicode</code>码（例如：<code>\u000a</code>）表示。</p><h4 id="2-3-3-非ASCII字符"><a href="#2-3-3-非ASCII字符" class="headerlink" title="2.3.3 非ASCII字符"></a>2.3.3 非ASCII字符</h4><p>对于其余非<code>ASCII</code>字符，直接使用<code>Unicode</code>字符（例如 <code>∞</code>），或者使用对应的<code>Unicode</code>码（例如：<code>\u221e</code>）转义，都是允许的。<strong>唯一需要考虑的是，何种方式更能使代码容易阅读和理解</strong>。</p><blockquote><p><strong>注意</strong>：在使用<code>Unicode</code>码转义，或者甚至是有时直接使用<code>Unicode</code>字符的时候，建议多添加一些注释说明，将对别人读懂代码很有帮助。</p></blockquote><p>例子：</p><table><thead><tr><th>示例</th><th>结论</th></tr></thead><tbody><tr><td>String unitAbbrev = “μs”;</td><td>赞：即使没有注释也非常清晰。</td></tr><tr><td>String unitAbbrev = “\u03bcs”; // “μs”</td><td>允许，但没有理由要这样做。</td></tr><tr><td>String unitAbbrev = “\u03bcs”; // Greek letter mu, “s”</td><td>允许，但这样做显得笨拙还容易出错。</td></tr><tr><td>String unitAbbrev = “\u03bcs”;</td><td>很糟：读者根本看不出这是什么。</td></tr><tr><td>return ‘\ufeff’ + content; // byte order mark</td><td>很好：对于非打印字符，使用转义，并在必要时写上注释。</td></tr></tbody></table><blockquote><p><strong>注意</strong>：永远不要由于害怕某些程序可能无法正确处理非<code>ASCII</code>字符而让你的代码可读性变差。当程序无法正确处理非<code>ASCII</code>字符时，它自然无法正确运行，你就会去<code>fix</code>这些问题的了。(言下之意就是大胆去用非<code>ASCII</code>字符，如果真的有需要的话)</p></blockquote><h2 id="3-源文件结构"><a href="#3-源文件结构" class="headerlink" title="3 源文件结构"></a>3 源文件结构</h2><p>源文件按照先后顺序，由以下几部分组成：</p><ul><li>许可证(<code>License</code>)或版权信息(<code>copyright</code>)（如果需要）</li><li><code>package</code>语句</li><li><code>import</code>语句</li><li><code>class</code>类声明（每个源码文件只能有唯一一个顶级<code>class</code>）。</li></ul><blockquote><p><strong>注意</strong>：以上每个部分之间应该只有<strong>一个空行</strong>作为间隔。</p></blockquote><h3 id="3-1-许可证或版权信息"><a href="#3-1-许可证或版权信息" class="headerlink" title="3.1 许可证或版权信息"></a>3.1 许可证或版权信息</h3><p>如果一个文件包含许可证或版权信息，那么它应当被放在文件最前面。</p><h3 id="3-2-package语句"><a href="#3-2-package语句" class="headerlink" title="3.2 package语句"></a>3.2 package语句</h3><p><code>package</code>语句不换行，单行长度限制(4.4节)不适用于package语句。(即package语句写在一行里)</p><h3 id="3-3-import语句"><a href="#3-3-import语句" class="headerlink" title="3.3 import语句"></a>3.3 import语句</h3><h4 id="3-3-1-import不使用通配符"><a href="#3-3-1-import不使用通配符" class="headerlink" title="3.3.1 import不使用通配符"></a>3.3.1 import不使用通配符</h4><p><code>import</code>语句中不应该使用通配符，不管是否是静态导入。</p><h4 id="3-3-2-import不换行"><a href="#3-3-2-import不换行" class="headerlink" title="3.3.2 import不换行"></a>3.3.2 import不换行</h4><p><code>import</code>语句不换行，列限制(4.4节)并不适用于<code>import</code>语句。(每个<code>import</code>语句独立成行)</p><h4 id="3-3-3-顺序和间距"><a href="#3-3-3-顺序和间距" class="headerlink" title="3.3.3 顺序和间距"></a>3.3.3 顺序和间距</h4><p><code>import</code>语句可分为以下几组，按照顺序，每组由<strong>一个空行</strong>分隔：</p><ul><li>所有的静态导入(static import)归为一组</li><li><code>com.google</code>包的<code>import</code>归为一组</li><li>使用的第三方包的导入，每个顶级按字典顺序归为一组。例如：<code>android</code>, <code>com</code>, <code>junit</code>, <code>org</code>, <code>sun</code></li><li><code>java</code>包归为一组</li><li><code>javax</code>包归为一组</li></ul><blockquote><p><strong>注意</strong>：同一组内的<code>import</code>语句之间不应用空行隔开，同一组中的<code>import</code>语句按字典序排列。</p></blockquote><h3 id="3-4-类声明"><a href="#3-4-类声明" class="headerlink" title="3.4 类声明"></a>3.4 类声明</h3><h4 id="3-4-1-只声明唯一一个顶级class"><a href="#3-4-1-只声明唯一一个顶级class" class="headerlink" title="3.4.1 只声明唯一一个顶级class"></a>3.4.1 只声明唯一一个顶级class</h4><p>每个源文件中只能有一个顶级class。</p><h4 id="3-4-2-类成员顺序"><a href="#3-4-2-类成员顺序" class="headerlink" title="3.4.2 类成员顺序"></a>3.4.2 类成员顺序</h4><p>类成员的顺序对代码的易读性有很大影响，但是没有一个统一正确的标准。不同的类可能有不同的排序方式。</p><p>最重要的一点，<strong>每个类应该以某种逻辑去排序它的成员，维护者应该要能解释这种排序逻辑</strong>。比如，新的方法不能总是习惯性地添加到类的结尾，因为这样就是按时间顺序而非某种逻辑来排序的。</p><h5 id="3-4-2-1-重载：永不分离"><a href="#3-4-2-1-重载：永不分离" class="headerlink" title="3.4.2.1 重载：永不分离"></a>3.4.2.1 重载：永不分离</h5><p>当一个类有多个构造函数，或是多个同名方法，这些方法应该按顺序出现在一起，中间不要放进其它方法。</p><h2 id="4-格式"><a href="#4-格式" class="headerlink" title="4 格式"></a>4 格式</h2><blockquote><p><strong>术语说明</strong>：块状结构(<code>block-­like construct</code>)指的是一个类，方法或构造函数的主体。需要注意的是，数组初始化中的初始值可被选择性地视为块状结构(4.8.3.1节)。</p></blockquote><h3 id="4-1-大括号"><a href="#4-1-大括号" class="headerlink" title="4.1 大括号"></a>4.1 大括号</h3><h4 id="4-1-1-使用大括号-即使是可选的"><a href="#4-1-1-使用大括号-即使是可选的" class="headerlink" title="4.1.1 使用大括号(即使是可选的)"></a>4.1.1 使用大括号(即使是可选的)</h4><p>大括号一般用在<code>if</code>, <code>else</code>, <code>for</code>, <code>do</code>, <code>while</code>等语句，即使只有一条语句(或是空)，也应该把大括号写上。</p><h4 id="4-1-2-非空语句块采用K-amp-R风格"><a href="#4-1-2-非空语句块采用K-amp-R风格" class="headerlink" title="4.1.2 非空语句块采用K&amp;R风格"></a>4.1.2 非空语句块采用<code>K&amp;R</code>风格</h4><p>对于非空语句块，大括号遵循<code>Kernighan</code>和<code>Ritchie</code>风格 (<a href="https://blog.codinghorror.com/new-programming-jargon/" target="_blank" rel="noopener">Egyptian brackets</a>):</p><ul><li>左大括号前不换行</li><li>左大括号后换行</li><li>右大括号前换行</li><li>如果右大括号结束是一个<code>语句块</code>或者<code>方法体</code>、<code>构造函数体</code>或者<code>有命名的类体</code>，则需要换行。当右括号后面接<code>else</code>或者<code>逗号</code>时，不应该换行。</li></ul><p>示例：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token function">condition</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">method</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">MyClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span> <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">method</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">condition</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">try</span> <span class="token punctuation">{</span>                <span class="token function">something</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">ProblemException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token function">recover</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">otherCondition</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">somethingElse</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token function">lastThing</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>一些例外的情况，将在<code>4.8.1</code>节讲<code>枚举类型</code>的时候讲到。</p><h4 id="4-1-3-空语句块：使代码更简洁"><a href="#4-1-3-空语句块：使代码更简洁" class="headerlink" title="4.1.3 空语句块：使代码更简洁"></a>4.1.3 空语句块：使代码更简洁</h4><p>一个空的语句块，可以在左大括号之后直接接右大括号，中间不需要空格或换行。但是当一个由几个语句块联合组成的语句块时，则需要换行。（例如：<code>if/else</code> 或者<code>try/catch/finally</code>）.</p><p>示例：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 这是可接受的</span><span class="token keyword">void</span> <span class="token function">doNothing</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 这同样是可接受的</span><span class="token keyword">void</span> <span class="token function">doNothingElse</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 这是不可接受的：多块语句中没有简洁的空语句块</span><span class="token keyword">try</span> <span class="token punctuation">{</span>    <span class="token function">doSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4-2块缩进：2个空格"><a href="#4-2块缩进：2个空格" class="headerlink" title="4.2块缩进：2个空格"></a>4.2块缩进：2个空格</h3><p>每当一个新的语句块产生，缩进就增加两个空格。当这个语句块结束时，缩进恢复到上一层级的缩进格数。缩进要求对整个语句块中的代码和注释都适用。（例子可参考之前4.1.2节中的例子）。</p><blockquote><p><strong>注意</strong>：根据实际的编程经验，<code>2</code>个空格缩进的代码在当前大屏的计算机上会显得十分拥挤，反而使得代码<code>臃肿</code>不够美观。所以，我这里建议使用<code>4</code>个空格来缩进，会使得更加美观，而且能侧面督促开发人员减少代码的嵌套层数。</p></blockquote><h3 id="4-3-一行一个语句"><a href="#4-3-一行一个语句" class="headerlink" title="4.3 一行一个语句"></a>4.3 一行一个语句</h3><p>每条语句结束都需要换行。</p><h3 id="4-4-列长度限制：100"><a href="#4-4-列长度限制：100" class="headerlink" title="4.4 列长度限制：100"></a>4.4 列长度限制：100</h3><p>Java代码的列长度限制为<code>100个</code>字符。 除了如下所述，任何超过此限制的行都必须跳行。这在4.5节会有详细解释。</p><p>例外：</p><ul><li>不可能满足行长度限制的行(例如，Javadoc中的一个长URL，或是一个长的JSNI方法参考)</li><li><code>package</code>和<code>import</code>语句(见3.2节和3.3节)</li><li>注释中那些可能被剪切并粘贴到shell中的命令行</li></ul><blockquote><p><strong>注意</strong>：当前的计算机屏幕都已经比很宽了，而且变量及方法命名都较长，<code>100</code>个字符的长度反而会出现很多不必要的跳行，已经不适应当今的情况了，根据实际编程经验，我这里建议使用<code>120</code>个字符的宽度更为合适。</p></blockquote><h3 id="4-5-换行"><a href="#4-5-换行" class="headerlink" title="4.5 换行"></a>4.5 换行</h3><p><strong>术语说明</strong>：一般情况下，一行长代码为了避免超出列限制(<code>100</code>个字符)而被分为多行，我们称之为断行(<code>line­-wrapping</code>)。</p><p>我们并没有全面，确定性的准则来决定在每一种情况下如何断行。很多时候，对于同一段代码会有好几种有效的换断行方式。</p><blockquote><p><strong>注意</strong>: 提取<code>方法</code>或<code>局部变量</code>可以解决问题，而不不需要进行断行。</p></blockquote><h4 id="4-5-1-在何处断行"><a href="#4-5-1-在何处断行" class="headerlink" title="4.5.1 在何处断行"></a>4.5.1 在何处断行</h4><p>断行的主要原则是：<strong>选择在更高级的语法逻辑处断行</strong>。其他一些原则如下：</p><ul><li>当一个非赋值运算的语句断行时，在运算符号之前断行。（这与Google的C++规范和JavaScrip规范等其他规范不同）。</li><li>如果要在非赋值运算符处断行，那么在该符号前断开(比如<code>+</code>操作符，它将位于下一行)。以下的<code>类运算符</code>也可作为参考：<ul><li>点操作符<code>.</code></li><li>类型界限中的<code>&amp;</code>、<code>||</code>等（例如：<code>&lt;T extends Foo &amp; Bar&gt;</code>)</li></ul></li><li>当要在一个赋值运算语句处断行时，一般在赋值符号之后断行。但是也可以在之前断行。(例如：<code>=</code>，它与前面的内容留在同一行)。<ul><li>这条规则也适用于<code>foreach</code>语句中的冒号。</li></ul></li><li>方法名或构造函数名与左括号留在同一行。</li><li>逗号(<code>,</code>)与其前面的内容留在同一行。也就是在逗号之后断行。</li><li><code>Lambda</code>表达式在箭头符号(<code>-&gt;</code>)后断行。</li></ul><p>示例：</p><pre class="line-numbers language-java"><code class="language-java">MyLambda<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Long<span class="token punctuation">,</span> Object<span class="token operator">></span> lambda <span class="token operator">=</span>    <span class="token punctuation">(</span>String label<span class="token punctuation">,</span> Long value<span class="token punctuation">,</span> Object obj<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span>Predicate<span class="token operator">&lt;</span>String<span class="token operator">></span> predicate <span class="token operator">=</span> str <span class="token operator">-</span><span class="token operator">></span>    <span class="token function">longExpressionInvolving</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><strong>注意</strong>：换行的主要目标是使代码更清晰易读。</p></blockquote><h4 id="4-5-2-断行的缩进：至少-4个空格"><a href="#4-5-2-断行的缩进：至少-4个空格" class="headerlink" title="4.5.2 断行的缩进：至少+4个空格"></a>4.5.2 断行的缩进：至少+4个空格</h4><p>自动换行时，第一行后的每一行至少比第一行多缩进<code>4</code>个空格(注意：制表符不用于缩进。见2.3.1节)。</p><p>当存在连续自动换行时，缩进可能会多缩进不只<code>4</code>个空格(语法元素存在多级时)。一般而言，两个连续行使用相同的缩进当且仅当它们开始于同级语法元素。</p><p>第4.6.3水平对齐一节中指出，不鼓励使用可变数目的空格来对齐前面行的符号。</p><h3 id="4-6-空白"><a href="#4-6-空白" class="headerlink" title="4.6 空白"></a>4.6 空白</h3><h4 id="4-6-1-垂直空白"><a href="#4-6-1-垂直空白" class="headerlink" title="4.6.1 垂直空白"></a>4.6.1 垂直空白</h4><p>以下情况需要使用单行空行：</p><ul><li>类成员之间需要单个空行隔开：例如：<code>字段</code>，<code>构造函数</code>，<code>方法</code>，<code>嵌套类</code>，<code>静态初始化块</code>，<code>实例初始化块</code>。但也有以下两种例外情况：<ul><li>两个连续字段之间的空行是可选的，根据需要使用空行来创建字段间的逻辑分组。</li><li>枚举常量之间的的空行也是可选的，根据需要使用空行来创建枚举常量间的逻辑分组。</li></ul></li><li>在方法体内，根据代码的逻辑分组的需要，设置空白行作为间隔。</li><li>类的第一个成员之前或最后一个成员之后，使用空行(可选)。</li><li>本文档所介绍的其他章节的空行要求(比如3.3节：<code>import</code>语句)。</li></ul><h4 id="4-6-2-水平空白"><a href="#4-6-2-水平空白" class="headerlink" title="4.6.2 水平空白"></a>4.6.2 水平空白</h4><p>除了语法、其他规则、词语分隔、注释和javadoc外，水平的ASCII空格只在以下情况出现：</p><ul><li>所有保留的关键字与紧接它之后的位于同一行的左大括号之间需要用空格隔开。(例如：<code>if</code>, <code>for</code> <code>catch</code>等)</li><li>所有保留的关键字与在它之前的右大括号之间需要空格隔开。（例如：<code>else</code>、<code>catch</code>）</li><li>在左大括号之前都需要空格隔开。只有两种例外：<ul><li><code>@SomeAnnotation({a, b})</code></li><li><code>String[][] x = foo;</code></li></ul></li><li>所有的二元运算符和三元运算符的两边，都需要空格隔开。(例如：<code>a + b</code>、<code>b = a &lt; 0 ? 0 : a</code>)</li><li>逗号(<code>,</code>)、冒号(<code>:</code>)、分号(<code>;</code>)和右小括号(<code>)</code>)、Lambda箭头符号(<code>-&gt;</code>)之后，需要空格隔开。</li><li><code>//</code>双斜线开始一行注释时，双斜线两边都应该用空格隔开。并且可使用多个空格。（可选，例如：<code>a = 0; // 赋值为0</code>）</li><li>变量声明时，变量类型和变量名之间需要用空格隔开。（例如：<code>List&lt;String&gt; list</code>）</li><li>初始化一个数组时，花括号之间可以用空格隔开，也可以不使用。（可选，例如：<code>new int[] {5, 6}</code>和<code>new int[] { 5, 6 }</code>）</li></ul><blockquote><p><strong>注意</strong>：这个规则并不要求或禁止一行的开关或结尾需要额外的空格，只对内部空格做要求。</p></blockquote><h4 id="4-6-3-水平对齐：不做要求"><a href="#4-6-3-水平对齐：不做要求" class="headerlink" title="4.6.3 水平对齐：不做要求"></a>4.6.3 水平对齐：不做要求</h4><blockquote><p><strong>术语说明</strong>：水平对齐，是指通过添加多个空格，使本行的某一符号与上一行的某一符号上下对齐。</p></blockquote><p>这种对齐是被允许的，但是不会做强制要求。</p><p>以下是没有水平对齐和水平对齐的例子：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">int</span> x<span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// 这种挺好</span><span class="token keyword">private</span> Color color<span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// 同上</span><span class="token keyword">private</span> <span class="token keyword">int</span>   x<span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">// 允许，但是未来会继续编辑</span><span class="token keyword">private</span> Color color<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 可能会使它对不齐</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><strong>注意</strong>：水平对齐能够增加代码的可读性，但是增加了未来维护代码的难度。考虑到维护时只需要改变一行代码，之前的对齐可以不需要改动。为了对齐，你更有可能改了一行代码，同时需要更改附近的好几行代码，而这几行代码的改动，可能又会引起一些为了保持对齐的代码改动。那原本这行改动，我们称之为<strong>爆炸半径</strong>。这种改动，在最坏的情况下可能会导致大量的无意义的工作，即使在最好的情况下，也会影响版本历史信息，减慢代码<code>review</code>的速度，引起更多<code>merge</code>代码冲突的情况。</p></blockquote><h3 id="4-7-分组小括号：推荐使用"><a href="#4-7-分组小括号：推荐使用" class="headerlink" title="4.7 分组小括号：推荐使用"></a>4.7 分组小括号：推荐使用</h3><p>除非作者和<code>reviewer</code>都认为去掉小括号也不会使代码被误解，或是去掉小括号能让代码更易于阅读，否则我们不应该去掉小括号。我们没有理由假设读者能记住整个Java运算符优先级表。</p><h3 id="4-8-特殊结构"><a href="#4-8-特殊结构" class="headerlink" title="4.8 特殊结构"></a>4.8 特殊结构</h3><h4 id="4-8-1-枚举类型"><a href="#4-8-1-枚举类型" class="headerlink" title="4.8.1 枚举类型"></a>4.8.1 枚举类型</h4><p>枚举常量间用逗号隔开，换行是可选的。而且还允许附加的空行（通常只有一个）。以下就是一种可能性的示例：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">enum</span> Answer <span class="token punctuation">{</span>    YES <span class="token punctuation">{</span>        <span class="token annotation punctuation">@Override</span> <span class="token keyword">public</span> String <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token string">"yes"</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    NO<span class="token punctuation">,</span>    MAYBE<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>没有方法和Javadoc的枚举类可写成数组初始化的格式：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">enum</span> Suit <span class="token punctuation">{</span> CLUBS<span class="token punctuation">,</span> HEARTS<span class="token punctuation">,</span> SPADES<span class="token punctuation">,</span> DIAMONDS <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>由于枚举类也是一个类，因此所有适用于其它类的格式规则也适用于枚举类。</p><h4 id="4-8-2-变量声明"><a href="#4-8-2-变量声明" class="headerlink" title="4.8.2 变量声明"></a>4.8.2 变量声明</h4><h5 id="4-8-2-1-每次声明一个变量"><a href="#4-8-2-1-每次声明一个变量" class="headerlink" title="4.8.2.1 每次声明一个变量"></a>4.8.2.1 每次声明一个变量</h5><p>不要使用组合声明。例如：<code>int a, b;</code>是不允许的。</p><h5 id="4-8-2-2-需要时才声明，尽快进行初始化"><a href="#4-8-2-2-需要时才声明，尽快进行初始化" class="headerlink" title="4.8.2.2 需要时才声明，尽快进行初始化"></a>4.8.2.2 需要时才声明，尽快进行初始化</h5><p>不要在一个代码块的开头把局部变量一次性都声明了(这是c语言的做法)，而是在第一次需要使用它时才声明。局部变量在声明时最好就进行初始化，或者声明后尽快进行初始化。</p><h4 id="4-8-3-数组"><a href="#4-8-3-数组" class="headerlink" title="4.8.3 数组"></a>4.8.3 数组</h4><h5 id="4-8-3-1-数组初始化：可写成块状结构"><a href="#4-8-3-1-数组初始化：可写成块状结构" class="headerlink" title="4.8.3.1 数组初始化：可写成块状结构"></a>4.8.3.1 数组初始化：可写成块状结构</h5><p>数组初始化可以写成块状结构，例如以下格式的写法都是允许的：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">{</span>           <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">{</span>  <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span>            <span class="token number">0</span><span class="token punctuation">,</span><span class="token punctuation">}</span>                       <span class="token number">1</span><span class="token punctuation">,</span>                        <span class="token number">2</span><span class="token punctuation">,</span><span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">{</span>             <span class="token number">3</span><span class="token punctuation">,</span>  <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span>               <span class="token punctuation">}</span>  <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">}</span>                     <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span>                          <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="4-8-3-2-非C风格的数组声明"><a href="#4-8-3-2-非C风格的数组声明" class="headerlink" title="4.8.3.2 非C风格的数组声明"></a>4.8.3.2 非C风格的数组声明</h5><p>中括号是类型的一部分：<code>String[] args</code>， 而非<code>String args[]</code>。</p><h4 id="4-8-4-switch语句"><a href="#4-8-4-switch语句" class="headerlink" title="4.8.4 switch语句"></a>4.8.4 switch语句</h4><p><strong>术语说明</strong>：<code>switch</code>块的大括号内是一个或多个语句组。每个语句组包含一个或多个<code>switch</code>标签(<code>case FOO:</code>或<code>default:</code>)，后面跟着一条或多条语句。</p><h5 id="4-8-4-1-缩进"><a href="#4-8-4-1-缩进" class="headerlink" title="4.8.4.1 缩进"></a>4.8.4.1 缩进</h5><p>和其他语句块一样，<code>switch</code>大括号之后缩进两个字符。每个<code>switch</code>标签之后，后面紧接的非标签的新行，按照大括号相同的处理方式缩进两个字符。在标签结束后，恢复到之前的缩进，类似大括号结束。</p><h5 id="4-8-4-2-继续向下执行的注释"><a href="#4-8-4-2-继续向下执行的注释" class="headerlink" title="4.8.4.2 继续向下执行的注释"></a>4.8.4.2 继续向下执行的注释</h5><p>在一个<code>switch</code>块内，每个语句组要么通过<code>break</code>、<code>continue</code>、<code>return</code>或<code>抛出异常</code>来终止，要么通过一条注释来说明程序将继续执行到下一个语句组，任何能表达这个意思的注释都是可以的(典型的是用<code>// fall through</code>)。这个特殊的注释并不需要在最后一个语句组(一般是<code>default</code>)中出现。例如：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">switch</span> <span class="token punctuation">(</span>input<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">case</span> <span class="token number">1</span><span class="token operator">:</span>    <span class="token keyword">case</span> <span class="token number">2</span><span class="token operator">:</span>        <span class="token function">prepareOneOrTwo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// fall through</span>    <span class="token keyword">case</span> <span class="token number">3</span><span class="token operator">:</span>        <span class="token function">handleOneTwoOrThree</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">break</span><span class="token punctuation">;</span>    <span class="token keyword">default</span><span class="token operator">:</span>        <span class="token function">handleLargeNumber</span><span class="token punctuation">(</span>input<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><strong>注意</strong>：在<code>case 1</code>之后不需要该注释，仅在语句组的末尾。</p></blockquote><h5 id="4-8-4-3-default标签需要显式声明"><a href="#4-8-4-3-default标签需要显式声明" class="headerlink" title="4.8.4.3 default标签需要显式声明"></a>4.8.4.3 default标签需要显式声明</h5><p>每个<code>switch</code>语句中，都需要显式声明<code>default</code>标签。即使没有任何代码也需要显示声明。</p><blockquote><p><strong>注意</strong>：枚举类型的<code>switch</code>语句可以省略<code>default</code>语句组，如果它包含覆盖该类型的所有可能值的显式情况。这使得IDE或其他静态分析工具能够在丢失任何情况时发出警告。</p></blockquote><h4 id="4-8-5-注解"><a href="#4-8-5-注解" class="headerlink" title="4.8.5 注解"></a>4.8.5 注解</h4><p>注解应用到类、方法或者构造方法时，应紧接<code>Javadoc</code>之后。每一行只有一个注解。注解所在行不受列长度限制，也不需要增加缩进。例如：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@Override</span><span class="token annotation punctuation">@Nullable</span><span class="token keyword">public</span> String <span class="token function">getNameIfPresent</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>例外</strong>：如果注解只有一个，并且不带参数。则它可以和类或方法名放在同一行。例如：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@Override</span> <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>注解应用到成员变量时，也是紧接<code>Javadoc</code>之后。不同的是，多个注解可以放在同一行。例如：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@Partial</span> <span class="token annotation punctuation">@Mock</span> DataLoader loader<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>对于参数或者局部变量使用注解的情况，没有特定的规范。</p><h4 id="4-8-6-注释"><a href="#4-8-6-注释" class="headerlink" title="4.8.6 注释"></a>4.8.6 注释</h4><h5 id="4-8-6-1-块注释风格"><a href="#4-8-6-1-块注释风格" class="headerlink" title="4.8.6.1 块注释风格"></a>4.8.6.1 块注释风格</h5><p>注释的缩进与它所注释的代码缩进相同。可以采用<code>/* */</code>进行注释，也可以用<code>//</code>进行注释。当使用<code>/* */</code>进行多行注释时，每一行都应该以<code>*</code>开始，并且<code>*</code>应该上下对齐。</p><p>例如：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">/* * This is * okay. */</span><span class="token comment" spellcheck="true">// And so</span><span class="token comment" spellcheck="true">// is this.</span><span class="token comment" spellcheck="true">/* Or you can * even do this. */</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><strong>注意</strong>：多行注释时，如果你希望集成开发环境能自动对齐注释，你应该使用<code>/* */</code>，<code>//</code>一般不会自动对齐。</p></blockquote><h4 id="4-8-7-修饰符"><a href="#4-8-7-修饰符" class="headerlink" title="4.8.7 修饰符"></a>4.8.7 修饰符</h4><p>类和成员变量的修饰符，按<code>Java Lauguage Specification</code>中介绍的先后顺序排序。具体是：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">protected</span> <span class="token keyword">private</span> <span class="token keyword">abstract</span> <span class="token keyword">default</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">transient</span> <span class="token keyword">volatile</span> <span class="token keyword">synchronized</span> <span class="token keyword">native</span> <span class="token keyword">strictfp</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="4-8-8-数字字面量"><a href="#4-8-8-数字字面量" class="headerlink" title="4.8.8 数字字面量"></a>4.8.8 数字字面量</h4><p>长整型的数字字面量使用大写的<code>L</code>作为后缀，不得使用小写（以免与数字1混淆）。例如：使用<code>3000000000L</code>，而不是<code>3000000000l</code>。</p><h2 id="5-命名约定"><a href="#5-命名约定" class="headerlink" title="5 命名约定"></a>5 命名约定</h2><h3 id="5-1-对所有标识符都通用的规则"><a href="#5-1-对所有标识符都通用的规则" class="headerlink" title="5.1 对所有标识符都通用的规则"></a>5.1 对所有标识符都通用的规则</h3><p>标识符只能使用<code>ASCII</code>字母和数字，因此每个有效的标识符名称都能匹配正则表达式<code>\w+</code>。</p><p>在Google其它编程语言风格中使用的特殊前缀或后缀，如<code>name_</code>, <code>mName</code>, <code>s_name</code>和<code>kName</code>，在Java编程风格中都不再使用。</p><h3 id="5-2-标识符类型的规则"><a href="#5-2-标识符类型的规则" class="headerlink" title="5.2 标识符类型的规则"></a>5.2 标识符类型的规则</h3><h4 id="5-2-1-包名"><a href="#5-2-1-包名" class="headerlink" title="5.2.1 包名"></a>5.2.1 包名</h4><p>包名全部小写，连续的单词只是简单地连接起来，不使用下划线。例如：使用<code>com.example.deepspace</code>，而不是<code>com.example.deepSpace</code>或者<code>com.example.deep_space</code>。</p><h4 id="5-2-2-类名"><a href="#5-2-2-类名" class="headerlink" title="5.2.2 类名"></a>5.2.2 类名</h4><p>类名都以<code>UpperCamelCase</code>风格编写。</p><p>类名通常是名词或名词短语。例如：<code>Character</code>或者<code>ImmutableList</code>。接口名称也可以是名词或名词短语（例如：<code>List</code>），但有时可能是形容词或形容词短语（例如：<code>Readable</code>）。现在还没有特定的规则或行之有效的约定来命名注解类型。</p><p>测试类的命名以它要测试的类的名称开始，以<code>Test</code>结束。例如：<code>HashTest</code>或<code>HashIntegrationTest</code>。</p><h4 id="5-2-3-方法名"><a href="#5-2-3-方法名" class="headerlink" title="5.2.3 方法名"></a>5.2.3 方法名</h4><p>方法名都以<code>lowerCamelCase</code>风格编写。</p><p>方法名通常是动词或动词短语。例如：<code>sendMessage</code>或者<code>stop</code>。</p><p>下划线可能出现在JUnit测试方法名称中用以分隔名称的逻辑组件。一个典型的模式是：<code>test&lt;MethodUnderTest&gt;_&lt;state&gt;</code>，例如：<code>testPop_emptyStack</code>。 并不存在唯一正确的方式来命名测试方法。</p><h4 id="5-2-4-常量名"><a href="#5-2-4-常量名" class="headerlink" title="5.2.4 常量名"></a>5.2.4 常量名</h4><p>常量名命名模式为<code>CONSTANT_CASE</code>，全部字母大写，用下划线分隔单词。那到底什么算是一个常量呢？</p><p>每个常量都是一个静态<code>final</code>字段，其内容是不可变的，且没有可检测的副作用。这包括原始类型、字符串、不可变类型和不可变类型的不可变集合。如果任何一个实例的观测状态是可变的，则它肯定不会是一个常量。只是永远不打算改变对象也是不够的。例如：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 常量</span><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> NUMBER <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span><span class="token keyword">static</span> <span class="token keyword">final</span> ImmutableList<span class="token operator">&lt;</span>String<span class="token operator">></span> NAMES <span class="token operator">=</span> ImmutableList<span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token string">"Ed"</span><span class="token punctuation">,</span> <span class="token string">"Ann"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">static</span> <span class="token keyword">final</span> ImmutableMap<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Integer<span class="token operator">></span> AGES <span class="token operator">=</span> ImmutableMap<span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token string">"Ed"</span><span class="token punctuation">,</span> <span class="token number">35</span><span class="token punctuation">,</span> <span class="token string">"Ann"</span><span class="token punctuation">,</span> <span class="token number">32</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">static</span> <span class="token keyword">final</span> Joiner COMMA_JOINER <span class="token operator">=</span> Joiner<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">','</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 因为Joiner是不可变的</span><span class="token keyword">static</span> <span class="token keyword">final</span> SomeMutableType<span class="token punctuation">[</span><span class="token punctuation">]</span> EMPTY_ARRAY <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">enum</span> SomeEnum <span class="token punctuation">{</span> ENUM_CONSTANT <span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 非常量</span><span class="token keyword">static</span> String nonFinal <span class="token operator">=</span> <span class="token string">"non-final"</span><span class="token punctuation">;</span><span class="token keyword">final</span> String nonStatic <span class="token operator">=</span> <span class="token string">"non-static"</span><span class="token punctuation">;</span><span class="token keyword">static</span> <span class="token keyword">final</span> Set<span class="token operator">&lt;</span>String<span class="token operator">></span> mutableCollection <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashSet</span><span class="token operator">&lt;</span>String<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">static</span> <span class="token keyword">final</span> ImmutableSet<span class="token operator">&lt;</span>SomeMutableType<span class="token operator">></span> mutableElements <span class="token operator">=</span> ImmutableSet<span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span>mutable<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">static</span> <span class="token keyword">final</span> ImmutableMap<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> SomeMutableType<span class="token operator">></span> mutableValues <span class="token operator">=</span>    ImmutableMap<span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token string">"Ed"</span><span class="token punctuation">,</span> mutableInstance<span class="token punctuation">,</span> <span class="token string">"Ann"</span><span class="token punctuation">,</span> mutableInstance2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">static</span> <span class="token keyword">final</span> Logger logger <span class="token operator">=</span> Logger<span class="token punctuation">.</span><span class="token function">getLogger</span><span class="token punctuation">(</span>MyClass<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">static</span> <span class="token keyword">final</span> String<span class="token punctuation">[</span><span class="token punctuation">]</span> nonEmptyArray <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">"these"</span><span class="token punctuation">,</span> <span class="token string">"can"</span><span class="token punctuation">,</span> <span class="token string">"change"</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这些常量的名字通常是名词或名词短语。</p><h4 id="5-2-5-非常量字段名"><a href="#5-2-5-非常量字段名" class="headerlink" title="5.2.5 非常量字段名"></a>5.2.5 非常量字段名</h4><p>非常量字段名以<code>lowerCamelCase</code>风格编写。</p><p>这些名字通常是名词或名词短语。例如：<code>computedValues</code>或者<code>index</code>。</p><h4 id="5-2-6-参数名"><a href="#5-2-6-参数名" class="headerlink" title="5.2.6 参数名"></a>5.2.6 参数名</h4><p>参数名以<code>lowerCamelCase</code>风格编写。</p><p>参数应该避免用单个字符命名。</p><h4 id="5-2-7-局部变量名"><a href="#5-2-7-局部变量名" class="headerlink" title="5.2.7 局部变量名"></a>5.2.7 局部变量名</h4><p>局部变量名以<code>lowerCamelCase</code>风格编写。</p><p>即使局部变量是<code>final</code>和<code>不可改变</code>的，也不应该把它示为常量，当然也就不能用常量的规则去命名它。</p><h4 id="5-2-8-类型变量名"><a href="#5-2-8-类型变量名" class="headerlink" title="5.2.8 类型变量名"></a>5.2.8 类型变量名</h4><p>类型变量可用以下两种风格之一进行命名：</p><ul><li>单个的大写字母，后面可以视具体情况跟一个数字(如：<code>E</code>, <code>T</code>, <code>X</code>, <code>T2</code>)。</li><li>以类命名方式(5.2.2节)，后面加个大写的T(如：<code>RequestT</code>, <code>FooBarT</code>)。</li></ul><h3 id="5-3-驼峰式命名法-CamelCase"><a href="#5-3-驼峰式命名法-CamelCase" class="headerlink" title="5.3 驼峰式命名法(CamelCase)"></a>5.3 驼峰式命名法(CamelCase)</h3><p><strong>驼峰式命名法</strong>分大驼峰式命名法(<code>UpperCamelCase</code>)和小驼峰式命名法(<code>lowerCamelCase</code>)。有时，我们有不只一种合理的方式将一个英语词组转换成驼峰形式，如缩略语或不寻常的结构(例如：<code>IPv6</code>或<code>iOS</code>)。Google指定了以下的转换方案。</p><p>名字从散文形式(prose form)开始:</p><ul><li>把短语转换为纯<code>ASCII</code>码，并且移除任何单引号。例如：<code>Müller’s algorithm</code>将变成<code>Muellers algorithm</code>。</li><li>把这个结果切分成单词，在空格或其它标点符号(通常是连字符)处分割开。<ul><li><strong>推荐</strong>：如果某个单词已经有了常用的驼峰表示形式，按它的组成将它分割开(如<code>AdWords</code>将分割成<code>ad words</code>)。</li><li>需要注意的是iOS并不是一个真正的驼峰表示形式，因此该推荐对它并不适用。</li></ul></li><li>现在将所有字母都小写(包括缩写)，然后将单词的第一个字母大写：<ul><li>每个单词的第一个字母都大写，来得到大驼峰式命名。</li><li>除了第一个单词，每个单词的第一个字母都大写，来得到小驼峰式命名。</li></ul></li><li>最后将所有的单词连接起来得到一个标识符。</li></ul><p>示例：</p><table><thead><tr><th>散文形式</th><th>正确</th><th>不正确</th></tr></thead><tbody><tr><td>“XML HTTP request”</td><td>XmlHttpRequest</td><td>XMLHTTPRequest</td></tr><tr><td>“new customer ID”</td><td>newCustomerId</td><td>newCustomerID</td></tr><tr><td>“inner stopwatch”</td><td>innerStopwatch</td><td>innerStopWatch</td></tr><tr><td>“supports IPv6 on iOS?”</td><td>supportsIpv6OnIos</td><td>supportsIPv6OnIOS</td></tr><tr><td>“YouTube importer”</td><td>YouTubeImporter YoutubeImporter^</td><td>无</td></tr></tbody></table><p>加<code>^</code>号处表示可以，但不推荐。</p><blockquote><p><strong>注意</strong>：在英语中，某些带有连字符的单词形式不唯一。例如：<code>nonempty</code>和<code>non-empty</code>都是正确的，因此方法名<code>checkNonempty</code>和<code>checkNonEmpty</code>也都是正确的。</p></blockquote><h2 id="6-编程实践"><a href="#6-编程实践" class="headerlink" title="6 编程实践"></a>6 编程实践</h2><h3 id="6-1-Override：总是使用"><a href="#6-1-Override：总是使用" class="headerlink" title="6.1 @Override：总是使用"></a>6.1 <code>@Override</code>：总是使用</h3><p>只要是合法的方法，就把<code>@Override</code>注解加上。这包括覆盖超类方法的类方法，实现接口方法的类方法。</p><p><strong>例外</strong>：当父方法为<code>@Deprecated</code>时，可以省略<code>@Override</code>。</p><h3 id="6-2-捕获的异常：不能忽视"><a href="#6-2-捕获的异常：不能忽视" class="headerlink" title="6.2 捕获的异常：不能忽视"></a>6.2 捕获的异常：不能忽视</h3><p>除了下面的例子，对捕获的异常不做任何响应是极少的。(典型的响应方式是打印日志，或者如果它被认为是不可能的，则把它当作一个<code>AssertionError</code>重新抛出。)</p><p>如果它确实是不需要在<code>catch</code>块中做任何响应，需要做注释加以说明(如下面的例子)。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">try</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> i <span class="token operator">=</span> Integer<span class="token punctuation">.</span><span class="token function">parseInt</span><span class="token punctuation">(</span>response<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token function">handleNumericResponse</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">NumberFormatException</span> ok<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 它不是一个数字，不过没关系，继续</span><span class="token punctuation">}</span><span class="token keyword">return</span> <span class="token function">handleTextResponse</span><span class="token punctuation">(</span>response<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>例外：在测试中，如果一个捕获的异常被命名为<code>expected</code>，则它可以被不加注释地忽略。下面是一种非常常见的情形，用以确保所测试的方法会抛出一个期望中的异常， 因此在这里就没有必要加注释。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">try</span> <span class="token punctuation">{</span>    emptyStack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">fail</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">NoSuchElementException</span> expected<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>6.3 静态成员：使用类来调用</p><p>使用类名调用静态的类成员，而不是具体某个对象或表达式。</p><pre class="line-numbers language-java"><code class="language-java">Foo aFoo <span class="token operator">=</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">;</span>Foo<span class="token punctuation">.</span><span class="token function">aStaticMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 好</span>aFoo<span class="token punctuation">.</span><span class="token function">aStaticMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 糟</span><span class="token function">somethingThatYieldsAFoo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">aStaticMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 很糟</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>6.4 <code>Finalizers</code>: 禁用</p><p>极少会去重载<code>Object.finalize</code>。</p><blockquote><p><strong>注意</strong>：不要使用<code>finalize</code>。如果你非要使用它，请先仔细阅读和理解<code>Effective Java第7条款</code>：“Avoid Finalizers”，然后不要使用它。</p></blockquote><h2 id="7-Javadoc"><a href="#7-Javadoc" class="headerlink" title="7 Javadoc"></a>7 Javadoc</h2><h3 id="7-1-格式"><a href="#7-1-格式" class="headerlink" title="7.1 格式"></a>7.1 格式</h3><h4 id="7-1-1-一般形式"><a href="#7-1-1-一般形式" class="headerlink" title="7.1.1 一般形式"></a>7.1.1 一般形式</h4><p><code>Javadoc</code>块的基本格式如下所示：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * Multiple lines of Javadoc text are written here, * wrapped normally... */</span><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">method</span><span class="token punctuation">(</span>String p1<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>或者是以下单行形式：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** An especially short bit of Javadoc. */</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>基本格式总是可以接受的。当整个<code>Javadoc</code>块能容纳于一行时(且没有标记<code>@XXX</code>)，就可以使用单行形式。</p><h4 id="7-1-2-段落"><a href="#7-1-2-段落" class="headerlink" title="7.1.2 段落"></a>7.1.2 段落</h4><p>空行(只包含最左侧星号的行)会出现在段落之间和<code>Javadoc</code>标记(<code>@XXX</code>)之前(如果有的话)。 除了第一个段落，每个段落第一个单词前都有标签<code>&lt;p&gt;</code>，并且它和第一个单词间没有空格。</p><h4 id="7-1-3-Javadoc标记"><a href="#7-1-3-Javadoc标记" class="headerlink" title="7.1.3 Javadoc标记"></a>7.1.3 Javadoc标记</h4><p>标准的<code>Javadoc</code>标记按以下顺序出现：<code>@param</code>, <code>@return</code>, <code>@throws</code>, <code>@deprecated</code>, 前面这4种标记如果出现，描述都不能为空。 当描述无法在一行中容纳，连续行需要至少再缩进<code>4</code>个空格(<strong>注</strong>：如果你的缩进统一采用采用<code>4</code>个空格，那么这里就应该是<code>8</code>个空格)。</p><h4 id="7-2-摘要片段"><a href="#7-2-摘要片段" class="headerlink" title="7.2 摘要片段"></a>7.2 摘要片段</h4><p>每个类或成员的<code>Javadoc</code>以一个简短的摘要片段开始。这个片段是非常重要的，在某些情况下，它是唯一出现的文本，比如在类和方法索引中。</p><p>这只是一个小片段，可以是一个名词短语或动词短语，但不是一个完整的句子。它不会以<code>A {@code Foo} is a...</code>或者<code>This method returns...</code>开头, 它也不会是一个完整的祈使句，如<code>Save the record.</code>。然而，由于开头大写及被加了标点，它看起来就像是个完整的句子。</p><blockquote><p><strong>注意</strong>：一个常见的错误是把简单的Javadoc写成<code>/** @return the customer ID */</code>，这是不正确的。它应该写成<code>/** Returns the customer ID. */</code>。</p></blockquote><h3 id="7-3-在哪里使用Javadoc"><a href="#7-3-在哪里使用Javadoc" class="headerlink" title="7.3 在哪里使用Javadoc"></a>7.3 在哪里使用Javadoc</h3><p>至少在每个<code>public</code>类及它的每个<code>public</code>和<code>protected</code>成员处使用<code>Javadoc</code>，以下是一些例外：</p><h4 id="7-3-1-例外：不言自明的方法"><a href="#7-3-1-例外：不言自明的方法" class="headerlink" title="7.3.1 例外：不言自明的方法"></a>7.3.1 例外：不言自明的方法</h4><p>对于简单明显的方法如<code>getFoo</code>，<code>Javadoc</code>是可选的(可以不写)。这种情况下除了写<code>Returns the foo</code>，确实也没有什么值得写了。</p><p>单元测试类中的测试方法可能是不言自明的最常见例子了，我们通常可以从这些方法的描述性命名中知道它是干什么的，因此不需要额外的文档说明。</p><blockquote><p><strong>注意</strong>：如果有一些相关信息是需要读者了解的，那么以上的例外不应作为忽视这些信息的理由。例如，对于方法名<code>getCanonicalName</code>，就不应该忽视文档说明，因为读者很可能不知道词语<code>canonical name</code>指的是什么。</p></blockquote><h4 id="7-3-2-例外：重载"><a href="#7-3-2-例外：重载" class="headerlink" title="7.3.2 例外：重载"></a>7.3.2 例外：重载</h4><p>如果一个方法重载了超类中的方法，那么<code>Javadoc</code>并非必需的。</p><h4 id="7-3-3-可选的Javadoc"><a href="#7-3-3-可选的Javadoc" class="headerlink" title="7.3.3 可选的Javadoc"></a>7.3.3 可选的Javadoc</h4><p>对于包外不可见的类和方法，如有需要，也是要使用<code>Javadoc</code>的。如果一个注释是用来定义一个类，方法，字段的整体目的或行为， 那么这个注释应该写成<code>Javadoc</code>，这样更统一更友好。</p><p>原文地址: <a href="http://checkstyle.sourceforge.net/reports/google-java-style-20170228.html" target="_blank" rel="noopener">Google Java Style Guide</a></p>]]></content>
      
      
      <categories>
          
          <category> 技术管理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Google </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git 介绍及常用命令清单</title>
      <link href="/2018/092433617.html"/>
      <url>/2018/092433617.html</url>
      
        <content type="html"><![CDATA[<h2 id="一-Git-介绍"><a href="#一-Git-介绍" class="headerlink" title="一. Git  介绍"></a>一. Git  介绍</h2><p>Git是目前世界上最先进的分布式版本控制系统。</p><h3 id="1-、直接记录快照，而非差异比较"><a href="#1-、直接记录快照，而非差异比较" class="headerlink" title="1 、直接记录快照，而非差异比较"></a>1 、直接记录快照，而非差异比较</h3><p>Git 和其它版本控制系统（如 Subversion）的主要差别在于 Git 对待数据的方式。 从概念上来说，其它大部分系统以文件变更列表的方式存储信息，这类系统将它们存储的信息看作是一组基本文件和每个文件随时间逐步累积的差异 （它们通常称作 <strong>基于差异（delta-based）</strong> 的版本控制）。</p><p>Git 不按照以上方式对待或保存数据。反之，Git 更像是把数据看作是对小型文件系统的一系列快照。 在 Git 中，每当你提交更新或保存项目状态时，它基本上就会对当时的全部文件创建一个快照并保存这个快照的索引。 为了效率，如果文件没有修改，Git 不再重新存储该文件，而是只保留一个链接指向之前存储的文件。 Git 对待数据更像是一个 <strong>快照流</strong>。</p><p>这是 Git 与几乎所有其它版本控制系统的重要区别。 因此 Git 重新考虑了以前每一代版本控制系统延续下来的诸多方面。 Git 更像是一个小型的文件系统，提供了许多以此为基础构建的超强工具，而不只是一个简单的 VCS。 </p><h3 id="2、近乎所有操作都是本地执行"><a href="#2、近乎所有操作都是本地执行" class="headerlink" title="2、近乎所有操作都是本地执行"></a>2、近乎所有操作都是本地执行</h3><p>在 Git 中的绝大多数操作都只需要访问本地文件和资源，一般不需要来自网络上其它计算机的信息。因为你在本地磁盘上就有项目的完整历史，所以大部分操作看起来瞬间完成。这也意味着你在离线或者没有 VPN 时，几乎可以进行任何操作。</p><h3 id="3、Git-保证完整性"><a href="#3、Git-保证完整性" class="headerlink" title="3、Git 保证完整性"></a>3、Git 保证完整性</h3><p>Git 中所有的数据在存储前都计算校验和，然后以校验和来引用。 这意味着不可能在 Git 不知情时更改任何文件内容或目录内容。 这个功能建构在 Git 底层，是构成 Git 哲学不可或缺的部分。 </p><h3 id="4、Git-一般只添加数据"><a href="#4、Git-一般只添加数据" class="headerlink" title="4、Git 一般只添加数据"></a>4、Git 一般只添加数据</h3><p>你执行的 Git 操作，几乎只往 Git 数据库中 <strong>添加</strong> 数据。 你很难让 Git 执行任何不可逆操作，或者让它以任何方式清除数据。 这使得我们使用 Git 时可以尽情做各种尝试，而没有把事情弄糟的危险。 更深度探讨 Git 如何保存数据及恢复丢失数据的话题，请参考<a href="https://git-scm.com/book/zh/v2/ch00/_undoing" target="_blank" rel="noopener">撤消操作</a>。</p><h3 id="5、三种状态"><a href="#5、三种状态" class="headerlink" title="5、三种状态"></a>5、三种状态</h3><p> Git 有三种状态，你的文件可能处于其中之一： <strong>已提交（committed）</strong>、<strong>已修改（modified）</strong> 和 <strong>已暂存（staged）</strong>。</p><ul><li>已修改表示修改了文件，但还没保存到数据库中。</li><li>已暂存表示对一个已修改文件的当前版本做了标记，使之包含在下次提交的快照中。</li><li>已提交表示数据已经安全地保存在本地数据库中。</li></ul><p>这会让我们的 Git 项目拥有三个阶段：工作区、暂存区以及 Git 目录。</p><p><img src="../../../static/2020/areas.png" alt="工作区、暂存区以及 Git 目录。"></p><p>工作区是对项目的某个版本独立提取出来的内容。 这些从 Git 仓库的压缩数据库中提取出来的文件，放在磁盘上供你使用或修改。</p><p>暂存区是一个文件，保存了下次将要提交的文件列表信息，一般在 Git 仓库目录中。 按照 Git 的术语叫做“索引”，不过一般说法还是叫“暂存区”。</p><p>Git 仓库目录是 Git 用来保存项目的元数据和对象数据库的地方。 这是 Git 中最重要的部分，从其它计算机克隆仓库时，复制的就是这里的数据。</p><p>基本的 Git 工作流程如下：</p><ol><li>在工作区中修改文件。</li><li>将你想要下次提交的更改选择性地暂存，这样只会将更改的部分添加到暂存区。</li><li>提交更新，找到暂存区的文件，将快照永久性存储到 Git 目录。</li></ol><p>如果 Git 目录中保存着特定版本的文件，就属于 <strong>已提交</strong> 状态。 如果文件已修改并放入暂存区，就属于 <strong>已暂存</strong> 状态。 如果自上次检出后，作了修改但还没有放到暂存区域，就是 <strong>已修改</strong> 状态。</p><h2 id="二、Git-常用命令"><a href="#二、Git-常用命令" class="headerlink" title="二、Git 常用命令"></a>二、Git 常用命令</h2><p>一般来说，日常使用只要记住下图6个命令，就可以了。</p><p><img src="../../../static/2020/bg2015120901.png" alt="Git最常用6个命令使用示意"></p><p>几个专用名词：</p><ul><li>Workspace：工作区</li><li>Index / Stage：暂存区</li><li>Repository：仓库区（或本地仓库）</li><li>Remote：远程仓库</li></ul><h3 id="1、新建代码库"><a href="#1、新建代码库" class="headerlink" title="1、新建代码库"></a>1、新建代码库</h3><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 在当前目录新建一个Git代码库</span>$ <span class="token function">git</span> init<span class="token comment" spellcheck="true"># 新建一个目录，将其初始化为Git代码库</span>$ <span class="token function">git</span> init <span class="token punctuation">[</span>project-name<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># 下载一个项目和它的整个代码历史</span>$ <span class="token function">git</span> clone <span class="token punctuation">[</span>url<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2、配置"><a href="#2、配置" class="headerlink" title="2、配置"></a>2、配置</h3><p>Git的设置文件为<code>.gitconfig</code>，它可以在用户主目录下（全局配置），也可以在项目目录下（项目配置）。</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 显示当前的Git配置</span>$ <span class="token function">git</span> config --list<span class="token comment" spellcheck="true"># 编辑Git配置文件</span>$ <span class="token function">git</span> config -e <span class="token punctuation">[</span>--global<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># 设置提交代码时的用户信息</span>$ <span class="token function">git</span> config <span class="token punctuation">[</span>--global<span class="token punctuation">]</span> user.name <span class="token string">"[name]"</span>$ <span class="token function">git</span> config <span class="token punctuation">[</span>--global<span class="token punctuation">]</span> user.email <span class="token string">"[email address]"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3、增加-删除文件"><a href="#3、增加-删除文件" class="headerlink" title="3、增加/删除文件"></a>3、增加/删除文件</h3><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 添加指定文件到暂存区</span>$ <span class="token function">git</span> add <span class="token punctuation">[</span>file1<span class="token punctuation">]</span> <span class="token punctuation">[</span>file2<span class="token punctuation">]</span> <span class="token punctuation">..</span>.<span class="token comment" spellcheck="true"># 添加指定目录到暂存区，包括子目录</span>$ <span class="token function">git</span> add <span class="token punctuation">[</span>dir<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># 添加当前目录的所有文件到暂存区</span>$ <span class="token function">git</span> add <span class="token keyword">.</span><span class="token comment" spellcheck="true"># 添加每个变化前，都会要求确认</span><span class="token comment" spellcheck="true"># 对于同一个文件的多处变化，可以实现分次提交</span>$ <span class="token function">git</span> add -p<span class="token comment" spellcheck="true"># 删除工作区文件，并且将这次删除放入暂存区</span>$ <span class="token function">git</span> <span class="token function">rm</span> <span class="token punctuation">[</span>file1<span class="token punctuation">]</span> <span class="token punctuation">[</span>file2<span class="token punctuation">]</span> <span class="token punctuation">..</span>.<span class="token comment" spellcheck="true"># 停止追踪指定文件，但该文件会保留在工作区</span>$ <span class="token function">git</span> <span class="token function">rm</span> --cached <span class="token punctuation">[</span>file<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># 改名文件，并且将这个改名放入暂存区</span>$ <span class="token function">git</span> <span class="token function">mv</span> <span class="token punctuation">[</span>file-original<span class="token punctuation">]</span> <span class="token punctuation">[</span>file-renamed<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4、代码提交"><a href="#4、代码提交" class="headerlink" title="4、代码提交"></a>4、代码提交</h3><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 提交暂存区到仓库区</span>$ <span class="token function">git</span> commit -m <span class="token punctuation">[</span>message<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># 提交暂存区的指定文件到仓库区</span>$ <span class="token function">git</span> commit <span class="token punctuation">[</span>file1<span class="token punctuation">]</span> <span class="token punctuation">[</span>file2<span class="token punctuation">]</span> <span class="token punctuation">..</span>. -m <span class="token punctuation">[</span>message<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># 提交工作区自上次commit之后的变化，直接到仓库区</span>$ <span class="token function">git</span> commit -a<span class="token comment" spellcheck="true"># 提交时显示所有diff信息</span>$ <span class="token function">git</span> commit -v<span class="token comment" spellcheck="true"># 使用一次新的commit，替代上一次提交</span><span class="token comment" spellcheck="true"># 如果代码没有任何新变化，则用来改写上一次commit的提交信息</span>$ <span class="token function">git</span> commit --amend -m <span class="token punctuation">[</span>message<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># 重做上一次commit，并包括指定文件的新变化</span>$ <span class="token function">git</span> commit --amend <span class="token punctuation">[</span>file1<span class="token punctuation">]</span> <span class="token punctuation">[</span>file2<span class="token punctuation">]</span> <span class="token punctuation">..</span>.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="5、分支"><a href="#5、分支" class="headerlink" title="5、分支"></a>5、分支</h3><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 列出所有本地分支</span>$ <span class="token function">git</span> branch<span class="token comment" spellcheck="true"># 列出所有远程分支</span>$ <span class="token function">git</span> branch -r<span class="token comment" spellcheck="true"># 列出所有本地分支和远程分支</span>$ <span class="token function">git</span> branch -a<span class="token comment" spellcheck="true"># 新建一个分支，但依然停留在当前分支</span>$ <span class="token function">git</span> branch <span class="token punctuation">[</span>branch-name<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># 新建一个分支，并切换到该分支</span>$ <span class="token function">git</span> checkout -b <span class="token punctuation">[</span>branch<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># 新建一个分支，指向指定commit</span>$ <span class="token function">git</span> branch <span class="token punctuation">[</span>branch<span class="token punctuation">]</span> <span class="token punctuation">[</span>commit<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># 新建一个分支，与指定的远程分支建立追踪关系</span>$ <span class="token function">git</span> branch --track <span class="token punctuation">[</span>branch<span class="token punctuation">]</span> <span class="token punctuation">[</span>remote-branch<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># 切换到指定分支，并更新工作区</span>$ <span class="token function">git</span> checkout <span class="token punctuation">[</span>branch-name<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># 切换到上一个分支</span>$ <span class="token function">git</span> checkout -<span class="token comment" spellcheck="true"># 建立追踪关系，在现有分支与指定的远程分支之间</span>$ <span class="token function">git</span> branch --set-upstream <span class="token punctuation">[</span>branch<span class="token punctuation">]</span> <span class="token punctuation">[</span>remote-branch<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># 合并指定分支到当前分支</span>$ <span class="token function">git</span> merge <span class="token punctuation">[</span>branch<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># 选择一个commit，合并进当前分支</span>$ <span class="token function">git</span> cherry-pick <span class="token punctuation">[</span>commit<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># 删除分支</span>$ <span class="token function">git</span> branch -d <span class="token punctuation">[</span>branch-name<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># 删除远程分支</span>$ <span class="token function">git</span> push origin --delete <span class="token punctuation">[</span>branch-name<span class="token punctuation">]</span>$ <span class="token function">git</span> branch -dr <span class="token punctuation">[</span>remote/branch<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="6、标签"><a href="#6、标签" class="headerlink" title="6、标签"></a>6、标签</h3><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 列出所有tag</span>$ <span class="token function">git</span> tag<span class="token comment" spellcheck="true"># 新建一个tag在当前commit</span>$ <span class="token function">git</span> tag <span class="token punctuation">[</span>tag<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># 新建一个tag在指定commit</span>$ <span class="token function">git</span> tag <span class="token punctuation">[</span>tag<span class="token punctuation">]</span> <span class="token punctuation">[</span>commit<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># 删除本地tag</span>$ <span class="token function">git</span> tag -d <span class="token punctuation">[</span>tag<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># 删除远程tag</span>$ <span class="token function">git</span> push origin :refs/tags/<span class="token punctuation">[</span>tagName<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># 查看tag信息</span>$ <span class="token function">git</span> show <span class="token punctuation">[</span>tag<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># 提交指定tag</span>$ <span class="token function">git</span> push <span class="token punctuation">[</span>remote<span class="token punctuation">]</span> <span class="token punctuation">[</span>tag<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># 提交所有tag</span>$ <span class="token function">git</span> push <span class="token punctuation">[</span>remote<span class="token punctuation">]</span> --tags<span class="token comment" spellcheck="true"># 新建一个分支，指向某个tag</span>$ <span class="token function">git</span> checkout -b <span class="token punctuation">[</span>branch<span class="token punctuation">]</span> <span class="token punctuation">[</span>tag<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="7、查看信息"><a href="#7、查看信息" class="headerlink" title="7、查看信息"></a>7、查看信息</h3><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 显示有变更的文件</span>$ <span class="token function">git</span> status<span class="token comment" spellcheck="true"># 显示当前分支的版本历史</span>$ <span class="token function">git</span> log<span class="token comment" spellcheck="true"># 显示commit历史，以及每次commit发生变更的文件</span>$ <span class="token function">git</span> log --stat<span class="token comment" spellcheck="true"># 搜索提交历史，根据关键词</span>$ <span class="token function">git</span> log -S <span class="token punctuation">[</span>keyword<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># 显示某个commit之后的所有变动，每个commit占据一行</span>$ <span class="token function">git</span> log <span class="token punctuation">[</span>tag<span class="token punctuation">]</span> HEAD --pretty<span class="token operator">=</span>format:%s<span class="token comment" spellcheck="true"># 显示某个commit之后的所有变动，其"提交说明"必须符合搜索条件</span>$ <span class="token function">git</span> log <span class="token punctuation">[</span>tag<span class="token punctuation">]</span> HEAD --grep feature<span class="token comment" spellcheck="true"># 显示某个文件的版本历史，包括文件改名</span>$ <span class="token function">git</span> log --follow <span class="token punctuation">[</span>file<span class="token punctuation">]</span>$ <span class="token function">git</span> whatchanged <span class="token punctuation">[</span>file<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># 显示指定文件相关的每一次diff</span>$ <span class="token function">git</span> log -p <span class="token punctuation">[</span>file<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># 显示过去5次提交</span>$ <span class="token function">git</span> log -5 --pretty --oneline<span class="token comment" spellcheck="true"># 显示所有提交过的用户，按提交次数排序</span>$ <span class="token function">git</span> shortlog -sn<span class="token comment" spellcheck="true"># 显示指定文件是什么人在什么时间修改过</span>$ <span class="token function">git</span> blame <span class="token punctuation">[</span>file<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># 显示暂存区和工作区的差异</span>$ <span class="token function">git</span> <span class="token function">diff</span><span class="token comment" spellcheck="true"># 显示暂存区和上一个commit的差异</span>$ <span class="token function">git</span> <span class="token function">diff</span> --cached <span class="token punctuation">[</span>file<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># 显示工作区与当前分支最新commit之间的差异</span>$ <span class="token function">git</span> <span class="token function">diff</span> HEAD<span class="token comment" spellcheck="true"># 显示两次提交之间的差异</span>$ <span class="token function">git</span> <span class="token function">diff</span> <span class="token punctuation">[</span>first-branch<span class="token punctuation">]</span><span class="token punctuation">..</span>.<span class="token punctuation">[</span>second-branch<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># 显示今天你写了多少行代码</span>$ <span class="token function">git</span> <span class="token function">diff</span> --shortstat <span class="token string">"@{0 day ago}"</span><span class="token comment" spellcheck="true"># 显示某次提交的元数据和内容变化</span>$ <span class="token function">git</span> show <span class="token punctuation">[</span>commit<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># 显示某次提交发生变化的文件</span>$ <span class="token function">git</span> show --name-only <span class="token punctuation">[</span>commit<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># 显示某次提交时，某个文件的内容</span>$ <span class="token function">git</span> show <span class="token punctuation">[</span>commit<span class="token punctuation">]</span>:<span class="token punctuation">[</span>filename<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># 显示当前分支的最近几次提交</span>$ <span class="token function">git</span> reflog<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="8、远程同步"><a href="#8、远程同步" class="headerlink" title="8、远程同步"></a>8、远程同步</h3><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 下载远程仓库的所有变动</span>$ <span class="token function">git</span> fetch <span class="token punctuation">[</span>remote<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># 显示所有远程仓库</span>$ <span class="token function">git</span> remote -v<span class="token comment" spellcheck="true"># 显示某个远程仓库的信息</span>$ <span class="token function">git</span> remote show <span class="token punctuation">[</span>remote<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># 增加一个新的远程仓库，并命名</span>$ <span class="token function">git</span> remote add <span class="token punctuation">[</span>shortname<span class="token punctuation">]</span> <span class="token punctuation">[</span>url<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># 取回远程仓库的变化，并与本地分支合并</span>$ <span class="token function">git</span> pull <span class="token punctuation">[</span>remote<span class="token punctuation">]</span> <span class="token punctuation">[</span>branch<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># 上传本地指定分支到远程仓库</span>$ <span class="token function">git</span> push <span class="token punctuation">[</span>remote<span class="token punctuation">]</span> <span class="token punctuation">[</span>branch<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># 强行推送当前分支到远程仓库，即使有冲突</span>$ <span class="token function">git</span> push <span class="token punctuation">[</span>remote<span class="token punctuation">]</span> --force<span class="token comment" spellcheck="true"># 推送所有分支到远程仓库</span>$ <span class="token function">git</span> push <span class="token punctuation">[</span>remote<span class="token punctuation">]</span> --all<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="9、撤销"><a href="#9、撤销" class="headerlink" title="9、撤销"></a>9、撤销</h3><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 恢复暂存区的指定文件到工作区</span>$ <span class="token function">git</span> checkout <span class="token punctuation">[</span>file<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># 恢复某个commit的指定文件到暂存区和工作区</span>$ <span class="token function">git</span> checkout <span class="token punctuation">[</span>commit<span class="token punctuation">]</span> <span class="token punctuation">[</span>file<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># 恢复暂存区的所有文件到工作区</span>$ <span class="token function">git</span> checkout <span class="token keyword">.</span><span class="token comment" spellcheck="true"># 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变</span>$ <span class="token function">git</span> reset <span class="token punctuation">[</span>file<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># 重置暂存区与工作区，与上一次commit保持一致</span>$ <span class="token function">git</span> reset --hard<span class="token comment" spellcheck="true"># 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变</span>$ <span class="token function">git</span> reset <span class="token punctuation">[</span>commit<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致</span>$ <span class="token function">git</span> reset --hard <span class="token punctuation">[</span>commit<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># 重置当前HEAD为指定commit，但保持暂存区和工作区不变</span>$ <span class="token function">git</span> reset --keep <span class="token punctuation">[</span>commit<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># 新建一个commit，用来撤销指定commit</span><span class="token comment" spellcheck="true"># 后者的所有变化都将被前者抵消，并且应用到当前分支</span>$ <span class="token function">git</span> revert <span class="token punctuation">[</span>commit<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># 暂时将未提交的变化移除，稍后再移入</span>$ <span class="token function">git</span> stash$ <span class="token function">git</span> stash pop<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://git-scm.com/book/zh/v2" target="_blank" rel="noopener">Pro Git book</a></li><li><a href="https://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html" target="_blank" rel="noopener">常用 Git 命令清单</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 软件工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>状态模式（State Pattern）</title>
      <link href="/2018/092123773.html"/>
      <url>/2018/092123773.html</url>
      
        <content type="html"><![CDATA[<h2 id="一、模式动机"><a href="#一、模式动机" class="headerlink" title="一、模式动机"></a>一、模式动机</h2><p>在很多情况下，一个对象的行为取决于一个或多个动态变化的属性，这样的属性叫做状态，这样的对象叫做有状态的(<code>stateful</code>)对象，这样的对象状态是从事先定义好的一系列值中取出的。当一个这样的对象与外部事件产生互动时，其内部状态就会改变，从而使得系统的行为也随之发生变化。</p><h2 id="二、模式定义"><a href="#二、模式定义" class="headerlink" title="二、模式定义"></a>二、模式定义</h2><blockquote><p><strong>状态模式(<code>State Pattern</code>)</strong>：允许一个对象在其内部状态改变时改变它的行为，对象看起来似乎修改了它的类。其别名为状态对象(<code>Objects for States</code>)，状态模式是一种对象行为型模式。</p></blockquote><h2 id="三、模式结构"><a href="#三、模式结构" class="headerlink" title="三、模式结构"></a>三、模式结构</h2><h3 id="1-角色组成："><a href="#1-角色组成：" class="headerlink" title="1. 角色组成："></a>1. 角色组成：</h3><p>状态模式包含如下角色：</p><ul><li><code>Context</code>: 环境类</li><li><code>State</code>: 抽象状态角色</li><li><code>ConcreteState</code>: 具体状态角色类</li></ul><h3 id="2-结构图"><a href="#2-结构图" class="headerlink" title="2. 结构图"></a>2. 结构图</h3><p><img src="https://pic.lixl.cn/2019/State.jpg" alt="状态模式结构图"></p><h3 id="3-时序图"><a href="#3-时序图" class="headerlink" title="3. 时序图"></a>3. 时序图</h3><p><img src="https://pic.lixl.cn/2019/seq_State.jpg" alt="状态模式时序图"></p><h2 id="四、示例代码"><a href="#四、示例代码" class="headerlink" title="四、示例代码"></a>四、示例代码</h2><p>首先，是抽象的状态角色接口：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 抽象状态角色 * */</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">IState</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 抽象方法1     */</span>    <span class="token keyword">void</span> <span class="token function">handle1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * 抽象方法2     */</span>    <span class="token keyword">void</span> <span class="token function">handle2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>接下来，是多个具体的状态角色类，分别如下：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 具体状态角色类1 * */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConcreteState1</span> <span class="token keyword">implements</span> <span class="token class-name">IState</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 具体状态角色类1中的方法1     */</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">handle1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"执行了具体状态角色类1中的方法1..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 具体状态角色类1中的方法2     */</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">handle2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"执行了具体状态角色类1中的方法2..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 具体状态角色类2 * */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConcreteState2</span> <span class="token keyword">implements</span> <span class="token class-name">IState</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 具体状态角色类2中的方法1     */</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">handle1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"执行了具体状态角色类2中的方法1..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 具体状态角色类2中的方法2     */</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">handle2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"执行了具体状态角色类2中的方法2..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后，是环境类：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 环境角色类 * */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Context</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 当前状态</span>    <span class="token keyword">private</span> IState state<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * 构造方法     * @param state     */</span>    <span class="token keyword">public</span> <span class="token function">Context</span><span class="token punctuation">(</span>IState state<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>state <span class="token operator">=</span> state<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 方法1     */</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">handle1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">.</span><span class="token function">handle1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 方法2     */</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">handle2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">.</span><span class="token function">handle2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>最后，是用于测试状态模式的客户端场景类：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 状态模式的客户端场景累 * */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">StateClient</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Context context <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Context</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ConcreteState1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        context<span class="token punctuation">.</span><span class="token function">handle1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        context<span class="token punctuation">.</span><span class="token function">handle2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="五、模式分析"><a href="#五、模式分析" class="headerlink" title="五、模式分析"></a>五、模式分析</h2><ul><li>状态模式描述了对象状态的变化以及对象如何在每一种状态下表现出不同的行为。</li><li>状态模式的关键是引入了一个抽象接口来专门表示对象的状态，这个类我们叫做抽象状态接口，而对象的每一种具体状态类都实现了该类，并在不同具体状态类中实现了不同状态的行为，包括各种状态之间的转换。</li></ul><p>在状态模式结构中需要理解环境类与抽象状态类的作用：</p><ul><li>环境类实际上就是拥有状态的对象，环境类有时候可以充当状态管理器(State Manager)的角色，可以在环境类中对状态进行切换操作。</li><li>抽象状态类可以是抽象类，也可以是接口，不同状态类就是继承这个父类的不同子类，状态类的产生是由于环境类存在多个状态，同时还满足两个条件： 这些状态经常需要切换，在不同的状态下对象的行为不同。因此可以将不同对象下的行为单独提取出来封装在具体的状态类中，使得环境类对象在其内部状态改变时可以改变它的行为，对象看起来似乎修改了它的类，而实际上是由于切换到不同的具体状态类实现的。由于环境类可以设置为任一具体状态类，因此它针对抽象状态类进行编程，在程序运行时可以将任一具体状态类的对象设置到环境类中，从而使得环境类可以改变内部状态，并且改变行为。</li></ul><h3 id="1-优点"><a href="#1-优点" class="headerlink" title="1. 优点"></a>1. 优点</h3><p>状态模式的优点：</p><ul><li>封装了转换规则。</li><li>枚举可能的状态，在枚举状态之前需要确定状态种类。</li><li>将所有与某个状态有关的行为放到一个类中，并且可以方便地增加新的状态，只需要改变对象状态即可改变对象的行为。</li><li>允许状态转换逻辑与状态对象合成一体，而不是某一个巨大的条件语句块。</li><li>可以让多个环境对象共享一个状态对象，从而减少系统中对象的个数。</li></ul><h3 id="2-缺点"><a href="#2-缺点" class="headerlink" title="2. 缺点"></a>2. 缺点</h3><p>状态模式的缺点：</p><ul><li>状态模式的使用必然会增加系统类和对象的个数。</li><li>状态模式的结构与实现都较为复杂，如果使用不当将导致程序结构和代码的混乱。</li><li>状态模式对“开闭原则”的支持并不太好，对于可以切换状态的状态模式，增加新的状态类需要修改那些负责状态转换的源代码，否则无法切换到新增状态；而且修改某个状态类的行为也需修改对应类的源代码。</li></ul><h3 id="3-适用环境"><a href="#3-适用环境" class="headerlink" title="3.适用环境"></a>3.适用环境</h3><p>在以下情况下可以使用状态模式：</p><ul><li>对象的行为依赖于它的状态（属性）并且可以根据它的状态改变而改变它的相关行为。</li><li>代码中包含大量与对象状态有关的条件语句，这些条件语句的出现，会导致代码的可维护性和灵活性变差，不能方便地增加和删除状态，使客户类与类库之间的耦合增强。在这些条件语句中包含了对象的行为，而且这些条件对应于对象的各种状态。</li></ul><blockquote><p>状态模式在工作流或游戏等类型的软件中得以广泛使用，甚至可以用于这些系统的核心功能设计，如在政府OA办公系统中，一个批文的状态有多种：尚未办理；正在办理；正在批示；正在审核；已经完成等各种状态，而且批文状态不同时对批文的操作也有所差异。使用状态模式可以描述工作流对象（如批文）的状态转换以及不同状态下它所具有的行为。</p></blockquote><h2 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h2><ul><li>状态模式允许一个对象在其内部状态改变时改变它的行为，对象看起来似乎修改了它的类。其别名为状态对象，状态模式是一种对象行为型模式。</li><li>状态模式包含三个角色：环境类又称为上下文类，它是拥有状态的对象，在环境类中维护一个抽象状态类State的实例，这个实例定义当前状态，在具体实现时，它是一个State子类的对象，可以定义初始状态；抽象状态类用于定义一个接口以封装与环境类的一个特定状态相关的行为；具体状态类是抽象状态类的子类，每一个子类实现一个与环境类的一个状态相关的行为，每一个具体状态类对应环境的一个具体状态，不同的具体状态类其行为有所不同。</li><li>状态模式描述了对象状态的变化以及对象如何在每一种状态下表现出不同的行为。</li><li>状态模式的主要优点在于封装了转换规则，并枚举可能的状态，它将所有与某个状态有关的行为放到一个类中，并且可以方便地增加新的状态，只需要改变对象状态即可改变对象的行为，还可以让多个环境对象共享一个状态对象，从而减少系统中对象的个数；其缺点在于使用状态模式会增加系统类和对象的个数，且状态模式的结构与实现都较为复杂，如果使用不当将导致程序结构和代码的混乱，对于可以切换状态的状态模式不满足“开闭原则”的要求。</li><li>状态模式适用情况包括：对象的行为依赖于它的状态（属性）并且可以根据它的状态改变而改变它的相关行为；代码中包含大量与对象状态有关的条件语句，这些条件语句的出现，会导致代码的可维护性和灵活性变差，不能方便地增加和删除状态，使客户类与类库之间的耦合增强。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 软件设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 设计原则与模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>代理模式（Proxy Pattern）</title>
      <link href="/2018/092032073.html"/>
      <url>/2018/092032073.html</url>
      
        <content type="html"><![CDATA[<h2 id="一、模式动机"><a href="#一、模式动机" class="headerlink" title="一、模式动机"></a>一、模式动机</h2><p>在某些情况下，一个客户不想或者不能直接引用一个对象，此时可以通过一个称之为“代理”的第三者来实现间接引用。代理对象可以在客户端和目标对象之间起到中介的作用，并且可以通过代理对象去掉客户不能看到 的内容和服务或者添加客户需要的额外服务。</p><p>通过引入一个新的对象来实现对真实对象的操作或者将新的对象作为真实对象的一个替身，这种实现机制即为代理模式，通过引入代理对象来间接访问一个对象，这就是代理模式的模式动机。</p><h2 id="二、模式定义"><a href="#二、模式定义" class="headerlink" title="二、模式定义"></a>二、模式定义</h2><blockquote><p><strong>代理模式(<code>Proxy Pattern</code>)</strong>：给某一个对象提供一个代理，并由代理对象控制对原对象的引用。代理模式的英文叫做<code>Proxy</code>或<code>Surrogate</code>，它是一种对象结构型模式。</p></blockquote><h2 id="三、模式结构"><a href="#三、模式结构" class="headerlink" title="三、模式结构"></a>三、模式结构</h2><h3 id="1-角色组成"><a href="#1-角色组成" class="headerlink" title="1. 角色组成"></a>1. 角色组成</h3><p>代理模式包含如下角色：</p><ul><li><code>Subject</code>: 抽象主题角色</li><li><code>RealSubject</code>: 真实主题角色</li><li><code>Proxy</code>: 代理主题角色</li></ul><h3 id="2-结构图"><a href="#2-结构图" class="headerlink" title="2. 结构图"></a>2. 结构图</h3><p><img src="https://pic.lixl.cn/2019/Proxy.jpg" alt="代理模式结构图"></p><h2 id="四、示例代码"><a href="#四、示例代码" class="headerlink" title="四、示例代码"></a>四、示例代码</h2><p>首先，是抽象的主题接口和真实主题类：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>blinkfox<span class="token punctuation">.</span>patterns<span class="token punctuation">.</span>proxy<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * 抽象主题类 */</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">ISubject</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 定义一个方法     */</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">request</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>blinkfox<span class="token punctuation">.</span>patterns<span class="token punctuation">.</span>proxy<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * 真实主题类 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">RealSubject</span> <span class="token keyword">implements</span> <span class="token class-name">ISubject</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 实现方法     */</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">request</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"真实主题类请求方法..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后，是代理类：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>blinkfox<span class="token punctuation">.</span>patterns<span class="token punctuation">.</span>proxy<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * 代理类 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Proxy</span> <span class="token keyword">implements</span> <span class="token class-name">ISubject</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> ISubject subject<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">Proxy</span><span class="token punctuation">(</span>ISubject subject<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>subject <span class="token operator">=</span> subject<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">request</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">before</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>subject<span class="token punctuation">.</span><span class="token function">request</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">after</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 预处理     */</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">before</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"执行前(before)的处理..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 善后处理     */</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">after</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"执行后(after)的处理..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>最后，是客户端场景测试类：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>blinkfox<span class="token punctuation">.</span>patterns<span class="token punctuation">.</span>proxy<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * 代理模式客户端场景类 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ProxyClient</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        ISubject subject <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">RealSubject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Proxy proxy <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Proxy</span><span class="token punctuation">(</span>subject<span class="token punctuation">)</span><span class="token punctuation">;</span>        proxy<span class="token punctuation">.</span><span class="token function">request</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="五、模式分析"><a href="#五、模式分析" class="headerlink" title="五、模式分析"></a>五、模式分析</h2><h3 id="1-优点"><a href="#1-优点" class="headerlink" title="1. 优点"></a>1. 优点</h3><p>代理模式的优点：</p><ul><li>代理模式能够协调调用者和被调用者，在一定程度上降低了系 统的耦合度。</li><li>远程代理使得客户端可以访问在远程机器上的对象，远程机器可能具有更好的计算性能与处理速度，可以快速响应并处理客户端请求。</li><li>虚拟代理通过使用一个小对象来代表一个大对象，可以减少系统资源的消耗，对系统进行优化并提高运行速度。</li><li>保护代理可以控制对真实对象的使用权限。</li></ul><h3 id="2-缺点"><a href="#2-缺点" class="headerlink" title="2. 缺点"></a>2. 缺点</h3><p>代理模式的缺点：</p><ul><li>由于在客户端和真实主题之间增加了代理对象，因此有些类型的代理模式可能会造成请求的处理速度变慢。</li><li>实现代理模式需要额外的工作，有些代理模式的实现非常复杂。</li></ul><h3 id="3-适用环境"><a href="#3-适用环境" class="headerlink" title="3. 适用环境"></a>3. 适用环境</h3><p>根据代理模式的使用目的，常见的代理模式有以下几种类型：</p><ul><li><strong>远程(Remote)代理</strong>：为一个位于不同的地址空间的对象提供一个本地的代理对象，这个不同的地址空间可以是在同一台主机中，也可是在另一台主机中，远程代理又叫做大使(Ambassador)。</li><li><strong>虚拟(Virtual)代理</strong>：如果需要创建一个资源消耗较大的对象，先创建一个消耗相对较小的对象来表示，真实对象只在需要时才会被真正创建。</li><li><strong>Copy-on-Write 代理</strong>：它是虚拟代理的一种，把复制（克隆）操作延迟 到只有在客户端真正需要时才执行。一般来说，对象的深克隆是一个开销较大的操作，Copy-on-Write 代理可以让这个操作延迟，只有对象被用到的时候才被克隆。</li><li><strong>保护(Protect or Access)代理</strong>：控制对一个对象的访问，可以给不同的用户提供不同级别的使用权限。</li><li><strong>缓冲(Cache)代理</strong>：为某一个目标操作的结果提供临时的存储空间，以便多个客户端可以共享这些结果。</li><li><strong>防火墙(Firewall)代理</strong>：保护目标不让恶意用户接近。</li><li><strong>同步化(Synchronization)代理</strong>：使几个用户能够同时使用一个对象而没有冲突。</li><li><strong>智能引用(Smart Reference)代理</strong>：当一个对象被引用时，提供一些额外的操作，如将此对象被调用的次数记录下来等。</li></ul><h2 id="模式总结"><a href="#模式总结" class="headerlink" title="模式总结"></a>模式总结</h2><ul><li>在代理模式中，要求给某一个对象提供一个代理，并由代理对象控制对原对象的引用。代理模式的英文叫做 Proxy 或 Surrogate，它是一种对象结构型模式。</li><li>代理模式包含三个角色：抽象主题角色声明了真实主题和代理主题的共同接口；代理主题角色内部包含对真实主题的引用，从而可以在任何时候操作真实主题对象；真实主题角色定义了代理角色所代表的真实对象，在真实主题角色中实现了真实的业务操作，客户端可以通过代理主题角色间接调用真实主题角色中定义的方法。</li><li>代理模式的优点在于能够协调调用者和被调用者，在一定程度上降低了系统的耦合度；其缺点在于由于在客户端和真实主题之间增加了代理对象，因此有些类型的代理模式可能会造成请求的处理速度变慢，并且实现代理模式需要额外的工作，有些代理模式的实现非常复杂。远程代理为一个位于不同的地址空间的对象提供一个本地的代表对象，它使得客户端可以访问在远程机器上的对象，远程机器可能具有更好的计算性能与处理速度，可以快速响应并处理客户端请求。</li><li>如果需要创建一个资源消耗较大的对象，先创建一个消耗相对较小的对象来表示，真实对象只在需要时才会被真正创建，这个小对象称为虚拟代理。虚拟代理通过使用一个小对象来代表一个大对象，可以减少系统资源的消耗，对系统进行优化并提高运行速度。</li><li>保护代理可以控制对一个对象的访问，可以给不同的用户提供不同级别的使用权限。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 软件设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 设计原则与模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>工厂模式（Factory Pattern）</title>
      <link href="/2018/091449719.html"/>
      <url>/2018/091449719.html</url>
      
        <content type="html"><![CDATA[<h2 id="一、模式定义"><a href="#一、模式定义" class="headerlink" title="一、模式定义"></a>一、模式定义</h2><p>工厂方法模式(<code>Factory Method Pattern</code>)又称为工厂模式，也叫虚拟构造器(Virtual Constructor)模式或者多态工厂(Polymorphic Factory)模式，它属于类创建型模式。在工厂方法模式中，工厂父类负责定义创建产品对象的公共接口，而工厂子类则负责生成具体的产品对象，这样做的目的是将产品类的实例化操作延迟到工厂子类中完成，即通过工厂子类来确定究竟应该实例化哪一个具体产品类。</p><h2 id="二、模式结构"><a href="#二、模式结构" class="headerlink" title="二、模式结构"></a>二、模式结构</h2><h3 id="1-角色组成"><a href="#1-角色组成" class="headerlink" title="1. 角色组成"></a>1. 角色组成</h3><p>工厂方法模式包含如下角色：</p><ul><li><code>Product</code>：抽象产品</li><li><code>ConcreteProduct</code>：具体产品</li><li><code>Factory</code>：抽象工厂</li><li><code>ConcreteFactory</code>：具体工厂</li></ul><h3 id="2-结构图"><a href="#2-结构图" class="headerlink" title="2. 结构图"></a>2. 结构图</h3><p><img src="https://pic.lixl.cn/2019/FactoryMethod.jpg" alt="工厂方法模式结构图"></p><h3 id="3-时序图"><a href="#3-时序图" class="headerlink" title="3. 时序图"></a>3. 时序图</h3><p><img src="https://pic.lixl.cn/2019/seq_FactoryMethod.jpg" alt="工厂方法模式时序图"></p><h2 id="三、示例代码"><a href="#三、示例代码" class="headerlink" title="三、示例代码"></a>三、示例代码</h2><p>首先，是抽象的产品类和具体的产品类：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 抽象产品类 * */</span><span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">Product</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 产品类的公共方法     */</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">method1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"这是产品类的公共方法"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 抽象方法     */</span>    <span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">void</span> <span class="token function">method2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 具体产品类1 * */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConcreteProduct1</span> <span class="token keyword">extends</span> <span class="token class-name">Product</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">method2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"ConcreteProduct1的method2方法"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 具体产品类2 * */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConcreteProduct2</span> <span class="token keyword">extends</span> <span class="token class-name">Product</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">method2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"ConcreteProduct2的method2方法"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后，是抽象的工厂类和具体的工厂类：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 抽象的工厂类 * */</span><span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">Factory</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 运用了Java中的泛型和反射技术,生成某种具体的产品     * 其输入类型可以自行设置     * @param c     * @param &lt;T>     * @return     */</span>    <span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token operator">&lt;</span>T <span class="token keyword">extends</span> <span class="token class-name">Product</span><span class="token operator">></span> T <span class="token function">createProduct</span><span class="token punctuation">(</span>Class<span class="token operator">&lt;</span>T<span class="token operator">></span> c<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 具体生产产品的工厂类 * */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConcreteFactory</span> <span class="token keyword">extends</span> <span class="token class-name">Factory</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 运用了Java中的泛型和反射技术,生成某种具体的产品     * 其输入类型可以自行设置     * @param c     * @param &lt;T>     * @return     */</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token operator">&lt;</span>T <span class="token keyword">extends</span> <span class="token class-name">Product</span><span class="token operator">></span> T <span class="token function">createProduct</span><span class="token punctuation">(</span>Class<span class="token operator">&lt;</span>T<span class="token operator">></span> c<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Product product <span class="token operator">=</span> null<span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            product <span class="token operator">=</span> <span class="token punctuation">(</span>Product<span class="token punctuation">)</span> Class<span class="token punctuation">.</span><span class="token function">forName</span><span class="token punctuation">(</span>c<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">newInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"生产产品出错"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token punctuation">(</span>T<span class="token punctuation">)</span> product<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>最后，是客户端场景类：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 工厂方法模式客户端场景类 * */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Client</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Factory factory <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcreteFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Product product1 <span class="token operator">=</span> factory<span class="token punctuation">.</span><span class="token function">createProduct</span><span class="token punctuation">(</span>ConcreteProduct1<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        product1<span class="token punctuation">.</span><span class="token function">method1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        product1<span class="token punctuation">.</span><span class="token function">method2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Product product2 <span class="token operator">=</span> factory<span class="token punctuation">.</span><span class="token function">createProduct</span><span class="token punctuation">(</span>ConcreteProduct2<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        product2<span class="token punctuation">.</span><span class="token function">method1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        product2<span class="token punctuation">.</span><span class="token function">method2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="四、模式分析"><a href="#四、模式分析" class="headerlink" title="四、模式分析"></a>四、模式分析</h2><p>在工厂方法模式中，核心的工厂类不再负责所有产品的创建，而是将具体创建工作交给子类去做。这个核心类仅仅负责给出具体工厂必须实现的接口，而不负责哪一个产品类被实例化这种细节，这使得工厂方法模式可以允许系统在不修改工厂角色的情况下引进新产品。</p><h3 id="1-优点"><a href="#1-优点" class="headerlink" title="1. 优点"></a>1. 优点</h3><p>工厂方法模式的优点：</p><ul><li>在工厂方法模式中，工厂方法用来创建客户所需要的产品，同时还向客户隐藏了哪种具体产品类将被实例化这一细节，用户只需要关心所需产品对应的工厂，无须关心创建细节，甚至无须知道具体产品类的类名。</li><li>基于工厂角色和产品角色的多态性设计是工厂方法模式的关键。它能够使工厂可以自主确定创建何种产品对象，而如何创建这个对象的细节则完全封装在具体工厂内部。工厂方法模式之所以又被称为多态工厂模式，是因为所有的具体工厂类都具有同一抽象父类。</li><li>使用工厂方法模式的另一个优点是在系统中加入新产品时，无须修改抽象工厂和抽象产品提供的接口，无须修改客户端，也无须修改其他的具体工厂和具体产品，而只要添加一个具体工厂和具体产品就可以了。这样，系统的可扩展性也就变得非常好，完全符合“开闭原则”。</li></ul><h3 id="2-缺点"><a href="#2-缺点" class="headerlink" title="2. 缺点"></a>2. 缺点</h3><p>工厂方法模式的缺点：</p><ul><li>在添加新产品时，需要编写新的具体产品类，而且还要提供与之对应的具体工厂类，系统中类的个数将成对增加，在一定程度上增加了系统的复杂度，有更多的类需要编译和运行，会给系统带来一些额外的开销。</li><li>由于考虑到系统的可扩展性，需要引入抽象层，在客户端代码中均使用抽象层进行定义，增加了系统的抽象性和理解难度，且在实现时可能需要用到 DOM、反射等技术，增加了系统的实现难度。</li></ul><h3 id="3-适用环境"><a href="#3-适用环境" class="headerlink" title="3. 适用环境"></a>3. 适用环境</h3><p>在以下情况下可以使用工厂方法模式：</p><ul><li>一个类不知道它所需要的对象的类：在工厂方法模式中，客户端不需要知道具体产品类的类名，只需要知道所对应的工厂即可，具体的产品对象由具体工厂类创建；客户端需要知道创建具体产品的工厂类。</li><li>一个类通过其子类来指定创建哪个对象：在工厂方法模式中，对于抽象工厂类只需要提供一个创建产品的接口，而由其子类来确定具体要创建的对象，利用面向对象的多态性和里氏代换原则，在程序运行时，子类对象将覆盖父类对象，从而使得系统更容易扩展。</li><li>将创建对象的任务委托给多个工厂子类中的某一个，客户端在使用时可以无须关心是哪一个工厂子类创建产品子类，需要时再动态指定，可将具体工厂类的类名存储在配置文件或数据库中。</li></ul><h2 id="五、模式扩展"><a href="#五、模式扩展" class="headerlink" title="五、模式扩展"></a>五、模式扩展</h2><p>工厂方法模式有很多扩展，而且与其他模式结合使用威力更大，下面介绍 4 种常用扩展。</p><h3 id="1-简单工厂模式"><a href="#1-简单工厂模式" class="headerlink" title="1. 简单工厂模式"></a>1. 简单工厂模式</h3><p>我们这样考虑一个问题：一个模块仅需要一个工厂类，没有必要把它产生出来，使用静态的方法就可以了。因此去掉工厂类中继承的抽象类，把方法改成静态即可。通用代码如下：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 简单工厂模式中的工厂类 * */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SimpleFactory</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 运用了Java中的泛型和反射技术,生成某种具体的产品     * 其输入类型可以自行设置     * @param c     * @param &lt;T>     * @return     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span>  <span class="token operator">&lt;</span>T <span class="token keyword">extends</span> <span class="token class-name">Product</span><span class="token operator">></span> T <span class="token function">createProduct</span><span class="token punctuation">(</span>Class<span class="token operator">&lt;</span>T<span class="token operator">></span> c<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Product product <span class="token operator">=</span> null<span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            product <span class="token operator">=</span> <span class="token punctuation">(</span>Product<span class="token punctuation">)</span> Class<span class="token punctuation">.</span><span class="token function">forName</span><span class="token punctuation">(</span>c<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">newInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"生产产品出错"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token punctuation">(</span>T<span class="token punctuation">)</span> product<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 简单工厂模式客户端场景类 * */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SimpleClient</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Product product1 <span class="token operator">=</span> SimpleFactory<span class="token punctuation">.</span><span class="token function">createProduct</span><span class="token punctuation">(</span>ConcreteProduct1<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        product1<span class="token punctuation">.</span><span class="token function">method1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        product1<span class="token punctuation">.</span><span class="token function">method2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Product product2 <span class="token operator">=</span> SimpleFactory<span class="token punctuation">.</span><span class="token function">createProduct</span><span class="token punctuation">(</span>ConcreteProduct2<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        product2<span class="token punctuation">.</span><span class="token function">method1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        product2<span class="token punctuation">.</span><span class="token function">method2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行结果没有发生变化，但是类图简单了，调用者也比较简单，简单工厂模式是工厂方法模式的弱化，也叫做静态工厂模式。其缺点是工厂类的扩展比较困难，不符合“开闭原则”，但它仍然是一个非常实用的设计模式。</p><h3 id="2-多工厂类工厂方法模式"><a href="#2-多工厂类工厂方法模式" class="headerlink" title="2. 多工厂类工厂方法模式"></a>2. 多工厂类工厂方法模式</h3><p>当我们在一个比较复杂的项目时，经常会遇到初始化一个对象很耗费精力的情况，所有的产品类都放到一个工厂方法中进行初始化会使代码结构不清晰。为了让结构清晰，我们就为每类产品定义一个创造者，然后由调用者自己去选择与哪个工厂方法关联。多工厂模式的通用代码如下：</p><p>多工厂模式的抽象工厂类：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 生成多个产品的抽象工厂类 * */</span><span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">MultiFactory</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 生成某种产品的方法     * @return     */</span>    <span class="token keyword">public</span> <span class="token keyword">abstract</span> Product <span class="token function">createProduct</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>第一种产品的创建工厂实现：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 生成产品1的具体工厂类1 * */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConcreteFactory1</span> <span class="token keyword">extends</span> <span class="token class-name">MultiFactory</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 生成产品1的方法     * @return     */</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> Product <span class="token function">createProduct</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ConcreteProduct1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>第二种产品的创建工厂实现：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 生成产品2的具体工厂类2 * */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConcreteFactory2</span> <span class="token keyword">extends</span> <span class="token class-name">MultiFactory</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 生成产品2的方法     * @return     */</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> Product <span class="token function">createProduct</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ConcreteProduct2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>多工厂模式的客户端场景类</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 多工厂方法模式客户端场景类 * */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MultiClient</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Product concreteProduct1 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ConcreteFactory1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">createProduct</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        concreteProduct1<span class="token punctuation">.</span><span class="token function">method1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        concreteProduct1<span class="token punctuation">.</span><span class="token function">method2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Product concreteProduct2 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ConcreteFactory2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">createProduct</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        concreteProduct1<span class="token punctuation">.</span><span class="token function">method1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        concreteProduct1<span class="token punctuation">.</span><span class="token function">method2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-工厂方法的单例模式"><a href="#3-工厂方法的单例模式" class="headerlink" title="3. 工厂方法的单例模式"></a>3. 工厂方法的单例模式</h3><p>单例模式的核心要求就是在内存中只有一个对象，通过工厂方法模式也可以只在内存中生成一个对象，从而实现单例的功能。</p><p>下面是单例类，其中定义了一个 private 的无参构造函数，目的是不允许通过 new 的方式创建对象，代码如下：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 工厂方法模式中的单例类 * */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Singleton</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 私有化构造方法，不允许new产生一个对象     */</span>    <span class="token keyword">private</span> <span class="token function">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 工厂方法模式中的单例模式业务方法     */</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">doSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"工厂方法模式中的单例模式方法。。。"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>以上单例类中不能通过正常的渠道建立一个对象，那单例的工厂类中如何建立一个单例对象呢？答案是通过反射方式创建，单例工厂类的代码如下：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 生成单例的工厂类 * */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SingletonFactory</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> Singleton singleton<span class="token punctuation">;</span>    <span class="token keyword">static</span> <span class="token punctuation">{</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            Class <span class="token class-name">c</span> <span class="token operator">=</span> Class<span class="token punctuation">.</span><span class="token function">forName</span><span class="token punctuation">(</span>Singleton<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 获得无参构造</span>            Constructor constructor <span class="token operator">=</span> c<span class="token punctuation">.</span><span class="token function">getDeclaredConstructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 设置无参构造是可访问的</span>            constructor<span class="token punctuation">.</span><span class="token function">setAccessible</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 产生一个实例对象</span>            singleton <span class="token operator">=</span> <span class="token punctuation">(</span>Singleton<span class="token punctuation">)</span> constructor<span class="token punctuation">.</span><span class="token function">newInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"生成单例的工厂类方法中生成单例出错"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>zuihou        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> Singleton <span class="token function">getSingleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> singleton<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>最后是工厂方法单例模式的客户端场景类：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 工厂方法单例模式客户端场景类 * */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SingleClient</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Singleton singleton <span class="token operator">=</span> SingletonFactory<span class="token punctuation">.</span><span class="token function">getSingleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        singleton<span class="token punctuation">.</span><span class="token function">doSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4-工厂方法的延迟初始化"><a href="#4-工厂方法的延迟初始化" class="headerlink" title="4. 工厂方法的延迟初始化"></a>4. 工厂方法的延迟初始化</h3><p>何为延迟初始化？一个对象被消费完毕后，并不立即释放，工厂类保持其初始状态，等待再次使用。延迟初始化是工厂模式的一个扩展应用，其通用代码如下：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 延迟加载的工厂类 * */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">LazyFactory</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Product<span class="token operator">></span> lazyMap <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Product<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">synchronized</span> Product <span class="token function">createProduct</span><span class="token punctuation">(</span>String type<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Product product <span class="token operator">=</span> null<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 如果map中已经有这个对象，则直接取出该对象即可，否则创建并放在缓存容器中</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>lazyMap<span class="token punctuation">.</span><span class="token function">containsKey</span><span class="token punctuation">(</span>type<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> lazyMap<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>type<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 根据类型创建具体的产品对象</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token string">"product1"</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>type<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            product <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcreteProduct1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            product <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcreteProduct2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 同时把对象放到缓存容器中</span>        lazyMap<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"type"</span><span class="token punctuation">,</span> product<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> product<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面即为延迟加载的工厂类。代码比较简单，通过定义一个<code>map</code>容器来容纳所有产生的对象，如果在<code>map</code>容器中已经有的对象，则直接取出返回；如果没有，则根据需要的类型产生一个对象并放入到<code>map</code>容器中，以便下次调用。</p><p>延迟加载的工厂模式客户端场景类代码如下：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 延迟加载的工厂模式客户端场景类 * */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">LazyClient</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Product product1 <span class="token operator">=</span> LazyFactory<span class="token punctuation">.</span><span class="token function">createProduct</span><span class="token punctuation">(</span><span class="token string">"product1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Product product11 <span class="token operator">=</span> LazyFactory<span class="token punctuation">.</span><span class="token function">createProduct</span><span class="token punctuation">(</span><span class="token string">"product1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h2><ul><li>工厂方法模式又称为工厂模式，它属于类创建型模式。在工厂方法模式中，工厂父类负责定义创建产品对象的公共接口，而工厂子类则负责生成具体的产品对象，这样做的目的是将产品类的实例化操作延迟到工厂子类中完成，即通过工厂子类来确定究竟应该实例化哪一个具体产品类。</li><li>工厂方法模式包含四个角色：抽象产品是定义产品的接口，是工厂方法模式所创建对象的超类型，即产品对象的共同父类或接口；具体产品实现了抽象产品接口，某种类型的具体产品由专门的具体工厂创建，它们之间往往一一对应；抽象工厂中声明了工厂方法，用于返回一个产品，它是工厂方法模式的核心，任何在模式中创建对象的工厂类都必须实现该接口；具体工厂是抽象工厂类的子类，实现了抽象工厂中定义的工厂方法，并可由客户调用，返回一个具体产品类的实例。</li><li>工厂方法模式是简单工厂模式的进一步抽象和推广。由于使用了面向对象的多态性，工厂方法模式保持了简单工厂模式的优点，而且克服了它的缺点。在工厂方法模式中，核心的工厂类不再负责所有产品的创建，而是将具体创建工作交给子类去做。这个核心类仅仅负责给出具体工厂必须实现的接口，而不负责产品类被实例化这种细节，这使得工厂方法模式可以允许系统在不修改工厂角色的情况下引进新产品。</li><li>工厂方法模式的主要优点是增加新的产品类时无须修改现有系统，并封装了产品对象的创建细节，系统具有良好的灵活性和可扩展性；其缺点在于增加新产品的同时需要增加新的工厂，导致系统类的个数成对增加，在一定程度上增加了系统的复杂性。</li><li>工厂方法模式适用情况包括：一个类不知道它所需要的对象的类；一个类通过其子类来指定创建哪个对象；将创建对象的任务委托给多个工厂子类中的某一个，客户端在使用时可以无须关心是哪一个工厂子类创建产品子类，需要时再动态指定。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 软件设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 设计原则与模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>装饰模式（Decorator Pattern）</title>
      <link href="/2018/091461471.html"/>
      <url>/2018/091461471.html</url>
      
        <content type="html"><![CDATA[<h2 id="一、模式动机"><a href="#一、模式动机" class="headerlink" title="一、模式动机"></a>一、模式动机</h2><p>一般有两种方式可以实现给一个类或对象增加行为：</p><ul><li><strong>继承机制</strong>，使用继承机制是给现有类添加功能的一种有效途径，通过继承一个现有类可以使得子类在拥有自身方法的同时还拥有父类的方法。但是这种方法是静态的，用户不能控制增加行为的方式和时机。</li><li><strong>关联机制</strong>，即将一个类的对象嵌入另一个对象中，由另一个对象来决定是否调用嵌入对象的行为以便扩展自己的行为，我们称这个嵌入的对象为装饰器(Decorator)</li></ul><p><strong>装饰模式以对客户透明的方式动态地给一个对象附加上更多的责任</strong>，换言之，客户端并不会觉得对象在装饰前和装饰后有什么不同。<strong>装饰模式可以在不需要创造更多子类的情况下，将对象的功能加以扩展</strong>。这就是装饰模式的模式动机。</p><h2 id="二、模式定义"><a href="#二、模式定义" class="headerlink" title="二、模式定义"></a>二、模式定义</h2><blockquote><p><strong>装饰模式(Decorator Pattern) ：动态地给一个对象增加一些额外的职责(Responsibility)</strong>，就增加对象功能来说，装饰模式比生成子类实现更为灵活。其别名也可以称为包装器(Wrapper)，与适配器模式的别名相同，但它们适用于不同的场合。根据翻译的不同，装饰模式也有人称之为“油漆工模式”。</p></blockquote><p>策略模式是一种<strong>对象结构型</strong>模式。</p><h2 id="三、-模式结构"><a href="#三、-模式结构" class="headerlink" title="三、 模式结构"></a>三、 模式结构</h2><p>装饰模式包含如下角色：</p><ul><li><code>Component</code>: 抽象构件</li><li><code>ConcreteComponent</code>: 具体构件</li><li><code>Decorator</code>: 抽象装饰类</li><li><code>ConcreteDecorator</code>: 具体装饰类</li></ul><h3 id="结构图"><a href="#结构图" class="headerlink" title="结构图"></a>结构图</h3><p><img src="https://pic.lixl.cn/2019/Decorator.jpg" alt="装饰模式结构图"></p><h3 id="时序图"><a href="#时序图" class="headerlink" title="时序图"></a>时序图</h3><p><img src="https://pic.lixl.cn/2019/seq_Decorator.jpg" alt="装饰模式时序图"></p><h2 id="四、示例代码"><a href="#四、示例代码" class="headerlink" title="四、示例代码"></a>四、示例代码</h2><p>首先定义一个抽象构件接口：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 抽象构件 * */</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Component</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 接口方法</span>    <span class="token keyword">void</span> <span class="token function">operate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后是具体构件实现类：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 具体构件 * */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConcreteComponent</span> <span class="token keyword">implements</span> <span class="token class-name">Component</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 具体实现方法     */</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">operate</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"do Something..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>接着是装饰角色：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 装饰角色 * 维持一个指向Component对象的引用，并定义一个与 Component接口一致的接口。 * */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Decorator</span> <span class="token keyword">implements</span> <span class="token class-name">Component</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> Component component<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * 通过构造函数传递被修饰者     * @param component     */</span>    <span class="token keyword">public</span> <span class="token function">Decorator</span><span class="token punctuation">(</span>Component component<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>component <span class="token operator">=</span> component<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 委托给被修饰者执行     */</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">operate</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>component<span class="token punctuation">.</span><span class="token function">operate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>下面是具体的装饰类：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 具体的装饰类1 * */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConcreteDecorator1</span> <span class="token keyword">extends</span> <span class="token class-name">Decorator</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 通过构造函数传递被修饰者     * @param component     */</span>    <span class="token keyword">public</span> <span class="token function">ConcreteDecorator1</span><span class="token punctuation">(</span>Component component<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">super</span><span class="token punctuation">(</span>component<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 定义自己的修饰方法1     */</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">method1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"method1修饰..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 重写父类的operate方法     */</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">operate</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">method1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">operate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 具体的装饰类2 * */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConcreteDecorator2</span> <span class="token keyword">extends</span> <span class="token class-name">Decorator</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 通过构造函数传递被修饰者     * @param component     */</span>    <span class="token keyword">public</span> <span class="token function">ConcreteDecorator2</span><span class="token punctuation">(</span>Component component<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">super</span><span class="token punctuation">(</span>component<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 定义自己的修饰方法2     */</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">method2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"method2修饰..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 重写父类的operate方法     */</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">operate</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">method2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">operate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>最后是客户端的场景类：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 装饰模式的客户端场景类 * */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Client</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Component component <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcreteComponent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 第一修饰</span>        component <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcreteDecorator1</span><span class="token punctuation">(</span>component<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 第二修饰</span>        component <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcreteDecorator2</span><span class="token punctuation">(</span>component<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 修饰后运行</span>        component<span class="token punctuation">.</span><span class="token function">operate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="五、模式分析"><a href="#五、模式分析" class="headerlink" title="五、模式分析"></a>五、模式分析</h2><h3 id="总体分析"><a href="#总体分析" class="headerlink" title="总体分析"></a>总体分析</h3><ul><li><strong>与继承关系相比，关联关系的主要优势在于不会破坏类的封装性，而且继承是一种耦合度较大的静态关系，无法在程序运行时动态扩展</strong>。在软件开发阶段，关联关系虽然不会比继承关系减少编码量，但是到了软件维护阶段，由于关联关系使系统具有较好的松耦合性，因此使得系统更加容易维护。当然，<em>关联关系的缺点是比继承关系要创建更多的对象</em>。</li><li><strong>使用装饰模式来实现扩展比继承更加灵活，它以对客户透明的方式动态地给一个对象附加更多的责任</strong>。装饰模式可以在不需要创造更多子类的情况下，将对象的功能加以扩展。</li></ul><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p>装饰模式的优点：</p><ul><li>装饰模式与继承关系的目的都是要扩展对象的功能，但是装饰模式可以提供比继承更多的灵活性。</li><li>可以通过一种动态的方式来扩展一个对象的功能，通过配置文件可以在运行时选择不同的装饰器，从而实现不同的行为。</li><li>通过使用不同的具体装饰类以及这些装饰类的排列组合，可以创造出很多不同行为的组合。可以使用多个具体装饰类来装饰同一对象，得到功能更为强大的对象。</li><li>具体构件类与具体装饰类可以独立变化，用户可以根据需要增加新的具体构件类和具体装饰类，在使用时再对其进行组合，原有代码无须改变，符合“开闭原则”。</li></ul><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>装饰模式的缺点：</p><ul><li>使用装饰模式进行系统设计时将产生很多小对象，这些对象的区别在于它们之间相互连接的方式有所不同，而不是它们的类或者属性值有所不同，同时还将产生很多具体装饰类。这些装饰类和小对象的产生将增加系统的复杂度，加大学习与理解的难度。</li><li>这种比继承更加灵活机动的特性，也同时意味着装饰模式比继承更加易于出错，排错也很困难，对于多次装饰的对象，调试时寻找错误可能需要逐级排查，较为烦琐。</li></ul><h3 id="适用环境"><a href="#适用环境" class="headerlink" title="适用环境"></a>适用环境</h3><p>在以下情况下可以使用装饰模式：</p><ul><li>在不影响其他对象的情况下，以动态、透明的方式给单个对象添加职责。</li><li>需要动态地给一个对象增加功能，这些功能也可以动态地被撤销。</li><li>当不能采用继承的方式对系统进行扩充或者采用继承不利于系统扩展和维护时。不能采用继承的情况主要有两类：第一类是系统中存在大量独立的扩展，为支持每一种组合将产生大量的子类，使得子类数目呈爆炸性增长；第二类是因为类定义不能继承（如final类）。</li></ul><h3 id="模式扩展"><a href="#模式扩展" class="headerlink" title="模式扩展"></a>模式扩展</h3><p>装饰模式的简化-需要注意的问题:</p><ul><li>一个装饰类的接口必须与被装饰类的接口保持相同，对于客户端来说无论是装饰之前的对象还是装饰之后的对象都可以一致对待。</li><li>尽量保持具体构件类Component作为一个“轻”类，也就是说不要把太多的逻辑和状态放在具体构件类中，可以通过装饰类。</li><li>如果只有一个具体构件类而没有抽象构件类，那么抽象装饰类可以作为具体构件类的直接子类。</li></ul><h2 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h2><ul><li>装饰模式用于动态地给一个对象增加一些额外的职责，就增加对象功 能来说，装饰模式比生成子类实现更为灵活。它是一种对象结构型模式。</li><li>装饰模式包含四个角色：抽象构件定义了对象的接口，可以给这些对 象动态增加职责（方法）；具体构件定义了具体的构件对象，实现了 在抽象构件中声明的方法，装饰器可以给它增加额外的职责（方法）； 抽象装饰类是抽象构件类的子类，用于给具体构件增加职责，但是具 体职责在其子类中实现；具体装饰类是抽象装饰类的子类，负责向构 件添加新的职责。</li><li>使用装饰模式来实现扩展比继承更加灵活，它以对客户透明的方式动 态地给一个对象附加更多的责任。装饰模式可以在不需要创造更多子 类的情况下，将对象的功能加以扩展。</li><li>装饰模式的主要优点在于可以提供比继承更多的灵活性，可以通过一种动态的方式来扩展一个对象的功能，并通过使用不同的具体装饰类以及这些装饰类的排列组合，可以创造出很多不同行为的组合，而且具体构件类与具体装饰类可以独立变化，用户可以根据需要增加新的具体构件类和具体装饰类；其主要缺点在于使用装饰模式进行系统设计时将产生很多小对象，而且装饰模式比继承更加易于出错，排错也很困难，对于多次装饰的对象，调试时寻找错误可能需要逐级排查，较为烦琐。</li><li>装饰模式适用情况包括：在不影响其他对象的情况下，以动态、透明的方式给单个对象添加职责；需要动态地给一个对象增加功能，这些功能也可以动态地被撤销；当不能采用继承的方式对系统进行扩充或者采用继承不利于系统扩展 和维护时。</li><li>装饰模式可分为透明装饰模式和半透明装饰模式：在透明装饰模式中，要求客户端完全针对抽象编程，装饰模式的透明性要求客户端程序不应该声明具体构件类型和具体装饰类型，而应该全部声明为抽象构件类型；半透明装饰模式允许用户在客户端声明具体装饰者类型的对象，调用在具体装饰者中新增的方法。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 软件设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 设计原则与模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>策略模式（Strategy Pattern）</title>
      <link href="/2018/09149157.html"/>
      <url>/2018/09149157.html</url>
      
        <content type="html"><![CDATA[<h2 id="一、模式动机"><a href="#一、模式动机" class="headerlink" title="一、模式动机"></a>一、模式动机</h2><p>完成一项任务，往往可以有多种不同的方式，每一种方式称为一个策略，我们可以根据环境或者条件的不同选择不同的策略来完成该项任务。在软件开发中也常常遇到类似的情况，实现某一个功能有多个途径，此时可以使用一种设计模式来使得系统可以灵活地选择解决途径，也能够方便地增加新的解决途径。</p><p>在软件系统中，有许多算法可以实现某一功能，如查找、排序等，一种常用的方法是硬编码(<code>Hard Coding</code>)在一个类中，如需要提供多种查找算法，可以将这些算法写到一个类中，在该类中提供多个方法，每一个方法对应一个具体的查找算法；当然也可以将这些查找算法封装在一个统一的方法中，通过 if…else…等条件判断语句来进行选择。这两种实现方法我们都可以称之为硬编码，如果需要增加一种新的查找算法，需要修改封装算法类的源代码；更换查找算法，也需要修改客户端调用代码。在这个算法类中封装了大量查找算法，该类代码将较复杂，维护较为困难。</p><p>除了提供专门的查找算法类之外，还可以在客户端程序中直接包含算法代码，这种做法更不可取，将导致客户端程序庞大而且难以维护，如果存在大量可供选择的算法时问题将变得更加严重。</p><p>为了解决这些问题，可以<strong>定义一些独立的类来封装不同的算法，每一个类封装一个具体的算法，在这里，每一个封装算法的类我们都可以称之为策略(Strategy)，为了保证这些策略的一致性，一般会用一个抽象的策略类来做算法的定义，而具体每种算法则对应于一个具体策略类</strong>。</p><h2 id="二、模式定义"><a href="#二、模式定义" class="headerlink" title="二、模式定义"></a>二、模式定义</h2><blockquote><p><strong>策略模式(Strategy Pattern)：定义一系列算法，将每一个算法封装起来，并让它们可以相互替换。策略模式让算法独立于使用它的客户而变化，也称为政策模式(Policy)</strong>。</p></blockquote><p>策略模式是一种对象行为型模式。</p><h2 id="三、-模式结构"><a href="#三、-模式结构" class="headerlink" title="三、 模式结构"></a>三、 模式结构</h2><p>策略模式包含如下角色：</p><ul><li>Context: 环境类</li><li>Strategy: 抽象策略类</li><li>ConcreteStrategy: 具体策略类</li></ul><h3 id="结构图"><a href="#结构图" class="headerlink" title="结构图"></a>结构图</h3><p><img src="https://pic.lixl.cn/2019/Strategy1.jpg" alt="策略模式结构图"></p><h3 id="时序图"><a href="#时序图" class="headerlink" title="时序图"></a>时序图</h3><p><img src="https://pic.lixl.cn/2019/strategy2.jpg" alt="策略模式时序图"></p><h2 id="四、示例代码"><a href="#四、示例代码" class="headerlink" title="四、示例代码"></a>四、示例代码</h2><p>首先定义一个策略接口：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">IStrategy</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 策略模式的运算法则     */</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">doSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后是具体的策略实现类：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConcreteStrategy1</span> <span class="token keyword">implements</span> <span class="token class-name">IStrategy</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">doSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"具体策略的策略方法1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConcreteStrategy2</span> <span class="token keyword">implements</span> <span class="token class-name">IStrategy</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">doSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"具体策略的策略方法2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>接着是封装角色的类：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Context</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 抽象策略</span>    <span class="token keyword">private</span> IStrategy strategy<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * 构造函数设置具体策略     * @param strategy     */</span>    <span class="token keyword">public</span> <span class="token function">Context</span><span class="token punctuation">(</span>IStrategy strategy<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>strategy <span class="token operator">=</span> strategy<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 封装后的策略方法     */</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">doAnything</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>strategy<span class="token punctuation">.</span><span class="token function">doSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>最后是客户端的调用策略类：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Client</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 声明一个具体的策略</span>        IStrategy strategy <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcreteStrategy1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 声明上下文对象</span>        Context context <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Context</span><span class="token punctuation">(</span>strategy<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 执行封装后的方法</span>        context<span class="token punctuation">.</span><span class="token function">doAnything</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="五、模式分析"><a href="#五、模式分析" class="headerlink" title="五、模式分析"></a>五、模式分析</h2><h3 id="总体分析"><a href="#总体分析" class="headerlink" title="总体分析"></a>总体分析</h3><ul><li>策略模式是一个比较容易理解和使用的设计模式，策略模式是对算法的封装，它把算法的责任和算法本身分割开，委派给不同的对象管理。策略模式通常把一个系列的算法封装到一系列的策略类里面，作为一个抽象策略类的子类。用一句话来说，就是“<strong>准备一组算法，并将每一个算法封装起来，使得它们可以互换</strong>”。</li><li>在策略模式中，应当由客户端自己决定在什么情况下使用什么具体策略角色。</li><li>策略模式仅仅封装算法，提供新算法插入到已有系统中，以及老算法从系统中“退休”的方便，策略模式并不决定在何时使用何种算法，算法的选择由客户端来决定。这在一定程度上提高了系统的灵活性，但是客户端需要理解所有具体策略类之间的区别，以便选择合适的算法，这也是策略模式的缺点之一，在一定程度上增加了客户端的使用难度。</li></ul><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p>策略模式的优点：</p><ul><li>策略模式提供了对“开闭原则”的完美支持，用户可以在不修改原有系统的基- 础上选择算法或行为，也可以灵活地增加新的算法或行为。</li><li>策略模式提供了管理相关的算法族的办法。</li><li>策略模式提供了可以替换继承关系的办法。</li><li>使用策略模式可以避免使用多重条件转移语句。</li></ul><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>策略模式的缺点：</p><ul><li>客户端必须知道所有的策略类，并自行决定使用哪一个策略类。</li><li>策略模式将造成产生很多策略类，可以通过使用享元模式在一定程度上减少对象的数量。</li></ul><h3 id="适用环境"><a href="#适用环境" class="headerlink" title="适用环境"></a>适用环境</h3><p>在以下情况下可以使用策略模式：</p><ul><li>如果在一个系统里面有许多类，它们之间的区别仅在于它们的行为，那么使用策略模式可以动态地让一个对象在许多行为中选择一种行为。</li><li>一个系统需要动态地在几种算法中选择一种。</li><li>如果一个对象有很多的行为，如果不用恰当的模式，这些行为就只好使用多重的条件选择语句来实现。</li><li>不希望客户端知道复杂的、与算法相关的数据结构，在具体策略类中封装算法和相关的数据结构，提高算法的保密性与安全性。</li></ul><h3 id="模式扩展"><a href="#模式扩展" class="headerlink" title="模式扩展"></a>模式扩展</h3><p>策略模式与状态模式：</p><ul><li>可以通过环境类状态的个数来决定是使用策略模式还是状态模式。</li><li>策略模式的环境类自己选择一个具体策略类，具体策略类无须关心环境类；而状态模式的环境类由于外在因素需要放进一个具体状态中，以便通过其方法实现状态的切换，因此环境类和状态类之间存在一种双向的关联关系。</li><li>使用策略模式时，客户端需要知道所选的具体策略是哪一个，而使用状态模式时，客户端无须关心具体状态，环境类的状态会根据用户的操作自动转换。</li><li>如果系统中某个类的对象存在多种状态，不同状态下行为有差异，而且这些状态之间可以发生转换时使用状态模式；如果系统中某个类的某一行为存在多种实现方式，而且这些实现方式可以互换时使用策略模式。</li></ul><h2 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h2><ul><li>在策略模式中定义了一系列算法，将每一个算法封装起来，并让它们可以相互替换。策略模式让算法独立于使用它的客户而变化，也称为政策模式。策略模式是一种对象行为型模式。</li><li>策略模式包含三个角色：环境类在解决某个问题时可以采用多种策略，在环境类中维护一个对抽象策略类的引用实例；抽象策略类为所支持的算法声明了抽象方法，是所有策略类的父类；具体策略类实现了在抽象策略类中定义的算法。</li><li>策略模式是对算法的封装，它把算法的责任和算法本身分割开，委派给不同的对象管理。策略模式通常把一个系列的算法封装到一系列的策略类里面，作为一个抽象策略类的子类。</li><li>策略模式主要优点在于对“开闭原则”的完美支持，在不修改原有系统的基础上可以更换算法或者增加新的算法，它很好地管理算法族，提高了代码的复用性，是一种替换继承，避免多重条件转移语句的实现方式；其缺点在于客户端必须知道所有的策略类，并理解其区别，同时在一定程度上增加了系统中类的个数，可能会存在很多策略类。</li><li>策略模式适用情况包括：在一个系统里面有许多类，它们之间的区别仅在于它们的行为，使用策略模式可以动态地让一个对象在许多行为中选择一种行为；一个系统需要动态地在几种算法中选择一种；避免使用难以维护的多重条件选择语句；希望在具体策略类中封装算法和与相关的数据结构。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 软件设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 设计原则与模式 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
